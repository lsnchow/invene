"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   EdgeToolbar: () => (/* binding */ EdgeToolbar),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   MiniMapNode: () => (/* binding */ MiniMapNode),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   experimental_useOnEdgesChangeMiddleware: () => (/* binding */ experimental_useOnEdgesChangeMiddleware),\n/* harmony export */   experimental_useOnNodesChangeMiddleware: () => (/* binding */ experimental_useOnNodesChangeMiddleware),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,EdgeToolbar,Handle,MiniMap,MiniMapNode,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,experimental_useOnEdgesChangeMiddleware,experimental_useOnNodesChangeMiddleware,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error001\"]();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector - A selector function that returns a slice of the flow's internal state.\n * Extracting or transforming just the state you need is a good practice to avoid unnecessary\n * re-renders.\n * @param equalityFn - A function to compare the previous and next value. This is incredibly useful\n * for preventing unnecessary re-renders. Good sensible defaults are using `Object.is` or importing\n * `zustand/shallow`, but you can be as granular as you like.\n * @returns The selected state slice.\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object.\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            getState: store.getState,\n            setState: store.setState,\n            subscribe: store.subscribe\n        }), [\n        store\n    ]);\n}\nconst style = {\n    display: \"none\"\n};\nconst ariaLiveStyle = {\n    position: \"absolute\",\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0px, 0px, 0px, 0px)\",\n    clipPath: \"inset(100%)\"\n};\nconst ARIA_NODE_DESC_KEY = \"react-flow__node-desc\";\nconst ARIA_EDGE_DESC_KEY = \"react-flow__edge-desc\";\nconst ARIA_LIVE_MESSAGE = \"react-flow__aria-live\";\nconst ariaLiveSelector = (s)=>s.ariaLiveMessage;\nconst ariaLabelConfigSelector = (s)=>s.ariaLabelConfig;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(ariaLiveSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    const ariaLabelConfig = useStore(ariaLabelConfigSelector);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: disableKeyboardA11y ? ariaLabelConfig[\"node.a11yDescription.default\"] : ariaLabelConfig[\"node.a11yDescription.keyboardDisabled\"]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: ariaLabelConfig[\"edge.a11yDescription.default\"]\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = \"top-left\", children, className, style, ...rest }, ref)=>{\n    const positionClasses = `${position}`.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__panel\",\n            className,\n            ...positionClasses\n        ]),\n        style: style,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = \"Panel\";\nfunction Attribution({ proOptions, position = \"bottom-right\" }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const params = {\n            nodes: selectedNodes,\n            edges: selectedEdges\n        };\n        onSelectionChange?.(params);\n        store.getState().onSelectionChangeHandlers.forEach((fn)=>fn(params));\n    }, [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // These fields exist in the global store, and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    \"nodes\",\n    \"edges\",\n    \"defaultNodes\",\n    \"defaultEdges\",\n    \"onConnect\",\n    \"onConnectStart\",\n    \"onConnectEnd\",\n    \"onClickConnectStart\",\n    \"onClickConnectEnd\",\n    \"nodesDraggable\",\n    \"autoPanOnNodeFocus\",\n    \"nodesConnectable\",\n    \"nodesFocusable\",\n    \"edgesFocusable\",\n    \"edgesReconnectable\",\n    \"elevateNodesOnSelect\",\n    \"elevateEdgesOnSelect\",\n    \"minZoom\",\n    \"maxZoom\",\n    \"nodeExtent\",\n    \"onNodesChange\",\n    \"onEdgesChange\",\n    \"elementsSelectable\",\n    \"connectionMode\",\n    \"snapGrid\",\n    \"snapToGrid\",\n    \"translateExtent\",\n    \"connectOnClick\",\n    \"defaultEdgeOptions\",\n    \"fitView\",\n    \"fitViewOptions\",\n    \"onNodesDelete\",\n    \"onEdgesDelete\",\n    \"onDelete\",\n    \"onNodeDrag\",\n    \"onNodeDragStart\",\n    \"onNodeDragStop\",\n    \"onSelectionDrag\",\n    \"onSelectionDragStart\",\n    \"onSelectionDragStop\",\n    \"onMoveStart\",\n    \"onMove\",\n    \"onMoveEnd\",\n    \"noPanClassName\",\n    \"nodeOrigin\",\n    \"autoPanOnConnect\",\n    \"autoPanOnNodeDrag\",\n    \"onError\",\n    \"connectionRadius\",\n    \"isValidConnection\",\n    \"selectNodesOnDrag\",\n    \"nodeDragThreshold\",\n    \"connectionDragThreshold\",\n    \"onBeforeDelete\",\n    \"debug\",\n    \"autoPanSpeed\",\n    \"ariaLabelConfig\",\n    \"zIndexMode\"\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    \"rfId\"\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: \"nopan\",\n    rfId: \"1\"\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n        return ()=>{\n            // when we reset the store we also need to reset the previous fields\n            previousFields.current = initPrevValues;\n            reset();\n        };\n    }, []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        for (const fieldName of fieldsToTrack){\n            const fieldValue = props[fieldName];\n            const previousFieldValue = previousFields.current[fieldName];\n            if (fieldValue === previousFieldValue) continue;\n            if (typeof props[fieldName] === \"undefined\") continue;\n            // Custom handling with dedicated setters for some fields\n            if (fieldName === \"nodes\") setNodes(fieldValue);\n            else if (fieldName === \"edges\") setEdges(fieldValue);\n            else if (fieldName === \"minZoom\") setMinZoom(fieldValue);\n            else if (fieldName === \"maxZoom\") setMaxZoom(fieldValue);\n            else if (fieldName === \"translateExtent\") setTranslateExtent(fieldValue);\n            else if (fieldName === \"nodeExtent\") setNodeExtent(fieldValue);\n            else if (fieldName === \"ariaLabelConfig\") store.setState({\n                ariaLabelConfig: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.mergeAriaLabelConfig)(fieldValue)\n            });\n            else if (fieldName === \"fitView\") store.setState({\n                fitViewQueued: fieldValue\n            });\n            else if (fieldName === \"fitViewOptions\") store.setState({\n                fitViewOptions: fieldValue\n            });\n            else store.setState({\n                [fieldName]: fieldValue\n            });\n        }\n        previousFields.current = props;\n    }, // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map((fieldName)=>props[fieldName]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia(\"(prefers-color-scheme: dark)\");\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === \"system\" ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (colorMode !== \"system\") {\n            setColorModeClass(colorMode);\n            return;\n        }\n        const mediaQuery = getMediaQuery();\n        const updateColorModeClass = ()=>setColorModeClass(mediaQuery?.matches ? \"dark\" : \"light\");\n        updateColorModeClass();\n        mediaQuery?.addEventListener(\"change\", updateColorModeClass);\n        return ()=>{\n            mediaQuery?.removeEventListener(\"change\", updateColorModeClass);\n        };\n    }, [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? \"dark\" : \"light\";\n}\nconst defaultDoc = typeof document !== \"undefined\" ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param options - Options\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/**\n * The key code (string or array of strings) specifies which key(s) should trigger\n * an action.\n *\n * A **string** can represent:\n * - A **single key**, e.g. `'a'`\n * - A **key combination**, using `'+'` to separate keys, e.g. `'a+d'`\n *\n * An  **array of strings** represents **multiple possible key inputs**. For example, `['a', 'd+s']`\n * means the user can press either the single key `'a'` or the combination of `'d'` and `'s'`.\n * @default null\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (keyCode !== null) {\n            const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                keyCode\n            ];\n            const keys = keyCodeArr.filter((kc)=>typeof kc === \"string\")/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map((kc)=>kc.replace(\"+\", \"\\n\").replace(\"\\n\\n\", \"\\n+\").split(\"\\n\"));\n            const keysFlat = keys.reduce((res, item)=>res.concat(...item), []);\n            return [\n                keys,\n                keysFlat\n            ];\n        }\n        return [\n            [],\n            []\n        ];\n    }, [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const target = options?.target ?? defaultDoc;\n        const actInsideInputWithModifier = options?.actInsideInputWithModifier ?? true;\n        if (keyCode !== null) {\n            const downHandler = (event)=>{\n                modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey || event.altKey;\n                const preventAction = (!modifierPressed.current || modifierPressed.current && !actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                if (preventAction) {\n                    return false;\n                }\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                pressedKeys.current.add(event[keyOrCode]);\n                if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                    const target = event.composedPath?.()?.[0] || event.target;\n                    const isInteractiveElement = target?.nodeName === \"BUTTON\" || target?.nodeName === \"A\";\n                    if (options.preventDefault !== false && (modifierPressed.current || !isInteractiveElement)) {\n                        event.preventDefault();\n                    }\n                    setKeyPressed(true);\n                }\n            };\n            const upHandler = (event)=>{\n                const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                    setKeyPressed(false);\n                    pressedKeys.current.clear();\n                } else {\n                    pressedKeys.current.delete(event[keyOrCode]);\n                }\n                // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                if (event.key === \"Meta\") {\n                    pressedKeys.current.clear();\n                }\n                modifierPressed.current = false;\n            };\n            const resetHandler = ()=>{\n                pressedKeys.current.clear();\n                setKeyPressed(false);\n            };\n            target?.addEventListener(\"keydown\", downHandler);\n            target?.addEventListener(\"keyup\", upHandler);\n            window.addEventListener(\"blur\", resetHandler);\n            window.addEventListener(\"contextmenu\", resetHandler);\n            return ()=>{\n                target?.removeEventListener(\"keydown\", downHandler);\n                target?.removeEventListener(\"keyup\", upHandler);\n                window.removeEventListener(\"blur\", resetHandler);\n                window.removeEventListener(\"contextmenu\", resetHandler);\n            };\n        }\n    }, [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? \"code\" : \"key\";\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            zoomIn: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomOut: (options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            zoomTo: (zoomLevel, options)=>{\n                const { panZoom } = store.getState();\n                return panZoom ? panZoom.scaleTo(zoomLevel, {\n                    duration: options?.duration\n                }) : Promise.resolve(false);\n            },\n            getZoom: ()=>store.getState().transform[2],\n            setViewport: async (viewport, options)=>{\n                const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport({\n                    x: viewport.x ?? tX,\n                    y: viewport.y ?? tY,\n                    zoom: viewport.zoom ?? tZoom\n                }, options);\n                return Promise.resolve(true);\n            },\n            getViewport: ()=>{\n                const [x, y, zoom] = store.getState().transform;\n                return {\n                    x,\n                    y,\n                    zoom\n                };\n            },\n            setCenter: async (x, y, options)=>{\n                return store.getState().setCenter(x, y, options);\n            },\n            fitBounds: async (bounds, options)=>{\n                const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                await panZoom.setViewport(viewport, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            screenToFlowPosition: (clientPosition, options = {})=>{\n                const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                if (!domNode) {\n                    return clientPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const correctedPosition = {\n                    x: clientPosition.x - domX,\n                    y: clientPosition.y - domY\n                };\n                const _snapGrid = options.snapGrid ?? snapGrid;\n                const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n            },\n            flowToScreenPosition: (flowPosition)=>{\n                const { transform, domNode } = store.getState();\n                if (!domNode) {\n                    return flowPosition;\n                }\n                const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                return {\n                    x: rendererPosition.x + domX,\n                    y: rendererPosition.y + domY\n                };\n            }\n        };\n    }, []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === \"add\") {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === \"remove\" || change.type === \"replace\") {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === \"remove\") {\n            continue;\n        }\n        if (changes[0].type === \"replace\") {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case \"select\":\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case \"position\":\n            {\n                if (typeof change.position !== \"undefined\") {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== \"undefined\") {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case \"dimensions\":\n            {\n                if (typeof change.dimensions !== \"undefined\") {\n                    element.measured = {\n                        ...change.dimensions\n                    };\n                    if (change.setAttributes) {\n                        if (change.setAttributes === true || change.setAttributes === \"width\") {\n                            element.width = change.dimensions.width;\n                        }\n                        if (change.setAttributes === true || change.setAttributes === \"height\") {\n                            element.height = change.dimensions.height;\n                        }\n                    }\n                }\n                if (typeof change.resizing === \"boolean\") {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply.\n * @param nodes - Array of nodes to apply the changes to.\n * @returns Array of updated nodes.\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply.\n * @param edges - Array of edge to apply the changes to.\n * @returns Array of updated edges.\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: \"select\",\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: \"replace\"\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: \"add\",\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: \"remove\"\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: \"remove\"\n    };\n}\n/**\n * Test whether an object is usable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test.\n * @returns Tests whether the provided value can be used as a `Node`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Node` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ...\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is usable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns Tests whether the provided value can be used as an `Edge`. If you're using TypeScript,\n * this function acts as a type guard and will narrow the type of the value to `Edge` if it returns\n * `true`.\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ...\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createQueue(()=>setSerial((n)=>n + BigInt(1))));\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect(()=>{\n        const queueItems = queue.get();\n        if (queueItems.length) {\n            runQueue(queueItems);\n            queue.reset();\n        }\n    }, [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup, fitViewQueued, onNodesChangeMiddlewareMap } = store.getState();\n        /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        let changes = getElementsDiffChanges({\n            items: next,\n            lookup: nodeLookup\n        });\n        for (const middleware of onNodesChangeMiddlewareMap.values()){\n            changes = middleware(changes);\n        }\n        if (hasDefaultNodes) {\n            setNodes(next);\n        }\n        // We only want to fire onNodesChange if there are changes to the nodes\n        if (changes.length > 0) {\n            onNodesChange?.(changes);\n        } else if (fitViewQueued) {\n            // If there are no changes to the nodes, we still need to call setNodes\n            // to trigger a re-render and fitView.\n            window.requestAnimationFrame(()=>{\n                const { fitViewQueued, nodes, setNodes } = store.getState();\n                if (fitViewQueued) {\n                    setNodes(nodes);\n                }\n            });\n        }\n    }, []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((queueItems)=>{\n        const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n        let next = edges;\n        for (const payload of queueItems){\n            next = typeof payload === \"function\" ? payload(next) : payload;\n        }\n        if (hasDefaultEdges) {\n            setEdges(next);\n        } else if (onEdgesChange) {\n            onEdgesChange(getElementsDiffChanges({\n                items: next,\n                lookup: edgeLookup\n            }));\n        }\n    }, []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            nodeQueue,\n            edgeQueue\n        }), []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error(\"useBatchContext must be used within a BatchProvider\");\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const getInternalNode = (id)=>store.getState().nodeLookup.get(id);\n        const setNodes = (payload)=>{\n            batchContext.nodeQueue.push(payload);\n        };\n        const setEdges = (payload)=>{\n            batchContext.edgeQueue.push(payload);\n        };\n        const getNodeRect = (node)=>{\n            const { nodeLookup, nodeOrigin } = store.getState();\n            const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n            const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n            const nodeWithPosition = {\n                ...nodeToUse,\n                position,\n                width: nodeToUse.measured?.width ?? nodeToUse.width,\n                height: nodeToUse.measured?.height ?? nodeToUse.height\n            };\n            return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n        };\n        const updateNode = (id, nodeUpdate, options = {\n            replace: false\n        })=>{\n            setNodes((prevNodes)=>prevNodes.map((node)=>{\n                    if (node.id === id) {\n                        const nextNode = typeof nodeUpdate === \"function\" ? nodeUpdate(node) : nodeUpdate;\n                        return options.replace && isNode(nextNode) ? nextNode : {\n                            ...node,\n                            ...nextNode\n                        };\n                    }\n                    return node;\n                }));\n        };\n        const updateEdge = (id, edgeUpdate, options = {\n            replace: false\n        })=>{\n            setEdges((prevEdges)=>prevEdges.map((edge)=>{\n                    if (edge.id === id) {\n                        const nextEdge = typeof edgeUpdate === \"function\" ? edgeUpdate(edge) : edgeUpdate;\n                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                            ...edge,\n                            ...nextEdge\n                        };\n                    }\n                    return edge;\n                }));\n        };\n        return {\n            getNodes: ()=>store.getState().nodes.map((n)=>({\n                        ...n\n                    })),\n            getNode: (id)=>getInternalNode(id)?.internals.userNode,\n            getInternalNode,\n            getEdges: ()=>{\n                const { edges = [] } = store.getState();\n                return edges.map((e)=>({\n                        ...e\n                    }));\n            },\n            getEdge: (id)=>store.getState().edgeLookup.get(id),\n            setNodes,\n            setEdges,\n            addNodes: (payload)=>{\n                const newNodes = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes,\n                        ...newNodes\n                    ]);\n            },\n            addEdges: (payload)=>{\n                const newEdges = Array.isArray(payload) ? payload : [\n                    payload\n                ];\n                batchContext.edgeQueue.push((edges)=>[\n                        ...edges,\n                        ...newEdges\n                    ]);\n            },\n            toObject: ()=>{\n                const { nodes = [], edges = [], transform } = store.getState();\n                const [x, y, zoom] = transform;\n                return {\n                    nodes: nodes.map((n)=>({\n                            ...n\n                        })),\n                    edges: edges.map((e)=>({\n                            ...e\n                        })),\n                    viewport: {\n                        x,\n                        y,\n                        zoom\n                    }\n                };\n            },\n            deleteElements: async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                    nodesToRemove,\n                    edgesToRemove,\n                    nodes,\n                    edges,\n                    onBeforeDelete\n                });\n                const hasMatchingEdges = matchingEdges.length > 0;\n                const hasMatchingNodes = matchingNodes.length > 0;\n                if (hasMatchingEdges) {\n                    const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                    onEdgesDelete?.(matchingEdges);\n                    triggerEdgeChanges(edgeChanges);\n                }\n                if (hasMatchingNodes) {\n                    const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                    onNodesDelete?.(matchingNodes);\n                    triggerNodeChanges(nodeChanges);\n                }\n                if (hasMatchingNodes || hasMatchingEdges) {\n                    onDelete?.({\n                        nodes: matchingNodes,\n                        edges: matchingEdges\n                    });\n                }\n                return {\n                    deletedNodes: matchingNodes,\n                    deletedEdges: matchingEdges\n                };\n            },\n            /**\n             * Partial is defined as \"the 2 nodes/areas are intersecting partially\".\n             * If a is contained in b or b is contained in a, they are both\n             * considered fully intersecting.\n             */ getIntersectingNodes: (nodeOrRect, partially = true, nodes)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                const hasNodesOption = nodes !== undefined;\n                if (!nodeRect) {\n                    return [];\n                }\n                return (nodes || store.getState().nodes).filter((n)=>{\n                    const internalNode = store.getState().nodeLookup.get(n.id);\n                    if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                        return false;\n                    }\n                    const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                    const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                    const partiallyVisible = partially && overlappingArea > 0;\n                    return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;\n                });\n            },\n            isNodeIntersecting: (nodeOrRect, area, partially = true)=>{\n                const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                if (!nodeRect) {\n                    return false;\n                }\n                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                const partiallyVisible = partially && overlappingArea > 0;\n                return partiallyVisible || overlappingArea >= area.width * area.height || overlappingArea >= nodeRect.width * nodeRect.height;\n            },\n            updateNode,\n            updateNodeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateNode(id, (node)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(node) : dataUpdate;\n                    return options.replace ? {\n                        ...node,\n                        data: nextData\n                    } : {\n                        ...node,\n                        data: {\n                            ...node.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            updateEdge,\n            updateEdgeData: (id, dataUpdate, options = {\n                replace: false\n            })=>{\n                updateEdge(id, (edge)=>{\n                    const nextData = typeof dataUpdate === \"function\" ? dataUpdate(edge) : dataUpdate;\n                    return options.replace ? {\n                        ...edge,\n                        data: nextData\n                    } : {\n                        ...edge,\n                        data: {\n                            ...edge.data,\n                            ...nextData\n                        }\n                    };\n                }, options);\n            },\n            getNodesBounds: (nodes)=>{\n                const { nodeLookup, nodeOrigin } = store.getState();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                    nodeLookup,\n                    nodeOrigin\n                });\n            },\n            getHandleConnections: ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : \"\"}`)?.values() ?? []),\n            getNodeConnections: ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : \"\"}`)?.values() ?? []),\n            fitView: async (options)=>{\n                // We either create a new Promise or reuse the existing one\n                // Even if fitView is called multiple times in a row, we only end up with a single Promise\n                const fitViewResolver = store.getState().fitViewResolver ?? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.withResolvers)();\n                // We schedule a fitView by setting fitViewQueued and triggering a setNodes\n                store.setState({\n                    fitViewQueued: true,\n                    fitViewOptions: options,\n                    fitViewResolver\n                });\n                batchContext.nodeQueue.push((nodes)=>[\n                        ...nodes\n                    ]);\n                return fitViewResolver.promise;\n            }\n        };\n    }, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            ...generalHelper,\n            ...viewportHelper,\n            viewportInitialized\n        };\n    }, [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, {\n        actInsideInputWithModifier: false\n    });\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (deleteKeyPressed) {\n            const { edges, nodes } = store.getState();\n            deleteElements({\n                nodes: nodes.filter(selected),\n                edges: edges.filter(selected)\n            });\n            store.setState({\n                nodesSelectionActive: false\n            });\n        }\n    }, [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            multiSelectionActive: multiSelectionKeyPressed\n        });\n    }, [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (!domNode.current || !(domNode.current.checkVisibility?.() ?? true)) {\n                return false;\n            }\n            const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n            if (size.height === 0 || size.width === 0) {\n                store.getState().onError?.(\"004\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error004\"]());\n            }\n            store.setState({\n                width: size.width || 500,\n                height: size.height || 500\n            });\n        };\n        if (domNode.current) {\n            updateDimensions();\n            window.addEventListener(\"resize\", updateDimensions);\n            const resizeObserver = new ResizeObserver(()=>updateDimensions());\n            resizeObserver.observe(domNode.current);\n            return ()=>{\n                window.removeEventListener(\"resize\", updateDimensions);\n                if (resizeObserver && domNode.current) {\n                    resizeObserver.unobserve(domNode.current);\n                }\n            };\n        }\n    }, []);\n}\nconst containerStyle = {\n    position: \"absolute\",\n    width: \"100%\",\n    height: \"100%\",\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib,\n        connectionInProgress: s.connection.inProgress\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance, selectionOnDrag }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib, connectionInProgress } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((transform)=>{\n        onViewportChange?.({\n            x: transform[0],\n            y: transform[1],\n            zoom: transform[2]\n        });\n        if (!isControlledViewport) {\n            store.setState({\n                transform\n            });\n        }\n    }, [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (zoomPane.current) {\n            panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                domNode: zoomPane.current,\n                minZoom,\n                maxZoom,\n                translateExtent,\n                viewport: defaultViewport,\n                onDraggingChange: (paneDragging)=>store.setState({\n                        paneDragging\n                    }),\n                onPanZoomStart: (event, vp)=>{\n                    const { onViewportChangeStart, onMoveStart } = store.getState();\n                    onMoveStart?.(event, vp);\n                    onViewportChangeStart?.(vp);\n                },\n                onPanZoom: (event, vp)=>{\n                    const { onViewportChange, onMove } = store.getState();\n                    onMove?.(event, vp);\n                    onViewportChange?.(vp);\n                },\n                onPanZoomEnd: (event, vp)=>{\n                    const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                    onMoveEnd?.(event, vp);\n                    onViewportChangeEnd?.(vp);\n                }\n            });\n            const { x, y, zoom } = panZoom.current.getViewport();\n            store.setState({\n                panZoom: panZoom.current,\n                transform: [\n                    x,\n                    y,\n                    zoom\n                ],\n                domNode: zoomPane.current.closest(\".react-flow\")\n            });\n            return ()=>{\n                panZoom.current?.destroy();\n            };\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        panZoom.current?.update({\n            onPaneContextMenu,\n            zoomOnScroll,\n            zoomOnPinch,\n            panOnScroll,\n            panOnScrollSpeed,\n            panOnScrollMode,\n            zoomOnDoubleClick,\n            panOnDrag,\n            zoomActivationKeyPressed,\n            preventScrolling,\n            noPanClassName,\n            userSelectionActive,\n            noWheelClassName,\n            lib,\n            onTransformChange,\n            connectionInProgress,\n            selectionOnDrag,\n            paneClickDistance\n        });\n    }, [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange,\n        connectionInProgress,\n        selectionOnDrag,\n        paneClickDistance\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        connectionInProgress: s.connection.inProgress,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, paneClickDistance, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging, connectionInProgress } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isSelectionEnabled = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        // We also prevent click events when a connection is in progress\n        if (selectionInProgress.current || connectionInProgress) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onClickCapture = (event)=>{\n        if (selectionInProgress.current) {\n            event.stopPropagation();\n            selectionInProgress.current = false;\n        }\n    };\n    // We are using capture here in order to prevent other pointer events\n    // to be able to create a selection above a node or an edge\n    const onPointerDownCapture = (event)=>{\n        const { domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!containerBounds.current) return;\n        const eventTargetIsContainer = event.target === container.current;\n        // if a child element has the 'nokey' class, we don't want to swallow the event and don't start a selection\n        const isNoKeyEvent = !eventTargetIsContainer && !!event.target.closest(\".nokey\");\n        const isSelectionActive = selectionOnDrag && eventTargetIsContainer || selectionKeyPressed;\n        if (isNoKeyEvent || !isSelecting || !isSelectionActive || event.button !== 0 || !event.isPrimary) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        if (!eventTargetIsContainer) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions, resetSelectedElements } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        if (!selectionInProgress.current) {\n            const requiredDistance = selectionKeyPressed ? 0 : paneClickDistance;\n            const distance = Math.hypot(mouseX - startX, mouseY - startY);\n            if (distance <= requiredDistance) {\n                return;\n            }\n            resetSelectedElements();\n            onSelectionStart?.(event);\n        }\n        selectionInProgress.current = true;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && event.target === container.current && store.getState().userSelectionRect) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null\n        });\n        if (selectionInProgress.current) {\n            onSelectionEnd?.(event);\n            store.setState({\n                nodesSelectionActive: selectedNodeIds.current.size > 0\n            });\n        }\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__pane\",\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: isSelectionEnabled ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: isSelectionEnabled ? undefined : onPaneMouseEnter,\n        onPointerMove: isSelectionEnabled ? onPointerMove : onPaneMouseMove,\n        onPointerUp: isSelectionEnabled ? onPointerUp : undefined,\n        onPointerDownCapture: isSelectionEnabled ? onPointerDownCapture : undefined,\n        onClickCapture: isSelectionEnabled ? onClickCapture : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.(\"012\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error012\"](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n            getStoreItems: ()=>store.getState(),\n            onNodeMouseDown: (id)=>{\n                handleNodeClick({\n                    id,\n                    store,\n                    nodeRef\n                });\n            },\n            onDragStart: ()=>{\n                setDragging(true);\n            },\n            onDragStop: ()=>{\n                setDragging(false);\n            }\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (disabled) {\n            xyDrag.current?.destroy();\n        } else if (nodeRef.current) {\n            xyDrag.current?.update({\n                noDragClassName,\n                handleSelector,\n                domNode: nodeRef.current,\n                isSelectable,\n                nodeId,\n                nodeClickDistance\n            });\n            return ()=>{\n                xyDrag.current?.destroy();\n            };\n        }\n    }, [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === \"undefined\");\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((params)=>{\n        const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n        const nodeUpdates = new Map();\n        const isSelected = selectedAndDraggable(nodesDraggable);\n        /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n        const yVelo = snapToGrid ? snapGrid[1] : 5;\n        const xDiff = params.direction.x * xVelo * params.factor;\n        const yDiff = params.direction.y * yVelo * params.factor;\n        for (const [, node] of nodeLookup){\n            if (!isSelected(node)) {\n                continue;\n            }\n            let nextPosition = {\n                x: node.internals.positionAbsolute.x + xDiff,\n                y: node.internals.positionAbsolute.y + yDiff\n            };\n            if (snapToGrid) {\n                nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n            }\n            const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                nodeId: node.id,\n                nextPosition,\n                nodeLookup,\n                nodeExtent,\n                nodeOrigin,\n                onError\n            });\n            node.position = position;\n            node.internals.positionAbsolute = positionAbsolute;\n            nodeUpdates.set(node.id, node);\n        }\n        updateNodePositions(nodeUpdates);\n    }, []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns The id for a node in the flow.\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = \"source\", position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === \"target\";\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.(\"010\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error010\"]());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                handleDomNode: event.currentTarget,\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed,\n                dragThreshold: currentStore.connectionDragThreshold\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__handle\",\n            `react-flow__handle-${position}`,\n            \"nodrag\",\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!disableKeyboardA11y) {\n            nodeRef.current?.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__nodesselection\",\n            \"react-flow__container\",\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        selectionOnDrag: _selectionOnDrag,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            paneClickDistance: paneClickDistance,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = \"FlowRenderer\";\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        if (typeof ResizeObserver === \"undefined\") {\n            return null;\n        }\n        return new ResizeObserver((entries)=>{\n            const updates = new Map();\n            entries.forEach((entry)=>{\n                const id = entry.target.getAttribute(\"data-id\");\n                updates.set(id, {\n                    id,\n                    nodeElement: entry.target,\n                    force: true\n                });\n            });\n            updateNodeInternals(updates);\n        });\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            resizeObserver?.disconnect();\n        };\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n            }\n            resizeObserver?.observe(nodeRef.current);\n            observedNode.current = nodeRef.current;\n        }\n    }, [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            if (observedNode.current) {\n                resizeObserver?.unobserve(observedNode.current);\n                observedNode.current = null;\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (nodeRef.current) {\n            /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n            const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n            const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n            if (typeChanged || sourcePosChanged || targetPosChanged) {\n                prevType.current = nodeType;\n                prevSourcePosition.current = node.sourcePosition;\n                prevTargetPosition.current = node.targetPosition;\n                store.getState().updateNodeInternals(new Map([\n                    [\n                        node.id,\n                        {\n                            id: node.id,\n                            nodeElement: nodeRef.current,\n                            force: true\n                        }\n                    ]\n                ]));\n            }\n        }\n    }, [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore((s)=>{\n        const node = s.nodeLookup.get(id);\n        const isParent = s.parentLookup.has(id);\n        return {\n            node,\n            internals: node.internals,\n            isParent\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || \"default\";\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.(\"003\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error003\"](nodeType));\n        nodeType = \"default\";\n        NodeComponent = nodeTypes?.[\"default\"] || builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === \"undefined\");\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === \"undefined\");\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === \"undefined\");\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === \"undefined\");\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === \"Escape\";\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            const { ariaLabelConfig } = store.getState();\n            store.setState({\n                ariaLiveMessage: ariaLabelConfig[\"node.a11yDescription.ariaLiveMessage\"]({\n                    direction: event.key.replace(\"Arrow\", \"\").toLowerCase(),\n                    x: ~~internals.positionAbsolute.x,\n                    y: ~~internals.positionAbsolute.y\n                })\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    const onFocus = ()=>{\n        if (disableKeyboardA11y || !nodeRef.current?.matches(\":focus-visible\")) {\n            return;\n        }\n        const { transform, width, height, autoPanOnNodeFocus, setCenter } = store.getState();\n        if (!autoPanOnNodeFocus) {\n            return;\n        }\n        const withinViewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(new Map([\n            [\n                id,\n                node\n            ]\n        ]), {\n            x: 0,\n            y: 0,\n            width,\n            height\n        }, transform, true).length > 0;\n        if (!withinViewport) {\n            setCenter(node.position.x + nodeDimensions.width / 2, node.position.y + nodeDimensions.height / 2, {\n                zoom: transform[2]\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__node\",\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? \"all\" : \"none\",\n            visibility: hasDimensions ? \"visible\" : \"hidden\",\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        onFocus: isFocusable ? onFocus : undefined,\n        role: node.ariaRole ?? (isFocusable ? \"group\" : undefined),\n        \"aria-roledescription\": \"node\",\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        ...node.domAttributes,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nvar NodeWrapper$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeWrapper);\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, its designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when youre dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs  and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once  instead of once per node.\n             * - Any operations that youd normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized  so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper$1, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = \"NodeRenderer\";\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        if (!onlyRenderVisible) {\n            return s.edges.map((edge)=>edge.id);\n        }\n        const visibleEdgeIds = [];\n        if (s.width && s.height) {\n            for (const edge of s.edges){\n                const sourceNode = s.nodeLookup.get(edge.source);\n                const targetNode = s.nodeLookup.get(edge.target);\n                if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                    sourceNode,\n                    targetNode,\n                    width: s.width,\n                    height: s.height,\n                    transform: s.transform\n                })) {\n                    visibleEdgeIds.push(edge.id);\n                }\n            }\n        }\n        return visibleEdgeIds;\n    }, [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrow\",\n        style: style,\n        strokeLinecap: \"round\",\n        fill: \"none\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = \"none\", strokeWidth = 1 })=>{\n    const style = {\n        strokeWidth,\n        ...color && {\n            stroke: color,\n            fill: color\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        className: \"arrowclosed\",\n        style: style,\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n        if (!symbolExists) {\n            store.getState().onError?.(\"009\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error009\"](type));\n            return null;\n        }\n        return MarkerSymbols[type];\n    }, [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = \"strokeWidth\", strokeWidth, orient = \"auto-start-reverse\" })=>{\n    const Symbol1 = useMarkerSymbol(type);\n    if (!Symbol1) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol1, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore((s)=>s.edges);\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n            id: rfId,\n            defaultColor,\n            defaultMarkerStart: defaultEdgeOptions?.markerStart,\n            defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n        });\n        return markers;\n    }, [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        \"aria-hidden\": \"true\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = \"MarkerDefinitions\";\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle, labelShowBg = true, labelBgStyle, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        \"react-flow__edge-textwrapper\",\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (edgeTextRef.current) {\n            const textBbox = edgeTextRef.current.getBBox();\n            setEdgeTextBbox({\n                x: textBbox.x,\n                y: textBbox.y,\n                width: textBbox.width,\n                height: textBbox.height\n            });\n        }\n    }, [\n        label\n    ]);\n    if (!label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? \"visible\" : \"hidden\",\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = \"EdgeText\";\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n * @public\n *\n * @example\n * ```jsx\n * import { EdgeText } from '@xyflow/react';\n *\n * export function CustomEdgeLabel({ label }) {\n *   return (\n *     <EdgeText\n *       x={100}\n *       y={100}\n *       label={label}\n *       labelStyle={{ fill: 'white' }}\n *       labelShowBg\n *       labelBgStyle={{ fill: 'red' }}\n *       labelBgPadding={[2, 4]}\n *       labelBgBorderRadius={2}\n *     />\n *   );\n * }\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    \"react-flow__edge-path\",\n                    props.className\n                ])\n            }),\n            interactionWidth ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }) : null,\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n * @returns\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = \"SimpleBezierEdge\";\nSimpleBezierEdgeInternal.displayName = \"SimpleBezierEdgeInternal\";\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset,\n            stepPosition: pathOptions?.stepPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a smooth step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { SmoothStepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <SmoothStepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = \"SmoothStepEdge\";\nSmoothStepEdgeInternal.displayName = \"SmoothStepEdgeInternal\";\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n                    borderRadius: 0,\n                    offset: props.pathOptions?.offset\n                }), [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a step edge.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StepEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <StepEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const StepEdge = createStepEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = \"StepEdge\";\nStepEdgeInternal.displayName = \"StepEdgeInternal\";\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a straight line.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { StraightEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY }) {\n *   return (\n *     <StraightEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *     />\n *   );\n * }\n * ```\n */ const StraightEdge = createStraightEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = \"StraightEdge\";\nStraightEdgeInternal.displayName = \"StraightEdgeInternal\";\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\n/**\n * Component that can be used inside a custom edge to render a bezier curve.\n *\n * @public\n * @example\n *\n * ```tsx\n * import { BezierEdge } from '@xyflow/react';\n *\n * function CustomEdge({ sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition }) {\n *   return (\n *     <BezierEdge\n *       sourceX={sourceX}\n *       sourceY={sourceY}\n *       targetX={targetX}\n *       targetY={targetY}\n *       sourcePosition={sourcePosition}\n *       targetPosition={targetPosition}\n *     />\n *   );\n * }\n * ```\n */ const BezierEdge = createBezierEdge({\n    isInternal: false\n});\n/**\n * @internal\n */ const BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = \"BezierEdge\";\nBezierEdgeInternal.displayName = \"BezierEdgeInternal\";\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = \"react-flow__edgeupdater\";\n/**\n * @internal\n */ function EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === \"target\";\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        const _onConnectStart = (_event, params)=>{\n            setReconnecting(true);\n            onReconnectStart?.(event, edge, oppositeHandle.type);\n            onConnectStart?.(_event, params);\n        };\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart: _onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle,\n            dragThreshold: store.getState().connectionDragThreshold,\n            handleDomNode: event.currentTarget\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: \"target\"\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: \"source\"\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === \"source\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === \"target\") && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore((s)=>s.edgeLookup.get(id));\n    const defaultEdgeOptions = useStore((s)=>s.defaultEdgeOptions);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || \"default\";\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.(\"011\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error011\"](edgeType));\n        edgeType = \"default\";\n        EdgeComponent = edgeTypes?.[\"default\"] || builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === \"undefined\");\n    const isReconnectable = typeof onReconnect !== \"undefined\" && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === \"undefined\");\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === \"undefined\");\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((store)=>{\n        const sourceNode = store.nodeLookup.get(edge.source);\n        const targetNode = store.nodeLookup.get(edge.target);\n        if (!sourceNode || !targetNode) {\n            return {\n                zIndex: edge.zIndex,\n                ...nullPosition\n            };\n        }\n        const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n            id,\n            sourceNode,\n            targetNode,\n            sourceHandle: edge.sourceHandle || null,\n            targetHandle: edge.targetHandle || null,\n            connectionMode: store.connectionMode,\n            onError\n        });\n        const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n            selected: edge.selected,\n            zIndex: edge.zIndex,\n            sourceNode,\n            targetNode,\n            elevateOnSelect: store.elevateEdgesOnSelect,\n            zIndexMode: store.zIndexMode\n        });\n        return {\n            zIndex,\n            ...edgePosition || nullPosition\n        };\n    }, [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined, [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined, [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === \"Escape\";\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__edge\",\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: edge.ariaRole ?? (isFocusable ? \"group\" : \"img\"),\n            \"aria-roledescription\": \"edge\",\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            ...edge.domAttributes,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: \"pathOptions\" in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nvar EdgeWrapper$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeWrapper);\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper$1, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = \"EdgeRenderer\";\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n            setTimeout(()=>onInit(rfInstance), 1);\n            isInitialized.current = true;\n        }\n    }, [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (viewport) {\n            syncViewport?.(viewport);\n            store.setState({\n                transform: [\n                    viewport.x,\n                    viewport.y,\n                    viewport.zoom\n                ]\n            });\n        }\n    }, [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @param connectionSelector - An optional selector function used to extract a slice of the\n * `ConnectionState` data. Using a selector can prevent component re-renders where data you don't\n * otherwise care about might change. If a selector is not provided, the entire `ConnectionState`\n * object is returned unchanged.\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__connection\",\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition, pointer } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle,\n            pointer: pointer\n        });\n    }\n    let path = \"\";\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = \"ConnectionLine\";\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            const usedKeys = new Set([\n                ...Object.keys(typesRef.current),\n                ...Object.keys(nodeOrEdgeTypes)\n            ]);\n            for (const key of usedKeys){\n                if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                    store.getState().onError?.(\"002\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error002\"]());\n                    break;\n                }\n            }\n            typesRef.current = nodeOrEdgeTypes;\n        }\n    }, [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            if (!checked.current) {\n                const pane = document.querySelector(\".react-flow__pane\");\n                if (pane && !(window.getComputedStyle(pane).zIndex === \"1\")) {\n                    store.getState().onError?.(\"013\", _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error013\"](\"react\"));\n                }\n                checked.current = true;\n            }\n        }\n    }, []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = \"GraphView\";\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom = 0.5, maxZoom = 2, nodeOrigin, nodeExtent, zIndexMode = \"basic\" } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        zIndexMode\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, fitViewOptions?.padding ?? 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: \"1\",\n        width: width ?? 0,\n        height: height ?? 0,\n        transform,\n        nodes: storeNodes,\n        nodesInitialized,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom,\n        maxZoom,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: \"nopan\",\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        connectionDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: true,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        fitViewQueued: fitView ?? false,\n        fitViewOptions,\n        fitViewResolver: null,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: \"\",\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanOnNodeFocus: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: \"react\",\n        debug: false,\n        ariaLabelConfig: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.defaultAriaLabelConfig,\n        zIndexMode,\n        onNodesChangeMiddlewareMap: new Map(),\n        onEdgesChangeMiddlewareMap: new Map()\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>{\n        async function resolveFitView() {\n            const { nodeLookup, panZoom, fitViewOptions, fitViewResolver, width, height, minZoom, maxZoom } = get();\n            if (!panZoom) {\n                return;\n            }\n            await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitViewport)({\n                nodes: nodeLookup,\n                width,\n                height,\n                panZoom,\n                minZoom,\n                maxZoom\n            }, fitViewOptions);\n            fitViewResolver?.resolve(true);\n            /**\n         * wait for the fitViewport to resolve before deleting the resolver,\n         * we want to reuse the old resolver if the user calls fitView again in the mean time\n         */ set({\n                fitViewResolver: null\n            });\n        }\n        return {\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView,\n                fitViewOptions,\n                minZoom,\n                maxZoom,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges,\n                zIndexMode\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, fitViewQueued, zIndexMode } = get();\n                /*\n             * setNodes() is called exclusively in response to user actions:\n             * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n             * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n             *\n             * When this happens, we take the note objects passed by the user and extend them with fields\n             * relevant for internal React Flow operations.\n             */ const nodesInitialized = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true,\n                    zIndexMode\n                });\n                if (fitViewQueued && nodesInitialized) {\n                    resolveFitView();\n                    set({\n                        nodes,\n                        nodesInitialized,\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    set({\n                        nodes,\n                        nodesInitialized\n                    });\n                }\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n         * Every node gets registerd at a ResizeObserver. Whenever a node\n         * changes its dimensions, this function is called to measure the\n         * new dimensions and update the nodes.\n         */ updateNodeInternals: (updates)=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, debug, fitViewQueued, zIndexMode } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, zIndexMode);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    zIndexMode\n                });\n                if (fitViewQueued) {\n                    resolveFitView();\n                    set({\n                        fitViewQueued: false,\n                        fitViewOptions: undefined\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                let changes = [];\n                const { nodeLookup, triggerNodeChanges, connection, updateConnection, onNodesChangeMiddlewareMap } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: \"position\",\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (node && connection.inProgress && connection.fromNode.id === node.id) {\n                        const updatedFrom = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHandlePosition)(node, connection.fromHandle, _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left, true);\n                        updateConnection({\n                            ...connection,\n                            from: updatedFrom\n                        });\n                    }\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                for (const middleware of onNodesChangeMiddlewareMap.values()){\n                    changes = middleware(changes);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger node changes\", changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log(\"React Flow: trigger edge changes\", changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                     * we need to unselect the internal node that was selected previously before we\n                     * send the change to the user to prevent it to be selected while dragging the new node\n                     */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges, elementsSelectable } = get();\n                if (!elementsSelectable) {\n                    return;\n                }\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent, zIndexMode } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false,\n                    zIndexMode\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            setCenter: async (x, y, options)=>{\n                const { width, height, maxZoom, panZoom } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const nextZoom = typeof options?.zoom !== \"undefined\" ? options.zoom : maxZoom;\n                await panZoom.setViewport({\n                    x: width / 2 - x * nextZoom,\n                    y: height / 2 - y * nextZoom,\n                    zoom: nextZoom\n                }, {\n                    duration: options?.duration,\n                    ease: options?.ease,\n                    interpolate: options?.interpolate\n                });\n                return Promise.resolve(true);\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        };\n    }, Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, initialMinZoom: minZoom, initialMaxZoom: maxZoom, initialFitViewOptions: fitViewOptions, fitView, nodeOrigin, nodeExtent, zIndexMode, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>createStore({\n            nodes,\n            edges,\n            defaultNodes,\n            defaultEdges,\n            width,\n            height,\n            fitView,\n            minZoom,\n            maxZoom,\n            fitViewOptions,\n            nodeOrigin,\n            nodeExtent,\n            zIndexMode\n        }));\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, fitViewOptions, minZoom, maxZoom, nodeOrigin, nodeExtent, zIndexMode }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        initialFitViewOptions: fitViewOptions,\n        initialMinZoom: minZoom,\n        initialMaxZoom: maxZoom,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        zIndexMode: zIndexMode,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    position: \"relative\",\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = \"Backspace\", selectionKeyCode = \"Shift\", selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = \"Space\", multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? \"Meta\" : \"Control\", snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, autoPanOnNodeFocus, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = \"#b1b1b7\", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 1, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = \"nodrag\", noWheelClassName = \"nowheel\", noPanClassName = \"nopan\", fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, connectionDragThreshold, viewport, onViewportChange, width, height, colorMode = \"light\", debug, onScroll, ariaLabelConfig, zIndexMode = \"basic\", ...rest }, ref) {\n    const rfId = id || \"1\";\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        e.currentTarget.scrollTo({\n            top: 0,\n            left: 0,\n            behavior: \"instant\"\n        });\n        onScroll?.(e);\n    }, [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow\",\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        role: \"application\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            fitViewOptions: fitViewOptions,\n            minZoom: minZoom,\n            maxZoom: maxZoom,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            zIndexMode: zIndexMode,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    autoPanOnNodeFocus: autoPanOnNodeFocus,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    connectionDragThreshold: connectionDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    debug: debug,\n                    ariaLabelConfig: ariaLabelConfig,\n                    zIndexMode: zIndexMode\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector(\".react-flow__edgelabel-renderer\");\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the\n * [edge label renderer example](/examples/edges/edge-label-renderer).\n * @public\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n * export function CustomEdge({ id, data, ...props }) {\n *   const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeLabelRenderer>\n *         <div\n *           style={{\n *             position: 'absolute',\n *             transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *             background: '#ffcc00',\n *             padding: 10,\n *         }}\n *           className=\"nodrag nopan\"\n *         >\n *          {data.label}\n *         </div>\n *       </EdgeLabelRenderer>\n *     </>\n *   );\n * };\n * ```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector(\".react-flow__viewport-portal\");\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n * handle position, you need to let React Flow know about it using this hook. This\n * will update the internal dimensions of the node and properly reposition handles\n * on the canvas if necessary.\n *\n * @public\n * @returns Use this function to tell React Flow to update the internal state of one or more nodes\n * that you have changed programmatically.\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        const { domNode, updateNodeInternals } = store.getState();\n        const updateIds = Array.isArray(id) ? id : [\n            id\n        ];\n        const updates = new Map();\n        updateIds.forEach((updateId)=>{\n            const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n            if (nodeElement) {\n                updates.set(updateId, {\n                    id: updateId,\n                    nodeElement,\n                    force: true\n                });\n            }\n        });\n        requestAnimationFrame(()=>updateNodeInternals(updates, {\n                triggerFitView: false\n            }));\n    }, []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of all nodes currently in the flow.\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of all edges currently in the flow.\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n * {@link Viewport} in a component. Components that use this hook\n * will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport.\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `nodes`: The current array of nodes. You might pass this directly to the `nodes` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n * - `setNodes`: A function that you can use to update the nodes. You can pass it a new array of\n * nodes or a callback that receives the current array of nodes and returns a new array of nodes.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n * - `onNodesChange`: A handy callback that can take an array of `NodeChanges` and update the nodes\n * state accordingly. You'll typically pass this directly to the `onNodesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setNodes((nds)=>applyNodeChanges(changes, nds)), []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @returns\n * - `edges`: The current array of edges. You might pass this directly to the `edges` prop of your\n * `<ReactFlow />` component, or you may want to manipulate it first to perform some layouting,\n * for example.\n *\n * - `setEdges`: A function that you can use to update the edges. You can pass it a new array of\n * edges or a callback that receives the current array of edges and returns a new array of edges.\n * This is the same as the second element of the tuple returned by React's `useState` hook.\n *\n * - `onEdgesChange`: A handy callback that can take an array of `EdgeChanges` and update the edges\n * state accordingly. You'll typically pass this directly to the `onEdgesChange` prop of your\n * `<ReactFlow />` component.\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((changes)=>setEdges((eds)=>applyEdgeChanges(changes, eds)), []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n * as panning and zooming. You can provide a callback for each phase of a viewport\n * change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeStart: onStart\n        });\n    }, [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChange: onChange\n        });\n    }, [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        store.setState({\n            onViewportChangeEnd: onEnd\n        });\n    }, [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const nextOnSelectionChangeHandlers = [\n            ...store.getState().onSelectionChangeHandlers,\n            onChange\n        ];\n        store.setState({\n            onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n        });\n        return ()=>{\n            const nextHandlers = store.getState().onSelectionChangeHandlers.filter((fn)=>fn !== onChange);\n            store.setState({\n                onSelectionChangeHandlers: nextHandlers\n            });\n        };\n    }, [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (!options.includeHiddenNodes) {\n            return s.nodesInitialized;\n        }\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { internals }] of s.nodeLookup){\n            if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                return false;\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @returns Whether or not the nodes have been initialized by the `<ReactFlow />` component and\n * given a width and height.\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @returns An array with handle connections.\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn(\"[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections\");\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages[\"error014\"]();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @returns An array with connections.\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore((state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : \"\"}`), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // @todo discuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n        if (prevConnections.current && prevConnections.current !== connections) {\n            const _connections = connections ?? new Map();\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n            (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n        }\n        prevConnections.current = connections ?? new Map();\n    }, [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>Array.from(connections?.values() ?? []), [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>{\n        const data = [];\n        const isArrayOfIds = Array.isArray(nodeIds);\n        const _nodeIds = isArrayOfIds ? nodeIds : [\n            nodeIds\n        ];\n        for (const nodeId of _nodeIds){\n            const node = s.nodeLookup.get(nodeId);\n            if (node) {\n                data.push({\n                    id: node.id,\n                    type: node.type,\n                    data: node.data\n                });\n            }\n        }\n        return isArrayOfIds ? data : data[0] ?? null;\n    }, [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - The ID of a node you want to observe.\n * @returns The `InternalNode` object for the node with the given ID.\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((s)=>s.nodeLookup.get(id), [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\n/**\n * Registers a middleware function to transform node changes.\n *\n * @public\n * @param fn - Middleware function. Should be memoized with useCallback to avoid re-registration.\n */ function experimental_useOnNodesChangeMiddleware(fn) {\n    const store = useStoreApi();\n    const [symbol] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>Symbol());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onNodesChangeMiddlewareMap } = store.getState();\n        onNodesChangeMiddlewareMap.set(symbol, fn);\n    }, [\n        fn\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onNodesChangeMiddlewareMap } = store.getState();\n        return ()=>{\n            onNodesChangeMiddlewareMap.delete(symbol);\n        };\n    }, []);\n}\n/**\n * Registers a middleware function to transform edge changes.\n *\n * @public\n * @param fn - Middleware function. Should be memoized with useCallback to avoid re-registration.\n */ function experimental_useOnEdgesChangeMiddleware(fn) {\n    const store = useStoreApi();\n    const [symbol] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>Symbol());\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onEdgesChangeMiddlewareMap } = store.getState();\n        onEdgesChangeMiddlewareMap.set(symbol, fn);\n    }, [\n        fn\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const { onEdgesChangeMiddlewareMap } = store.getState();\n        return ()=>{\n            onEdgesChangeMiddlewareMap.delete(symbol);\n        };\n    }, []);\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background-pattern\",\n            \"dots\",\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : \"\"}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__background\",\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            \"--xy-background-color-props\": bgColor,\n            \"--xy-background-pattern-color-props\": color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = \"Background\";\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components its important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls-button\",\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom,\n        ariaLabelConfig: s.ariaLabelConfig\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = \"bottom-left\", orientation = \"vertical\", \"aria-label\": ariaLabel }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached, ariaLabelConfig } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === \"horizontal\" ? \"horizontal\" : \"vertical\";\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__controls\",\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel ?? ariaLabelConfig[\"controls.ariaLabel\"],\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomIn.ariaLabel\"],\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        \"aria-label\": ariaLabelConfig[\"controls.zoomOut.ariaLabel\"],\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.fitView.ariaLabel\"],\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                \"aria-label\": ariaLabelConfig[\"controls.interactive.ariaLabel\"],\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = \"Controls\";\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap-node\",\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? \"crispEdges\" : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, its designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore((s)=>{\n        const { internals } = s.nodeLookup.get(id);\n        const node = internals.userNode;\n        const { x, y } = internals.positionAbsolute;\n        const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n        return {\n            node,\n            x,\n            y,\n            width,\n            height\n        };\n    }, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst filterHidden = (node)=>!node.hidden;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n            filter: filterHidden\n        }), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height,\n        ariaLabelConfig: s.ariaLabelConfig\n    };\n};\nconst ARIA_LABEL_KEY = \"react-flow__minimap-desc\";\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = \"\", nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = \"bottom-right\", onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel, inversePan, zoomStep = 1, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight, ariaLabelConfig } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (svg.current && panZoom) {\n            minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                domNode: svg.current,\n                panZoom,\n                getTransform: ()=>store.getState().transform,\n                getViewScale: ()=>viewScaleRef.current\n            });\n            return ()=>{\n                minimapInstance.current?.destroy();\n            };\n        }\n    }, [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        minimapInstance.current?.update({\n            translateExtent,\n            width: flowWidth,\n            height: flowHeight,\n            inversePan,\n            pannable,\n            zoomStep,\n            zoomable\n        });\n    }, [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event, nodeId)=>{\n        const node = store.getState().nodeLookup.get(nodeId).internals.userNode;\n        onNodeClick(event, node);\n    }, []) : undefined;\n    const _ariaLabel = ariaLabel ?? ariaLabelConfig[\"minimap.ariaLabel\"];\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            \"--xy-minimap-background-color-props\": typeof bgColor === \"string\" ? bgColor : undefined,\n            \"--xy-minimap-mask-background-color-props\": typeof maskColor === \"string\" ? maskColor : undefined,\n            \"--xy-minimap-mask-stroke-color-props\": typeof maskStrokeColor === \"string\" ? maskStrokeColor : undefined,\n            \"--xy-minimap-mask-stroke-width-props\": typeof maskStrokeWidth === \"number\" ? maskStrokeWidth * viewScale : undefined,\n            \"--xy-minimap-node-background-color-props\": typeof nodeColor === \"string\" ? nodeColor : undefined,\n            \"--xy-minimap-node-stroke-color-props\": typeof nodeStrokeColor === \"string\" ? nodeStrokeColor : undefined,\n            \"--xy-minimap-node-stroke-width-props\": typeof nodeStrokeWidth === \"number\" ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__minimap\",\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                _ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: _ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = \"MiniMap\";\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nconst scaleSelector = (calculateScale)=>(store)=>calculateScale ? `${Math.max(1 / store.transform[2], 1)}` : undefined;\nconst defaultPositions = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line]: \"right\",\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle]: \"bottom-right\"\n};\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = undefined, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, resizeDirection, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === \"string\" ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isHandleControl = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle;\n    const scale = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(scaleSelector(isHandleControl && autoScale), [\n        isHandleControl,\n        autoScale\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const controlPosition = position ?? defaultPositions[variant];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!resizeControlRef.current || !id) {\n            return;\n        }\n        if (!resizer.current) {\n            resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                domNode: resizeControlRef.current,\n                nodeId: id,\n                getStoreItems: ()=>{\n                    const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                    return {\n                        nodeLookup,\n                        transform,\n                        snapGrid,\n                        snapToGrid,\n                        nodeOrigin,\n                        paneDomNode: domNode\n                    };\n                },\n                onChange: (change, childChanges)=>{\n                    const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                    const changes = [];\n                    const nextPosition = {\n                        x: change.x,\n                        y: change.y\n                    };\n                    const node = nodeLookup.get(id);\n                    if (node && node.expandParent && node.parentId) {\n                        const origin = node.origin ?? nodeOrigin;\n                        const width = change.width ?? node.measured.width ?? 0;\n                        const height = change.height ?? node.measured.height ?? 0;\n                        const child = {\n                            id: node.id,\n                            parentId: node.parentId,\n                            rect: {\n                                width,\n                                height,\n                                ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                    x: change.x ?? node.position.x,\n                                    y: change.y ?? node.position.y\n                                }, {\n                                    width,\n                                    height\n                                }, node.parentId, nodeLookup, origin)\n                            }\n                        };\n                        const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                            child\n                        ], nodeLookup, parentLookup, nodeOrigin);\n                        changes.push(...parentExpandChanges);\n                        /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                        nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                    }\n                    if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                        const positionChange = {\n                            id,\n                            type: \"position\",\n                            position: {\n                                ...nextPosition\n                            }\n                        };\n                        changes.push(positionChange);\n                    }\n                    if (change.width !== undefined && change.height !== undefined) {\n                        const setAttributes = !resizeDirection ? true : resizeDirection === \"horizontal\" ? \"width\" : \"height\";\n                        const dimensionChange = {\n                            id,\n                            type: \"dimensions\",\n                            resizing: true,\n                            setAttributes,\n                            dimensions: {\n                                width: change.width,\n                                height: change.height\n                            }\n                        };\n                        changes.push(dimensionChange);\n                    }\n                    for (const childChange of childChanges){\n                        const positionChange = {\n                            ...childChange,\n                            type: \"position\"\n                        };\n                        changes.push(positionChange);\n                    }\n                    triggerNodeChanges(changes);\n                },\n                onEnd: ({ width, height })=>{\n                    const dimensionChange = {\n                        id: id,\n                        type: \"dimensions\",\n                        resizing: false,\n                        dimensions: {\n                            width,\n                            height\n                        }\n                    };\n                    store.getState().triggerNodeChanges([\n                        dimensionChange\n                    ]);\n                }\n            });\n        }\n        resizer.current.update({\n            controlPosition,\n            boundaries: {\n                minWidth,\n                minHeight,\n                maxWidth,\n                maxHeight\n            },\n            keepAspectRatio,\n            resizeDirection,\n            onResizeStart,\n            onResize,\n            onResizeEnd,\n            shouldResize\n        });\n        return ()=>{\n            resizer.current?.destroy();\n        };\n    }, [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split(\"-\");\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            \"react-flow__resize-control\",\n            \"nodrag\",\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: {\n            ...style,\n            scale,\n            ...color && {\n                [isHandleControl ? \"backgroundColor\" : \"borderColor\"]: color\n            }\n        },\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, autoScale = true, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    autoScale: autoScale,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector(\".react-flow__renderer\");\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = \"center\", ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((state)=>{\n        const nodeIds = Array.isArray(nodeId) ? nodeId : [\n            nodeId || contextNodeId || \"\"\n        ];\n        const internalNodes = nodeIds.reduce((res, id)=>{\n            const node = state.nodeLookup.get(id);\n            if (node) {\n                res.set(node.id, node);\n            }\n            return res;\n        }, new Map());\n        return internalNodes;\n    }, [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === \"boolean\" ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: \"absolute\",\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__node-toolbar\",\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, \"\").trim(),\n            children: children\n        })\n    });\n}\nconst zoomSelector = (state)=>state.transform[2];\n/**\n * This component can render a toolbar or tooltip to one side of a custom edge. This\n * toolbar doesn't scale with the viewport so that the content stays the same size.\n *\n * @public\n * @example\n * ```jsx\n * import { EdgeToolbar, BaseEdge, getBezierPath, type EdgeProps } from \"@xyflow/react\";\n *\n * export function CustomEdge({ id, data, ...props }: EdgeProps) {\n *   const [edgePath, centerX, centerY] = getBezierPath(props);\n *\n *   return (\n *     <>\n *       <BaseEdge id={id} path={edgePath} />\n *       <EdgeToolbar edgeId={id} x={centerX} y={centerY} isVisible>\n *         <button onClick={() => console.log('edge', id, 'click')}}>Click me</button>\n *       </EdgeToolbar>\n *     </>\n *   );\n * }\n * ```\n */ function EdgeToolbar({ edgeId, x, y, children, className, style, isVisible, alignX = \"center\", alignY = \"center\", ...rest }) {\n    const edgeSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((state)=>state.edgeLookup.get(edgeId), [\n        edgeId\n    ]);\n    const edge = useStore(edgeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = typeof isVisible === \"boolean\" ? isVisible : edge?.selected;\n    const zoom = useStore(zoomSelector);\n    if (!isActive) {\n        return null;\n    }\n    const zIndex = (edge?.zIndex ?? 0) + 1;\n    const transform = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeToolbarTransform)(x, y, zoom, alignX, alignY);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeLabelRenderer, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: {\n                position: \"absolute\",\n                transform,\n                zIndex,\n                pointerEvents: \"all\",\n                transformOrigin: \"0 0\",\n                ...style\n            },\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                \"react-flow__edge-toolbar\",\n                className\n            ]),\n            \"data-id\": edge?.id ?? \"\",\n            ...rest,\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NGhDQUN3RDtBQUNnRjtBQUM5RztBQUM4dUM7QUFDdDdCO0FBQy9QO0FBQ3pDO0FBQ0Q7QUFFekMsTUFBTStGLDZCQUFlNUYsb0RBQWFBLENBQUM7QUFDbkMsTUFBTTZGLGFBQWFELGFBQWFFLFFBQVE7QUFFeEMsTUFBTUMsc0JBQXNCcEYseURBQWEsQ0FBQyxXQUFXO0FBQ3JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBU3FGLFNBQVNDLFFBQVEsRUFBRUMsVUFBVTtJQUNsQyxNQUFNQyxRQUFRbEcsaURBQVVBLENBQUMyRjtJQUN6QixJQUFJTyxVQUFVLE1BQU07UUFDaEIsTUFBTSxJQUFJQyxNQUFNTDtJQUNwQjtJQUNBLE9BQU9QLDJFQUFzQkEsQ0FBQ1csT0FBT0YsVUFBVUM7QUFDbkQ7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRztJQUNMLE1BQU1GLFFBQVFsRyxpREFBVUEsQ0FBQzJGO0lBQ3pCLElBQUlPLFVBQVUsTUFBTTtRQUNoQixNQUFNLElBQUlDLE1BQU1MO0lBQ3BCO0lBQ0EsT0FBTzdGLDhDQUFPQSxDQUFDLElBQU87WUFDbEJvRyxVQUFVSCxNQUFNRyxRQUFRO1lBQ3hCQyxVQUFVSixNQUFNSSxRQUFRO1lBQ3hCQyxXQUFXTCxNQUFNSyxTQUFTO1FBQzlCLElBQUk7UUFBQ0w7S0FBTTtBQUNmO0FBRUEsTUFBTU0sUUFBUTtJQUFFQyxTQUFTO0FBQU87QUFDaEMsTUFBTUMsZ0JBQWdCO0lBQ2xCQyxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRLENBQUM7SUFDVEMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsTUFBTTtJQUNOQyxVQUFVO0FBQ2Q7QUFDQSxNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyxtQkFBbUIsQ0FBQ0MsSUFBTUEsRUFBRUMsZUFBZTtBQUNqRCxNQUFNQywwQkFBMEIsQ0FBQ0YsSUFBTUEsRUFBRUcsZUFBZTtBQUN4RCxTQUFTQyxnQkFBZ0IsRUFBRUMsSUFBSSxFQUFFO0lBQzdCLE1BQU1KLGtCQUFrQjFCLFNBQVN3QjtJQUNqQyxPQUFRekgsc0RBQUdBLENBQUMsT0FBTztRQUFFZ0ksSUFBSSxDQUFDLEVBQUVSLGtCQUFrQixDQUFDLEVBQUVPLEtBQUssQ0FBQztRQUFFLGFBQWE7UUFBYSxlQUFlO1FBQVFyQixPQUFPRTtRQUFlcUIsVUFBVU47SUFBZ0I7QUFDOUo7QUFDQSxTQUFTTyxpQkFBaUIsRUFBRUgsSUFBSSxFQUFFSSxtQkFBbUIsRUFBRTtJQUNuRCxNQUFNTixrQkFBa0I1QixTQUFTMkI7SUFDakMsT0FBUTlILHVEQUFJQSxDQUFDQyx1REFBUUEsRUFBRTtRQUFFa0ksVUFBVTtZQUFDakksc0RBQUdBLENBQUMsT0FBTztnQkFBRWdJLElBQUksQ0FBQyxFQUFFVixtQkFBbUIsQ0FBQyxFQUFFUyxLQUFLLENBQUM7Z0JBQUVyQixPQUFPQTtnQkFBT3VCLFVBQVVFLHNCQUM1Rk4sZUFBZSxDQUFDLCtCQUErQixHQUMvQ0EsZUFBZSxDQUFDLHdDQUF3QztZQUFDO1lBQUk3SCxzREFBR0EsQ0FBQyxPQUFPO2dCQUFFZ0ksSUFBSSxDQUFDLEVBQUVULG1CQUFtQixDQUFDLEVBQUVRLEtBQUssQ0FBQztnQkFBRXJCLE9BQU9BO2dCQUFPdUIsVUFBVUosZUFBZSxDQUFDLCtCQUErQjtZQUFDO1lBQUksQ0FBQ00sdUJBQXVCbkksc0RBQUdBLENBQUM4SCxpQkFBaUI7Z0JBQUVDLE1BQU1BO1lBQUs7U0FBRztJQUFDO0FBQy9RO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUNELE1BQU1LLHNCQUFRaEksaURBQVVBLENBQUMsQ0FBQyxFQUFFeUcsV0FBVyxVQUFVLEVBQUVvQixRQUFRLEVBQUVJLFNBQVMsRUFBRTNCLEtBQUssRUFBRSxHQUFHNEIsTUFBTSxFQUFFQztJQUN0RixNQUFNQyxrQkFBa0IsQ0FBQyxFQUFFM0IsU0FBUyxDQUFDLENBQUM0QixLQUFLLENBQUM7SUFDNUMsT0FBUXpJLHNEQUFHQSxDQUFDLE9BQU87UUFBRXFJLFdBQVcxSCxvREFBRUEsQ0FBQztZQUFDO1lBQXFCMEg7ZUFBY0c7U0FBZ0I7UUFBRzlCLE9BQU9BO1FBQU82QixLQUFLQTtRQUFLLEdBQUdELElBQUk7UUFBRUwsVUFBVUE7SUFBUztBQUNsSjtBQUNBRyxNQUFNTSxXQUFXLEdBQUc7QUFFcEIsU0FBU0MsWUFBWSxFQUFFQyxVQUFVLEVBQUUvQixXQUFXLGNBQWMsRUFBRTtJQUMxRCxJQUFJK0IsWUFBWUMsaUJBQWlCO1FBQzdCLE9BQU87SUFDWDtJQUNBLE9BQVE3SSxzREFBR0EsQ0FBQ29JLE9BQU87UUFBRXZCLFVBQVVBO1FBQVV3QixXQUFXO1FBQTJCLGdCQUFnQjtRQUEwR0osVUFBVWpJLHNEQUFHQSxDQUFDLEtBQUs7WUFBRThJLE1BQU07WUFBeUJDLFFBQVE7WUFBVUMsS0FBSztZQUF1QixjQUFjO1lBQTBCZixVQUFVO1FBQWE7SUFBRztBQUNqWDtBQUVBLE1BQU1nQixhQUFhLENBQUN2QjtJQUNoQixNQUFNd0IsZ0JBQWdCLEVBQUU7SUFDeEIsTUFBTUMsZ0JBQWdCLEVBQUU7SUFDeEIsS0FBSyxNQUFNLEdBQUdDLEtBQUssSUFBSTFCLEVBQUUyQixVQUFVLENBQUU7UUFDakMsSUFBSUQsS0FBS0UsUUFBUSxFQUFFO1lBQ2ZKLGNBQWNLLElBQUksQ0FBQ0gsS0FBS0ksU0FBUyxDQUFDQyxRQUFRO1FBQzlDO0lBQ0o7SUFDQSxLQUFLLE1BQU0sR0FBR0MsS0FBSyxJQUFJaEMsRUFBRWlDLFVBQVUsQ0FBRTtRQUNqQyxJQUFJRCxLQUFLSixRQUFRLEVBQUU7WUFDZkgsY0FBY0ksSUFBSSxDQUFDRztRQUN2QjtJQUNKO0lBQ0EsT0FBTztRQUFFUjtRQUFlQztJQUFjO0FBQzFDO0FBQ0EsTUFBTVMsV0FBVyxDQUFDQyxNQUFRQSxJQUFJN0IsRUFBRTtBQUNoQyxTQUFTOEIsU0FBU0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2xCLE9BQVFyRSx3REFBT0EsQ0FBQ29FLEVBQUViLGFBQWEsQ0FBQ2UsR0FBRyxDQUFDTCxXQUFXSSxFQUFFZCxhQUFhLENBQUNlLEdBQUcsQ0FBQ0wsY0FDL0RqRSx3REFBT0EsQ0FBQ29FLEVBQUVaLGFBQWEsQ0FBQ2MsR0FBRyxDQUFDTCxXQUFXSSxFQUFFYixhQUFhLENBQUNjLEdBQUcsQ0FBQ0w7QUFDbkU7QUFDQSxTQUFTTSx1QkFBdUIsRUFBRUMsaUJBQWlCLEVBQUc7SUFDbEQsTUFBTS9ELFFBQVFFO0lBQ2QsTUFBTSxFQUFFNEMsYUFBYSxFQUFFQyxhQUFhLEVBQUUsR0FBR2xELFNBQVNnRCxZQUFZYTtJQUM5RHpKLGdEQUFTQSxDQUFDO1FBQ04sTUFBTStKLFNBQVM7WUFBRUMsT0FBT25CO1lBQWVvQixPQUFPbkI7UUFBYztRQUM1RGdCLG9CQUFvQkM7UUFDcEJoRSxNQUFNRyxRQUFRLEdBQUdnRSx5QkFBeUIsQ0FBQ0MsT0FBTyxDQUFDLENBQUNDLEtBQU9BLEdBQUdMO0lBQ2xFLEdBQUc7UUFBQ2xCO1FBQWVDO1FBQWVnQjtLQUFrQjtJQUNwRCxPQUFPO0FBQ1g7QUFDQSxNQUFNTyxpQkFBaUIsQ0FBQ2hELElBQU0sQ0FBQyxDQUFDQSxFQUFFNkMseUJBQXlCO0FBQzNELFNBQVNJLGtCQUFrQixFQUFFUixpQkFBaUIsRUFBRztJQUM3QyxNQUFNUyxrQ0FBa0MzRSxTQUFTeUU7SUFDakQsSUFBSVAscUJBQXFCUyxpQ0FBaUM7UUFDdEQsT0FBTzVLLHNEQUFHQSxDQUFDa0ssd0JBQXdCO1lBQUVDLG1CQUFtQkE7UUFBa0I7SUFDOUU7SUFDQSxPQUFPO0FBQ1g7QUFFQSxNQUFNVSxvQkFBb0I7SUFBQztJQUFHO0NBQUU7QUFDaEMsTUFBTUMsa0JBQWtCO0lBQUVDLEdBQUc7SUFBR0MsR0FBRztJQUFHQyxNQUFNO0FBQUU7QUFFOUM7Ozs7Q0FJQyxHQUNELDhFQUE4RTtBQUM5RSxNQUFNQyx5QkFBeUI7SUFDM0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELHFGQUFxRjtBQUNyRixNQUFNQyxnQkFBZ0I7T0FBSUQ7SUFBd0I7Q0FBTztBQUN6RCxNQUFNRSxhQUFhLENBQUMxRCxJQUFPO1FBQ3ZCMkQsVUFBVTNELEVBQUUyRCxRQUFRO1FBQ3BCQyxVQUFVNUQsRUFBRTRELFFBQVE7UUFDcEJDLFlBQVk3RCxFQUFFNkQsVUFBVTtRQUN4QkMsWUFBWTlELEVBQUU4RCxVQUFVO1FBQ3hCQyxvQkFBb0IvRCxFQUFFK0Qsa0JBQWtCO1FBQ3hDQyxlQUFlaEUsRUFBRWdFLGFBQWE7UUFDOUJDLE9BQU9qRSxFQUFFaUUsS0FBSztRQUNkQyx5QkFBeUJsRSxFQUFFa0UsdUJBQXVCO0lBQ3REO0FBQ0EsTUFBTUMsaUJBQWlCO0lBQ25COzs7O0tBSUMsR0FDREMsaUJBQWlCaEwsMERBQWNBO0lBQy9CaUwsWUFBWWxCO0lBQ1ptQixTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsb0JBQW9CO0lBQ3BCQyxnQkFBZ0I7SUFDaEJwRSxNQUFNO0FBQ1Y7QUFDQSxTQUFTcUUsYUFBYUMsS0FBSztJQUN2QixNQUFNLEVBQUVoQixRQUFRLEVBQUVDLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLGtCQUFrQixFQUFFQyxhQUFhLEVBQUVDLEtBQUssRUFBRUMsdUJBQXVCLEVBQUcsR0FBRzNGLFNBQVNtRixZQUFZekYsb0RBQU9BO0lBQ3ZKLE1BQU1TLFFBQVFFO0lBQ2RqRyxnREFBU0EsQ0FBQztRQUNOdUwsd0JBQXdCUyxNQUFNQyxZQUFZLEVBQUVELE1BQU1FLFlBQVk7UUFDOUQsT0FBTztZQUNILG9FQUFvRTtZQUNwRUMsZUFBZUMsT0FBTyxHQUFHWjtZQUN6QkY7UUFDSjtJQUNKLEdBQUcsRUFBRTtJQUNMLE1BQU1hLGlCQUFpQmxNLDZDQUFNQSxDQUFDdUw7SUFDOUJ4TCxnREFBU0EsQ0FBQztRQUNOLEtBQUssTUFBTXFNLGFBQWF2QixjQUFlO1lBQ25DLE1BQU13QixhQUFhTixLQUFLLENBQUNLLFVBQVU7WUFDbkMsTUFBTUUscUJBQXFCSixlQUFlQyxPQUFPLENBQUNDLFVBQVU7WUFDNUQsSUFBSUMsZUFBZUMsb0JBQ2Y7WUFDSixJQUFJLE9BQU9QLEtBQUssQ0FBQ0ssVUFBVSxLQUFLLGFBQzVCO1lBQ0oseURBQXlEO1lBQ3pELElBQUlBLGNBQWMsU0FDZHJCLFNBQVNzQjtpQkFDUixJQUFJRCxjQUFjLFNBQ25CcEIsU0FBU3FCO2lCQUNSLElBQUlELGNBQWMsV0FDbkJuQixXQUFXb0I7aUJBQ1YsSUFBSUQsY0FBYyxXQUNuQmxCLFdBQVdtQjtpQkFDVixJQUFJRCxjQUFjLG1CQUNuQmpCLG1CQUFtQmtCO2lCQUNsQixJQUFJRCxjQUFjLGNBQ25CaEIsY0FBY2lCO2lCQUNiLElBQUlELGNBQWMsbUJBQ25CdEcsTUFBTUksUUFBUSxDQUFDO2dCQUFFcUIsaUJBQWlCaEgsb0VBQW9CQSxDQUFDOEw7WUFBWTtpQkFFbEUsSUFBSUQsY0FBYyxXQUNuQnRHLE1BQU1JLFFBQVEsQ0FBQztnQkFBRXFHLGVBQWVGO1lBQVc7aUJBQzFDLElBQUlELGNBQWMsa0JBQ25CdEcsTUFBTUksUUFBUSxDQUFDO2dCQUFFc0csZ0JBQWdCSDtZQUFXO2lCQUc1Q3ZHLE1BQU1JLFFBQVEsQ0FBQztnQkFBRSxDQUFDa0csVUFBVSxFQUFFQztZQUFXO1FBQ2pEO1FBQ0FILGVBQWVDLE9BQU8sR0FBR0o7SUFDN0IsR0FDQSwrREFBK0Q7SUFDL0RsQixjQUFjbEIsR0FBRyxDQUFDLENBQUN5QyxZQUFjTCxLQUFLLENBQUNLLFVBQVU7SUFDakQsT0FBTztBQUNYO0FBRUEsU0FBU0s7SUFDTCxJQUFJLElBQW1ELEVBQUU7UUFDckQsT0FBTztJQUNYO0lBQ0EsT0FBT0MsT0FBT0MsVUFBVSxDQUFDO0FBQzdCO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTQyxrQkFBa0JDLFNBQVM7SUFDaEMsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHOU0sK0NBQVFBLENBQUM0TSxjQUFjLFdBQVcsT0FBT0E7SUFDckY5TSxnREFBU0EsQ0FBQztRQUNOLElBQUk4TSxjQUFjLFVBQVU7WUFDeEJFLGtCQUFrQkY7WUFDbEI7UUFDSjtRQUNBLE1BQU1HLGFBQWFQO1FBQ25CLE1BQU1RLHVCQUF1QixJQUFNRixrQkFBa0JDLFlBQVlFLFVBQVUsU0FBUztRQUNwRkQ7UUFDQUQsWUFBWUcsaUJBQWlCLFVBQVVGO1FBQ3ZDLE9BQU87WUFDSEQsWUFBWUksb0JBQW9CLFVBQVVIO1FBQzlDO0lBQ0osR0FBRztRQUFDSjtLQUFVO0lBQ2QsT0FBT0MsbUJBQW1CLE9BQU9BLGlCQUFpQkwsaUJBQWlCUyxVQUFVLFNBQVM7QUFDMUY7QUFFQSxNQUFNRyxhQUFhLE9BQU9DLGFBQWEsY0FBY0EsV0FBVztBQUNoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDRCxTQUFTQyxZQUNUOzs7Ozs7Ozs7OztDQVdDLEdBQ0RDLFVBQVUsSUFBSSxFQUFFQyxVQUFVO0lBQUVoRixRQUFRNEU7SUFBWUssNEJBQTRCO0FBQUssQ0FBQztJQUM5RSxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBRzNOLCtDQUFRQSxDQUFDO0lBQzdDLHdFQUF3RTtJQUN4RSxNQUFNNE4sa0JBQWtCN04sNkNBQU1BLENBQUM7SUFDL0Isd0VBQXdFO0lBQ3hFLE1BQU04TixjQUFjOU4sNkNBQU1BLENBQUMsSUFBSStOLElBQUksRUFBRTtJQUNyQzs7Ozs7OztLQU9DLEdBQ0QsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdwTyw4Q0FBT0EsQ0FBQztRQUNwQyxJQUFJMk4sWUFBWSxNQUFNO1lBQ2xCLE1BQU1VLGFBQWFDLE1BQU1DLE9BQU8sQ0FBQ1osV0FBV0EsVUFBVTtnQkFBQ0E7YUFBUTtZQUMvRCxNQUFNYSxPQUFPSCxXQUNSSSxNQUFNLENBQUMsQ0FBQ0MsS0FBTyxPQUFPQSxPQUFPLFNBQzlCOzs7O2lCQUlDLElBQ0E1RSxHQUFHLENBQUMsQ0FBQzRFLEtBQU9BLEdBQUdDLE9BQU8sQ0FBQyxLQUFLLE1BQU1BLE9BQU8sQ0FBQyxRQUFRLE9BQU9yRyxLQUFLLENBQUM7WUFDcEUsTUFBTXNHLFdBQVdKLEtBQUtLLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLElBQUlELE9BQU8sRUFBRTtZQUNuRSxPQUFPO2dCQUFDUDtnQkFBTUk7YUFBUztRQUMzQjtRQUNBLE9BQU87WUFBQyxFQUFFO1lBQUUsRUFBRTtTQUFDO0lBQ25CLEdBQUc7UUFBQ2pCO0tBQVE7SUFDWnpOLGdEQUFTQSxDQUFDO1FBQ04sTUFBTTBJLFNBQVNnRixTQUFTaEYsVUFBVTRFO1FBQ2xDLE1BQU1LLDZCQUE2QkQsU0FBU0MsOEJBQThCO1FBQzFFLElBQUlGLFlBQVksTUFBTTtZQUNsQixNQUFNc0IsY0FBYyxDQUFDQztnQkFDakJsQixnQkFBZ0IxQixPQUFPLEdBQUc0QyxNQUFNQyxPQUFPLElBQUlELE1BQU1FLE9BQU8sSUFBSUYsTUFBTUcsUUFBUSxJQUFJSCxNQUFNSSxNQUFNO2dCQUMxRixNQUFNQyxnQkFBZ0IsQ0FBQyxDQUFDdkIsZ0JBQWdCMUIsT0FBTyxJQUFLMEIsZ0JBQWdCMUIsT0FBTyxJQUFJLENBQUN1QiwwQkFBMEIsS0FDdEdqTiw4REFBY0EsQ0FBQ3NPO2dCQUNuQixJQUFJSyxlQUFlO29CQUNmLE9BQU87Z0JBQ1g7Z0JBQ0EsTUFBTUMsWUFBWUMsYUFBYVAsTUFBTVEsSUFBSSxFQUFFdEI7Z0JBQzNDSCxZQUFZM0IsT0FBTyxDQUFDcUQsR0FBRyxDQUFDVCxLQUFLLENBQUNNLFVBQVU7Z0JBQ3hDLElBQUlJLGNBQWN6QixVQUFVRixZQUFZM0IsT0FBTyxFQUFFLFFBQVE7b0JBQ3JELE1BQU0xRCxTQUFVc0csTUFBTVcsWUFBWSxNQUFNLENBQUMsRUFBRSxJQUFJWCxNQUFNdEcsTUFBTTtvQkFDM0QsTUFBTWtILHVCQUF1QmxILFFBQVFtSCxhQUFhLFlBQVluSCxRQUFRbUgsYUFBYTtvQkFDbkYsSUFBSW5DLFFBQVFvQyxjQUFjLEtBQUssU0FBVWhDLENBQUFBLGdCQUFnQjFCLE9BQU8sSUFBSSxDQUFDd0Qsb0JBQW1CLEdBQUk7d0JBQ3hGWixNQUFNYyxjQUFjO29CQUN4QjtvQkFDQWpDLGNBQWM7Z0JBQ2xCO1lBQ0o7WUFDQSxNQUFNa0MsWUFBWSxDQUFDZjtnQkFDZixNQUFNTSxZQUFZQyxhQUFhUCxNQUFNUSxJQUFJLEVBQUV0QjtnQkFDM0MsSUFBSXdCLGNBQWN6QixVQUFVRixZQUFZM0IsT0FBTyxFQUFFLE9BQU87b0JBQ3BEeUIsY0FBYztvQkFDZEUsWUFBWTNCLE9BQU8sQ0FBQzRELEtBQUs7Z0JBQzdCLE9BQ0s7b0JBQ0RqQyxZQUFZM0IsT0FBTyxDQUFDNkQsTUFBTSxDQUFDakIsS0FBSyxDQUFDTSxVQUFVO2dCQUMvQztnQkFDQSwwTUFBME07Z0JBQzFNLElBQUlOLE1BQU1rQixHQUFHLEtBQUssUUFBUTtvQkFDdEJuQyxZQUFZM0IsT0FBTyxDQUFDNEQsS0FBSztnQkFDN0I7Z0JBQ0FsQyxnQkFBZ0IxQixPQUFPLEdBQUc7WUFDOUI7WUFDQSxNQUFNK0QsZUFBZTtnQkFDakJwQyxZQUFZM0IsT0FBTyxDQUFDNEQsS0FBSztnQkFDekJuQyxjQUFjO1lBQ2xCO1lBQ0FuRixRQUFRMEUsaUJBQWlCLFdBQVcyQjtZQUNwQ3JHLFFBQVEwRSxpQkFBaUIsU0FBUzJDO1lBQ2xDcEQsT0FBT1MsZ0JBQWdCLENBQUMsUUFBUStDO1lBQ2hDeEQsT0FBT1MsZ0JBQWdCLENBQUMsZUFBZStDO1lBQ3ZDLE9BQU87Z0JBQ0h6SCxRQUFRMkUsb0JBQW9CLFdBQVcwQjtnQkFDdkNyRyxRQUFRMkUsb0JBQW9CLFNBQVMwQztnQkFDckNwRCxPQUFPVSxtQkFBbUIsQ0FBQyxRQUFROEM7Z0JBQ25DeEQsT0FBT1UsbUJBQW1CLENBQUMsZUFBZThDO1lBQzlDO1FBQ0o7SUFDSixHQUFHO1FBQUMxQztRQUFTSTtLQUFjO0lBQzNCLE9BQU9EO0FBQ1g7QUFDQSxRQUFRO0FBQ1IsU0FBUzhCLGNBQWN6QixRQUFRLEVBQUVGLFdBQVcsRUFBRXFDLElBQUk7SUFDOUMsT0FBUW5DLFFBQ0o7Ozs7U0FJQyxJQUNBTSxNQUFNLENBQUMsQ0FBQ0QsT0FBUzhCLFFBQVE5QixLQUFLK0IsTUFBTSxLQUFLdEMsWUFBWXVDLElBQUksQ0FDMUQ7OztTQUdDLElBQ0FDLElBQUksQ0FBQyxDQUFDakMsT0FBU0EsS0FBS2tDLEtBQUssQ0FBQyxDQUFDQyxJQUFNMUMsWUFBWTJDLEdBQUcsQ0FBQ0Q7QUFDMUQ7QUFDQSxTQUFTbEIsYUFBYW9CLFNBQVMsRUFBRXpDLFdBQVc7SUFDeEMsT0FBT0EsWUFBWTBDLFFBQVEsQ0FBQ0QsYUFBYSxTQUFTO0FBQ3REO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNRSxvQkFBb0I7SUFDdEIsTUFBTTlLLFFBQVFFO0lBQ2QsT0FBT25HLDhDQUFPQSxDQUFDO1FBQ1gsT0FBTztZQUNIZ1IsUUFBUSxDQUFDcEQ7Z0JBQ0wsTUFBTSxFQUFFcUQsT0FBTyxFQUFFLEdBQUdoTCxNQUFNRyxRQUFRO2dCQUNsQyxPQUFPNkssVUFBVUEsUUFBUUMsT0FBTyxDQUFDLEtBQUs7b0JBQUVDLFVBQVV2RCxTQUFTdUQ7Z0JBQVMsS0FBS0MsUUFBUUMsT0FBTyxDQUFDO1lBQzdGO1lBQ0FDLFNBQVMsQ0FBQzFEO2dCQUNOLE1BQU0sRUFBRXFELE9BQU8sRUFBRSxHQUFHaEwsTUFBTUcsUUFBUTtnQkFDbEMsT0FBTzZLLFVBQVVBLFFBQVFDLE9BQU8sQ0FBQyxJQUFJLEtBQUs7b0JBQUVDLFVBQVV2RCxTQUFTdUQ7Z0JBQVMsS0FBS0MsUUFBUUMsT0FBTyxDQUFDO1lBQ2pHO1lBQ0FFLFFBQVEsQ0FBQ0MsV0FBVzVEO2dCQUNoQixNQUFNLEVBQUVxRCxPQUFPLEVBQUUsR0FBR2hMLE1BQU1HLFFBQVE7Z0JBQ2xDLE9BQU82SyxVQUFVQSxRQUFRUSxPQUFPLENBQUNELFdBQVc7b0JBQUVMLFVBQVV2RCxTQUFTdUQ7Z0JBQVMsS0FBS0MsUUFBUUMsT0FBTyxDQUFDO1lBQ25HO1lBQ0FLLFNBQVMsSUFBTXpMLE1BQU1HLFFBQVEsR0FBR3VMLFNBQVMsQ0FBQyxFQUFFO1lBQzVDQyxhQUFhLE9BQU9DLFVBQVVqRTtnQkFDMUIsTUFBTSxFQUFFK0QsV0FBVyxDQUFDRyxJQUFJQyxJQUFJQyxNQUFNLEVBQUVmLE9BQU8sRUFBRyxHQUFHaEwsTUFBTUcsUUFBUTtnQkFDL0QsSUFBSSxDQUFDNkssU0FBUztvQkFDVixPQUFPRyxRQUFRQyxPQUFPLENBQUM7Z0JBQzNCO2dCQUNBLE1BQU1KLFFBQVFXLFdBQVcsQ0FBQztvQkFDdEJoSCxHQUFHaUgsU0FBU2pILENBQUMsSUFBSWtIO29CQUNqQmpILEdBQUdnSCxTQUFTaEgsQ0FBQyxJQUFJa0g7b0JBQ2pCakgsTUFBTStHLFNBQVMvRyxJQUFJLElBQUlrSDtnQkFDM0IsR0FBR3BFO2dCQUNILE9BQU93RCxRQUFRQyxPQUFPLENBQUM7WUFDM0I7WUFDQVksYUFBYTtnQkFDVCxNQUFNLENBQUNySCxHQUFHQyxHQUFHQyxLQUFLLEdBQUc3RSxNQUFNRyxRQUFRLEdBQUd1TCxTQUFTO2dCQUMvQyxPQUFPO29CQUFFL0c7b0JBQUdDO29CQUFHQztnQkFBSztZQUN4QjtZQUNBb0gsV0FBVyxPQUFPdEgsR0FBR0MsR0FBRytDO2dCQUNwQixPQUFPM0gsTUFBTUcsUUFBUSxHQUFHOEwsU0FBUyxDQUFDdEgsR0FBR0MsR0FBRytDO1lBQzVDO1lBQ0F1RSxXQUFXLE9BQU9DLFFBQVF4RTtnQkFDdEIsTUFBTSxFQUFFakgsS0FBSyxFQUFFQyxNQUFNLEVBQUVpRixPQUFPLEVBQUVDLE9BQU8sRUFBRW1GLE9BQU8sRUFBRSxHQUFHaEwsTUFBTUcsUUFBUTtnQkFDbkUsTUFBTXlMLFdBQVdoUixvRUFBb0JBLENBQUN1UixRQUFRekwsT0FBT0MsUUFBUWlGLFNBQVNDLFNBQVM4QixTQUFTN0csV0FBVztnQkFDbkcsSUFBSSxDQUFDa0ssU0FBUztvQkFDVixPQUFPRyxRQUFRQyxPQUFPLENBQUM7Z0JBQzNCO2dCQUNBLE1BQU1KLFFBQVFXLFdBQVcsQ0FBQ0MsVUFBVTtvQkFDaENWLFVBQVV2RCxTQUFTdUQ7b0JBQ25Ca0IsTUFBTXpFLFNBQVN5RTtvQkFDZkMsYUFBYTFFLFNBQVMwRTtnQkFDMUI7Z0JBQ0EsT0FBT2xCLFFBQVFDLE9BQU8sQ0FBQztZQUMzQjtZQUNBa0Isc0JBQXNCLENBQUNDLGdCQUFnQjVFLFVBQVUsQ0FBQyxDQUFDO2dCQUMvQyxNQUFNLEVBQUUrRCxTQUFTLEVBQUVjLFFBQVEsRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUUsR0FBRzFNLE1BQU1HLFFBQVE7Z0JBQ25FLElBQUksQ0FBQ3VNLFNBQVM7b0JBQ1YsT0FBT0g7Z0JBQ1g7Z0JBQ0EsTUFBTSxFQUFFNUgsR0FBR2dJLElBQUksRUFBRS9ILEdBQUdnSSxJQUFJLEVBQUUsR0FBR0YsUUFBUUcscUJBQXFCO2dCQUMxRCxNQUFNQyxvQkFBb0I7b0JBQ3RCbkksR0FBRzRILGVBQWU1SCxDQUFDLEdBQUdnSTtvQkFDdEIvSCxHQUFHMkgsZUFBZTNILENBQUMsR0FBR2dJO2dCQUMxQjtnQkFDQSxNQUFNRyxZQUFZcEYsUUFBUTZFLFFBQVEsSUFBSUE7Z0JBQ3RDLE1BQU1RLGNBQWNyRixRQUFROEUsVUFBVSxJQUFJQTtnQkFDMUMsT0FBTzVSLG9FQUFvQkEsQ0FBQ2lTLG1CQUFtQnBCLFdBQVdzQixhQUFhRDtZQUMzRTtZQUNBRSxzQkFBc0IsQ0FBQ0M7Z0JBQ25CLE1BQU0sRUFBRXhCLFNBQVMsRUFBRWdCLE9BQU8sRUFBRSxHQUFHMU0sTUFBTUcsUUFBUTtnQkFDN0MsSUFBSSxDQUFDdU0sU0FBUztvQkFDVixPQUFPUTtnQkFDWDtnQkFDQSxNQUFNLEVBQUV2SSxHQUFHZ0ksSUFBSSxFQUFFL0gsR0FBR2dJLElBQUksRUFBRSxHQUFHRixRQUFRRyxxQkFBcUI7Z0JBQzFELE1BQU1NLG1CQUFtQnJTLG9FQUFvQkEsQ0FBQ29TLGNBQWN4QjtnQkFDNUQsT0FBTztvQkFDSC9HLEdBQUd3SSxpQkFBaUJ4SSxDQUFDLEdBQUdnSTtvQkFDeEIvSCxHQUFHdUksaUJBQWlCdkksQ0FBQyxHQUFHZ0k7Z0JBQzVCO1lBQ0o7UUFDSjtJQUNKLEdBQUcsRUFBRTtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNRLGFBQWFDLE9BQU8sRUFBRUMsUUFBUTtJQUNuQyxNQUFNQyxrQkFBa0IsRUFBRTtJQUMxQjs7O0tBR0MsR0FDRCxNQUFNQyxhQUFhLElBQUlDO0lBQ3ZCLE1BQU1DLGlCQUFpQixFQUFFO0lBQ3pCLEtBQUssTUFBTUMsVUFBVU4sUUFBUztRQUMxQixJQUFJTSxPQUFPQyxJQUFJLEtBQUssT0FBTztZQUN2QkYsZUFBZXZLLElBQUksQ0FBQ3dLO1lBQ3BCO1FBQ0osT0FDSyxJQUFJQSxPQUFPQyxJQUFJLEtBQUssWUFBWUQsT0FBT0MsSUFBSSxLQUFLLFdBQVc7WUFDNUQ7OzthQUdDLEdBQ0RKLFdBQVdLLEdBQUcsQ0FBQ0YsT0FBTy9MLEVBQUUsRUFBRTtnQkFBQytMO2FBQU87UUFDdEMsT0FDSztZQUNELE1BQU1HLGlCQUFpQk4sV0FBV08sR0FBRyxDQUFDSixPQUFPL0wsRUFBRTtZQUMvQyxJQUFJa00sZ0JBQWdCO2dCQUNoQjs7O2lCQUdDLEdBQ0RBLGVBQWUzSyxJQUFJLENBQUN3SztZQUN4QixPQUNLO2dCQUNESCxXQUFXSyxHQUFHLENBQUNGLE9BQU8vTCxFQUFFLEVBQUU7b0JBQUMrTDtpQkFBTztZQUN0QztRQUNKO0lBQ0o7SUFDQSxLQUFLLE1BQU1LLFdBQVdWLFNBQVU7UUFDNUIsTUFBTUQsVUFBVUcsV0FBV08sR0FBRyxDQUFDQyxRQUFRcE0sRUFBRTtRQUN6Qzs7O1NBR0MsR0FDRCxJQUFJLENBQUN5TCxTQUFTO1lBQ1ZFLGdCQUFnQnBLLElBQUksQ0FBQzZLO1lBQ3JCO1FBQ0o7UUFDQSw2RUFBNkU7UUFDN0UsSUFBSVgsT0FBTyxDQUFDLEVBQUUsQ0FBQ08sSUFBSSxLQUFLLFVBQVU7WUFDOUI7UUFDSjtRQUNBLElBQUlQLE9BQU8sQ0FBQyxFQUFFLENBQUNPLElBQUksS0FBSyxXQUFXO1lBQy9CTCxnQkFBZ0JwSyxJQUFJLENBQUM7Z0JBQUUsR0FBR2tLLE9BQU8sQ0FBQyxFQUFFLENBQUN2RSxJQUFJO1lBQUM7WUFDMUM7UUFDSjtRQUNBOzs7O1NBSUMsR0FDRCxNQUFNbUYsaUJBQWlCO1lBQUUsR0FBR0QsT0FBTztRQUFDO1FBQ3BDLEtBQUssTUFBTUwsVUFBVU4sUUFBUztZQUMxQmEsWUFBWVAsUUFBUU07UUFDeEI7UUFDQVYsZ0JBQWdCcEssSUFBSSxDQUFDOEs7SUFDekI7SUFDQTs7O0tBR0MsR0FDRCxJQUFJUCxlQUFlcEQsTUFBTSxFQUFFO1FBQ3ZCb0QsZUFBZXRKLE9BQU8sQ0FBQyxDQUFDdUo7WUFDcEIsSUFBSUEsT0FBT1EsS0FBSyxLQUFLQyxXQUFXO2dCQUM1QmIsZ0JBQWdCYyxNQUFNLENBQUNWLE9BQU9RLEtBQUssRUFBRSxHQUFHO29CQUFFLEdBQUdSLE9BQU83RSxJQUFJO2dCQUFDO1lBQzdELE9BQ0s7Z0JBQ0R5RSxnQkFBZ0JwSyxJQUFJLENBQUM7b0JBQUUsR0FBR3dLLE9BQU83RSxJQUFJO2dCQUFDO1lBQzFDO1FBQ0o7SUFDSjtJQUNBLE9BQU95RTtBQUNYO0FBQ0EscUVBQXFFO0FBQ3JFLFNBQVNXLFlBQVlQLE1BQU0sRUFBRUssT0FBTztJQUNoQyxPQUFRTCxPQUFPQyxJQUFJO1FBQ2YsS0FBSztZQUFVO2dCQUNYSSxRQUFROUssUUFBUSxHQUFHeUssT0FBT3pLLFFBQVE7Z0JBQ2xDO1lBQ0o7UUFDQSxLQUFLO1lBQVk7Z0JBQ2IsSUFBSSxPQUFPeUssT0FBT2xOLFFBQVEsS0FBSyxhQUFhO29CQUN4Q3VOLFFBQVF2TixRQUFRLEdBQUdrTixPQUFPbE4sUUFBUTtnQkFDdEM7Z0JBQ0EsSUFBSSxPQUFPa04sT0FBT1csUUFBUSxLQUFLLGFBQWE7b0JBQ3hDTixRQUFRTSxRQUFRLEdBQUdYLE9BQU9XLFFBQVE7Z0JBQ3RDO2dCQUNBO1lBQ0o7UUFDQSxLQUFLO1lBQWM7Z0JBQ2YsSUFBSSxPQUFPWCxPQUFPWSxVQUFVLEtBQUssYUFBYTtvQkFDMUNQLFFBQVFRLFFBQVEsR0FBRzt3QkFDZixHQUFHYixPQUFPWSxVQUFVO29CQUN4QjtvQkFDQSxJQUFJWixPQUFPYyxhQUFhLEVBQUU7d0JBQ3RCLElBQUlkLE9BQU9jLGFBQWEsS0FBSyxRQUFRZCxPQUFPYyxhQUFhLEtBQUssU0FBUzs0QkFDbkVULFFBQVF0TixLQUFLLEdBQUdpTixPQUFPWSxVQUFVLENBQUM3TixLQUFLO3dCQUMzQzt3QkFDQSxJQUFJaU4sT0FBT2MsYUFBYSxLQUFLLFFBQVFkLE9BQU9jLGFBQWEsS0FBSyxVQUFVOzRCQUNwRVQsUUFBUXJOLE1BQU0sR0FBR2dOLE9BQU9ZLFVBQVUsQ0FBQzVOLE1BQU07d0JBQzdDO29CQUNKO2dCQUNKO2dCQUNBLElBQUksT0FBT2dOLE9BQU9lLFFBQVEsS0FBSyxXQUFXO29CQUN0Q1YsUUFBUVUsUUFBUSxHQUFHZixPQUFPZSxRQUFRO2dCQUN0QztnQkFDQTtZQUNKO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkMsR0FDRCxTQUFTQyxpQkFBaUJ0QixPQUFPLEVBQUVwSixLQUFLO0lBQ3BDLE9BQU9tSixhQUFhQyxTQUFTcEo7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEJDLEdBQ0QsU0FBUzJLLGlCQUFpQnZCLE9BQU8sRUFBRW5KLEtBQUs7SUFDcEMsT0FBT2tKLGFBQWFDLFNBQVNuSjtBQUNqQztBQUNBLFNBQVMySyxzQkFBc0JqTixFQUFFLEVBQUVzQixRQUFRO0lBQ3ZDLE9BQU87UUFDSHRCO1FBQ0FnTSxNQUFNO1FBQ04xSztJQUNKO0FBQ0o7QUFDQSxTQUFTNEwsb0JBQW9CQyxLQUFLLEVBQUVDLGNBQWMsSUFBSS9HLEtBQUssRUFBRWdILGFBQWEsS0FBSztJQUMzRSxNQUFNNUIsVUFBVSxFQUFFO0lBQ2xCLEtBQUssTUFBTSxDQUFDekwsSUFBSWtILEtBQUssSUFBSWlHLE1BQU87UUFDNUIsTUFBTUcsaUJBQWlCRixZQUFZckUsR0FBRyxDQUFDL0k7UUFDdkMsMEVBQTBFO1FBQzFFLElBQUksQ0FBRWtILENBQUFBLEtBQUs1RixRQUFRLEtBQUtrTCxhQUFhLENBQUNjLGNBQWEsS0FBTXBHLEtBQUs1RixRQUFRLEtBQUtnTSxnQkFBZ0I7WUFDdkYsSUFBSUQsWUFBWTtnQkFDWjs7OztpQkFJQyxHQUNEbkcsS0FBSzVGLFFBQVEsR0FBR2dNO1lBQ3BCO1lBQ0E3QixRQUFRbEssSUFBSSxDQUFDMEwsc0JBQXNCL0YsS0FBS2xILEVBQUUsRUFBRXNOO1FBQ2hEO0lBQ0o7SUFDQSxPQUFPN0I7QUFDWDtBQUNBLFNBQVM4Qix1QkFBdUIsRUFBRUosUUFBUSxFQUFFLEVBQUVLLE1BQU0sRUFBRztJQUNuRCxNQUFNL0IsVUFBVSxFQUFFO0lBQ2xCLE1BQU1nQyxjQUFjLElBQUk1QixJQUFJc0IsTUFBTWxMLEdBQUcsQ0FBQyxDQUFDaUYsT0FBUztZQUFDQSxLQUFLbEgsRUFBRTtZQUFFa0g7U0FBSztJQUMvRCxLQUFLLE1BQU0sQ0FBQ3FGLE9BQU9yRixLQUFLLElBQUlpRyxNQUFNTyxPQUFPLEdBQUk7UUFDekMsTUFBTUMsYUFBYUgsT0FBT3JCLEdBQUcsQ0FBQ2pGLEtBQUtsSCxFQUFFO1FBQ3JDLE1BQU00TixZQUFZRCxZQUFZbk0sV0FBV0MsWUFBWWtNO1FBQ3JELElBQUlDLGNBQWNwQixhQUFhb0IsY0FBYzFHLE1BQU07WUFDL0N1RSxRQUFRbEssSUFBSSxDQUFDO2dCQUFFdkIsSUFBSWtILEtBQUtsSCxFQUFFO2dCQUFFa0gsTUFBTUE7Z0JBQU04RSxNQUFNO1lBQVU7UUFDNUQ7UUFDQSxJQUFJNEIsY0FBY3BCLFdBQVc7WUFDekJmLFFBQVFsSyxJQUFJLENBQUM7Z0JBQUUyRixNQUFNQTtnQkFBTThFLE1BQU07Z0JBQU9PO1lBQU07UUFDbEQ7SUFDSjtJQUNBLEtBQUssTUFBTSxDQUFDdk0sR0FBRyxJQUFJd04sT0FBUTtRQUN2QixNQUFNSyxXQUFXSixZQUFZdEIsR0FBRyxDQUFDbk07UUFDakMsSUFBSTZOLGFBQWFyQixXQUFXO1lBQ3hCZixRQUFRbEssSUFBSSxDQUFDO2dCQUFFdkI7Z0JBQUlnTSxNQUFNO1lBQVM7UUFDdEM7SUFDSjtJQUNBLE9BQU9QO0FBQ1g7QUFDQSxTQUFTcUMsc0JBQXNCNUcsSUFBSTtJQUMvQixPQUFPO1FBQ0hsSCxJQUFJa0gsS0FBS2xILEVBQUU7UUFDWGdNLE1BQU07SUFDVjtBQUNKO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ0QsTUFBTStCLFNBQVMsQ0FBQzNCLFVBQVlqVCwwREFBVUEsQ0FBQ2lUO0FBQ3ZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNELE1BQU00QixTQUFTLENBQUM1QixVQUFZaFQsMERBQVVBLENBQUNnVDtBQUN2QyxtRUFBbUU7QUFDbkUsU0FBUzZCLGdCQUFnQkMsTUFBTTtJQUMzQiw4REFBOEQ7SUFDOUQscUJBQU85VixpREFBVUEsQ0FBQzhWO0FBQ3RCO0FBRUEsc0VBQXNFO0FBQ3RFLE1BQU1DLDRCQUE0QixNQUFrQixHQUFjM1YsQ0FBZUEsR0FBR0gsNENBQVNBO0FBRTdGOzs7Ozs7O0NBT0MsR0FDRCxTQUFTK1YsU0FBU0MsUUFBUTtJQUN0Qjs7Ozs7O0tBTUMsR0FDRCxNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR2hXLCtDQUFRQSxDQUFDaVcsT0FBTztJQUM1Qzs7OztLQUlDLEdBQ0QsTUFBTSxDQUFDQyxNQUFNLEdBQUdsVywrQ0FBUUEsQ0FBQyxJQUFNbVcsWUFBWSxJQUFNSCxVQUFVSSxDQUFBQSxJQUFLQSxJQUFJSCxPQUFPO0lBQzNFOzs7O0tBSUMsR0FDREwsMEJBQTBCO1FBQ3RCLE1BQU1TLGFBQWFILE1BQU10QyxHQUFHO1FBQzVCLElBQUl5QyxXQUFXbEcsTUFBTSxFQUFFO1lBQ25CMkYsU0FBU087WUFDVEgsTUFBTTlLLEtBQUs7UUFDZjtJQUNKLEdBQUc7UUFBQzJLO0tBQU87SUFDWCxPQUFPRztBQUNYO0FBQ0EsU0FBU0MsWUFBWUcsRUFBRTtJQUNuQixJQUFJSixRQUFRLEVBQUU7SUFDZCxPQUFPO1FBQ0h0QyxLQUFLLElBQU1zQztRQUNYOUssT0FBTztZQUNIOEssUUFBUSxFQUFFO1FBQ2Q7UUFDQWxOLE1BQU0sQ0FBQzJGO1lBQ0h1SCxNQUFNbE4sSUFBSSxDQUFDMkY7WUFDWDJIO1FBQ0o7SUFDSjtBQUNKO0FBRUEsTUFBTUMsNkJBQWU3VyxvREFBYUEsQ0FBQztBQUNuQzs7Ozs7Q0FLQyxHQUNELFNBQVM4VyxjQUFjLEVBQUU5TyxRQUFRLEVBQUc7SUFDaEMsTUFBTTdCLFFBQVFFO0lBQ2QsTUFBTTBRLG1CQUFtQnZXLGtEQUFXQSxDQUFDLENBQUNtVztRQUNsQyxNQUFNLEVBQUV2TSxRQUFRLEVBQUUsRUFBRWdCLFFBQVEsRUFBRTRMLGVBQWUsRUFBRUMsYUFBYSxFQUFFN04sVUFBVSxFQUFFd0QsYUFBYSxFQUFFc0ssMEJBQTBCLEVBQUcsR0FBRy9RLE1BQU1HLFFBQVE7UUFDdkk7Ozs7U0FJQyxHQUNELElBQUk2USxPQUFPL007UUFDWCxLQUFLLE1BQU1nTixXQUFXVCxXQUFZO1lBQzlCUSxPQUFPLE9BQU9DLFlBQVksYUFBYUEsUUFBUUQsUUFBUUM7UUFDM0Q7UUFDQSxJQUFJNUQsVUFBVThCLHVCQUF1QjtZQUNqQ0osT0FBT2lDO1lBQ1A1QixRQUFRbk07UUFDWjtRQUNBLEtBQUssTUFBTWlPLGNBQWNILDJCQUEyQkksTUFBTSxHQUFJO1lBQzFEOUQsVUFBVTZELFdBQVc3RDtRQUN6QjtRQUNBLElBQUl3RCxpQkFBaUI7WUFDakI1TCxTQUFTK0w7UUFDYjtRQUNBLHVFQUF1RTtRQUN2RSxJQUFJM0QsUUFBUS9DLE1BQU0sR0FBRyxHQUFHO1lBQ3BCd0csZ0JBQWdCekQ7UUFDcEIsT0FDSyxJQUFJNUcsZUFBZTtZQUNwQix1RUFBdUU7WUFDdkUsc0NBQXNDO1lBQ3RDRyxPQUFPd0sscUJBQXFCLENBQUM7Z0JBQ3pCLE1BQU0sRUFBRTNLLGFBQWEsRUFBRXhDLEtBQUssRUFBRWdCLFFBQVEsRUFBRSxHQUFHakYsTUFBTUcsUUFBUTtnQkFDekQsSUFBSXNHLGVBQWU7b0JBQ2Z4QixTQUFTaEI7Z0JBQ2I7WUFDSjtRQUNKO0lBQ0osR0FBRyxFQUFFO0lBQ0wsTUFBTW9OLFlBQVlyQixTQUFTWTtJQUMzQixNQUFNVSxtQkFBbUJqWCxrREFBV0EsQ0FBQyxDQUFDbVc7UUFDbEMsTUFBTSxFQUFFdE0sUUFBUSxFQUFFLEVBQUVnQixRQUFRLEVBQUVxTSxlQUFlLEVBQUVDLGFBQWEsRUFBRWpPLFVBQVUsRUFBRSxHQUFHdkQsTUFBTUcsUUFBUTtRQUMzRixJQUFJNlEsT0FBTzlNO1FBQ1gsS0FBSyxNQUFNK00sV0FBV1QsV0FBWTtZQUM5QlEsT0FBTyxPQUFPQyxZQUFZLGFBQWFBLFFBQVFELFFBQVFDO1FBQzNEO1FBQ0EsSUFBSU0saUJBQWlCO1lBQ2pCck0sU0FBUzhMO1FBQ2IsT0FDSyxJQUFJUSxlQUFlO1lBQ3BCQSxjQUFjckMsdUJBQXVCO2dCQUNqQ0osT0FBT2lDO2dCQUNQNUIsUUFBUTdMO1lBQ1o7UUFDSjtJQUNKLEdBQUcsRUFBRTtJQUNMLE1BQU1rTyxZQUFZekIsU0FBU3NCO0lBQzNCLE1BQU1JLFFBQVEzWCw4Q0FBT0EsQ0FBQyxJQUFPO1lBQUVzWDtZQUFXSTtRQUFVLElBQUksRUFBRTtJQUMxRCxPQUFPN1gsc0RBQUdBLENBQUM4VyxhQUFhL1EsUUFBUSxFQUFFO1FBQUUrUixPQUFPQTtRQUFPN1AsVUFBVUE7SUFBUztBQUN6RTtBQUNBLFNBQVM4UDtJQUNMLE1BQU1DLGVBQWU5WCxpREFBVUEsQ0FBQzRXO0lBQ2hDLElBQUksQ0FBQ2tCLGNBQWM7UUFDZixNQUFNLElBQUkzUixNQUFNO0lBQ3BCO0lBQ0EsT0FBTzJSO0FBQ1g7QUFFQSxNQUFNQyxhQUFhLENBQUN2USxJQUFNLENBQUMsQ0FBQ0EsRUFBRTBKLE9BQU87QUFDckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ0QsU0FBUzhHO0lBQ0wsTUFBTUMsaUJBQWlCakg7SUFDdkIsTUFBTTlLLFFBQVFFO0lBQ2QsTUFBTTBSLGVBQWVEO0lBQ3JCLE1BQU1LLHNCQUFzQm5TLFNBQVNnUztJQUNyQyxNQUFNSSxnQkFBZ0JsWSw4Q0FBT0EsQ0FBQztRQUMxQixNQUFNbVksa0JBQWtCLENBQUN0USxLQUFPNUIsTUFBTUcsUUFBUSxHQUFHOEMsVUFBVSxDQUFDOEssR0FBRyxDQUFDbk07UUFDaEUsTUFBTXFELFdBQVcsQ0FBQ2dNO1lBQ2RXLGFBQWFQLFNBQVMsQ0FBQ2xPLElBQUksQ0FBQzhOO1FBQ2hDO1FBQ0EsTUFBTS9MLFdBQVcsQ0FBQytMO1lBQ2RXLGFBQWFILFNBQVMsQ0FBQ3RPLElBQUksQ0FBQzhOO1FBQ2hDO1FBQ0EsTUFBTWtCLGNBQWMsQ0FBQ25QO1lBQ2pCLE1BQU0sRUFBRUMsVUFBVSxFQUFFMEMsVUFBVSxFQUFFLEdBQUczRixNQUFNRyxRQUFRO1lBQ2pELE1BQU1pUyxZQUFZekMsT0FBTzNNLFFBQVFBLE9BQU9DLFdBQVc4SyxHQUFHLENBQUMvSyxLQUFLcEIsRUFBRTtZQUM5RCxNQUFNbkIsV0FBVzJSLFVBQVVDLFFBQVEsR0FDN0I5Vyx3RUFBd0JBLENBQUM2VyxVQUFVM1IsUUFBUSxFQUFFMlIsVUFBVTVELFFBQVEsRUFBRTRELFVBQVVDLFFBQVEsRUFBRXBQLFlBQVkwQyxjQUNqR3lNLFVBQVUzUixRQUFRO1lBQ3hCLE1BQU02UixtQkFBbUI7Z0JBQ3JCLEdBQUdGLFNBQVM7Z0JBQ1ozUjtnQkFDQUMsT0FBTzBSLFVBQVU1RCxRQUFRLEVBQUU5TixTQUFTMFIsVUFBVTFSLEtBQUs7Z0JBQ25EQyxRQUFReVIsVUFBVTVELFFBQVEsRUFBRTdOLFVBQVV5UixVQUFVelIsTUFBTTtZQUMxRDtZQUNBLE9BQU94RiwwREFBVUEsQ0FBQ21YO1FBQ3RCO1FBQ0EsTUFBTUMsYUFBYSxDQUFDM1EsSUFBSTRRLFlBQVk3SyxVQUFVO1lBQUVlLFNBQVM7UUFBTSxDQUFDO1lBQzVEekQsU0FBUyxDQUFDd04sWUFBY0EsVUFBVTVPLEdBQUcsQ0FBQyxDQUFDYjtvQkFDbkMsSUFBSUEsS0FBS3BCLEVBQUUsS0FBS0EsSUFBSTt3QkFDaEIsTUFBTTZOLFdBQVcsT0FBTytDLGVBQWUsYUFBYUEsV0FBV3hQLFFBQVF3UDt3QkFDdkUsT0FBTzdLLFFBQVFlLE9BQU8sSUFBSWlILE9BQU9GLFlBQVlBLFdBQVc7NEJBQUUsR0FBR3pNLElBQUk7NEJBQUUsR0FBR3lNLFFBQVE7d0JBQUM7b0JBQ25GO29CQUNBLE9BQU96TTtnQkFDWDtRQUNKO1FBQ0EsTUFBTTBQLGFBQWEsQ0FBQzlRLElBQUkrUSxZQUFZaEwsVUFBVTtZQUFFZSxTQUFTO1FBQU0sQ0FBQztZQUM1RHhELFNBQVMsQ0FBQzBOLFlBQWNBLFVBQVUvTyxHQUFHLENBQUMsQ0FBQ1A7b0JBQ25DLElBQUlBLEtBQUsxQixFQUFFLEtBQUtBLElBQUk7d0JBQ2hCLE1BQU1pUixXQUFXLE9BQU9GLGVBQWUsYUFBYUEsV0FBV3JQLFFBQVFxUDt3QkFDdkUsT0FBT2hMLFFBQVFlLE9BQU8sSUFBSWtILE9BQU9pRCxZQUFZQSxXQUFXOzRCQUFFLEdBQUd2UCxJQUFJOzRCQUFFLEdBQUd1UCxRQUFRO3dCQUFDO29CQUNuRjtvQkFDQSxPQUFPdlA7Z0JBQ1g7UUFDSjtRQUNBLE9BQU87WUFDSHdQLFVBQVUsSUFBTTlTLE1BQU1HLFFBQVEsR0FBRzhELEtBQUssQ0FBQ0osR0FBRyxDQUFDLENBQUMwTSxJQUFPO3dCQUFFLEdBQUdBLENBQUM7b0JBQUM7WUFDMUR3QyxTQUFTLENBQUNuUixLQUFPc1EsZ0JBQWdCdFEsS0FBS3dCLFVBQVVDO1lBQ2hENk87WUFDQWMsVUFBVTtnQkFDTixNQUFNLEVBQUU5TyxRQUFRLEVBQUUsRUFBRSxHQUFHbEUsTUFBTUcsUUFBUTtnQkFDckMsT0FBTytELE1BQU1MLEdBQUcsQ0FBQyxDQUFDb1AsSUFBTzt3QkFBRSxHQUFHQSxDQUFDO29CQUFDO1lBQ3BDO1lBQ0FDLFNBQVMsQ0FBQ3RSLEtBQU81QixNQUFNRyxRQUFRLEdBQUdvRCxVQUFVLENBQUN3SyxHQUFHLENBQUNuTTtZQUNqRHFEO1lBQ0FDO1lBQ0FpTyxVQUFVLENBQUNsQztnQkFDUCxNQUFNbUMsV0FBVy9LLE1BQU1DLE9BQU8sQ0FBQzJJLFdBQVdBLFVBQVU7b0JBQUNBO2lCQUFRO2dCQUM3RFcsYUFBYVAsU0FBUyxDQUFDbE8sSUFBSSxDQUFDLENBQUNjLFFBQVU7MkJBQUlBOzJCQUFVbVA7cUJBQVM7WUFDbEU7WUFDQUMsVUFBVSxDQUFDcEM7Z0JBQ1AsTUFBTXFDLFdBQVdqTCxNQUFNQyxPQUFPLENBQUMySSxXQUFXQSxVQUFVO29CQUFDQTtpQkFBUTtnQkFDN0RXLGFBQWFILFNBQVMsQ0FBQ3RPLElBQUksQ0FBQyxDQUFDZSxRQUFVOzJCQUFJQTsyQkFBVW9QO3FCQUFTO1lBQ2xFO1lBQ0FDLFVBQVU7Z0JBQ04sTUFBTSxFQUFFdFAsUUFBUSxFQUFFLEVBQUVDLFFBQVEsRUFBRSxFQUFFd0gsU0FBUyxFQUFFLEdBQUcxTCxNQUFNRyxRQUFRO2dCQUM1RCxNQUFNLENBQUN3RSxHQUFHQyxHQUFHQyxLQUFLLEdBQUc2RztnQkFDckIsT0FBTztvQkFDSHpILE9BQU9BLE1BQU1KLEdBQUcsQ0FBQyxDQUFDME0sSUFBTzs0QkFBRSxHQUFHQSxDQUFDO3dCQUFDO29CQUNoQ3JNLE9BQU9BLE1BQU1MLEdBQUcsQ0FBQyxDQUFDb1AsSUFBTzs0QkFBRSxHQUFHQSxDQUFDO3dCQUFDO29CQUNoQ3JILFVBQVU7d0JBQ05qSDt3QkFDQUM7d0JBQ0FDO29CQUNKO2dCQUNKO1lBQ0o7WUFDQTJPLGdCQUFnQixPQUFPLEVBQUV2UCxPQUFPd1AsZ0JBQWdCLEVBQUUsRUFBRXZQLE9BQU93UCxnQkFBZ0IsRUFBRSxFQUFFO2dCQUMzRSxNQUFNLEVBQUV6UCxLQUFLLEVBQUVDLEtBQUssRUFBRXlQLGFBQWEsRUFBRUMsYUFBYSxFQUFFQyxrQkFBa0IsRUFBRUMsa0JBQWtCLEVBQUVDLFFBQVEsRUFBRUMsY0FBYyxFQUFHLEdBQUdoVSxNQUFNRyxRQUFRO2dCQUN4SSxNQUFNLEVBQUU4RCxPQUFPZ1EsYUFBYSxFQUFFL1AsT0FBT2dRLGFBQWEsRUFBRSxHQUFHLE1BQU1qWixtRUFBbUJBLENBQUM7b0JBQzdFd1k7b0JBQ0FDO29CQUNBelA7b0JBQ0FDO29CQUNBOFA7Z0JBQ0o7Z0JBQ0EsTUFBTUcsbUJBQW1CRCxjQUFjNUosTUFBTSxHQUFHO2dCQUNoRCxNQUFNOEosbUJBQW1CSCxjQUFjM0osTUFBTSxHQUFHO2dCQUNoRCxJQUFJNkosa0JBQWtCO29CQUNsQixNQUFNRSxjQUFjSCxjQUFjclEsR0FBRyxDQUFDNkw7b0JBQ3RDa0UsZ0JBQWdCTTtvQkFDaEJKLG1CQUFtQk87Z0JBQ3ZCO2dCQUNBLElBQUlELGtCQUFrQjtvQkFDbEIsTUFBTUUsY0FBY0wsY0FBY3BRLEdBQUcsQ0FBQzZMO29CQUN0Q2lFLGdCQUFnQk07b0JBQ2hCSixtQkFBbUJTO2dCQUN2QjtnQkFDQSxJQUFJRixvQkFBb0JELGtCQUFrQjtvQkFDdENKLFdBQVc7d0JBQUU5UCxPQUFPZ1E7d0JBQWUvUCxPQUFPZ1E7b0JBQWM7Z0JBQzVEO2dCQUNBLE9BQU87b0JBQUVLLGNBQWNOO29CQUFlTyxjQUFjTjtnQkFBYztZQUN0RTtZQUNBOzs7O2FBSUMsR0FDRE8sc0JBQXNCLENBQUNDLFlBQVlDLFlBQVksSUFBSSxFQUFFMVE7Z0JBQ2pELE1BQU0yUSxTQUFTMVosNERBQVlBLENBQUN3WjtnQkFDNUIsTUFBTUcsV0FBV0QsU0FBU0YsYUFBYXZDLFlBQVl1QztnQkFDbkQsTUFBTUksaUJBQWlCN1EsVUFBVW1LO2dCQUNqQyxJQUFJLENBQUN5RyxVQUFVO29CQUNYLE9BQU8sRUFBRTtnQkFDYjtnQkFDQSxPQUFPLENBQUM1USxTQUFTakUsTUFBTUcsUUFBUSxHQUFHOEQsS0FBSyxFQUFFdUUsTUFBTSxDQUFDLENBQUMrSDtvQkFDN0MsTUFBTXdFLGVBQWUvVSxNQUFNRyxRQUFRLEdBQUc4QyxVQUFVLENBQUM4SyxHQUFHLENBQUN3QyxFQUFFM08sRUFBRTtvQkFDekQsSUFBSW1ULGdCQUFnQixDQUFDSCxVQUFXckUsQ0FBQUEsRUFBRTNPLEVBQUUsS0FBSzhTLFdBQVc5UyxFQUFFLElBQUksQ0FBQ21ULGFBQWEzUixTQUFTLENBQUM0UixnQkFBZ0IsR0FBRzt3QkFDakcsT0FBTztvQkFDWDtvQkFDQSxNQUFNQyxlQUFlOVosMERBQVVBLENBQUMyWixpQkFBaUJ2RSxJQUFJd0U7b0JBQ3JELE1BQU1HLGtCQUFrQjlaLGtFQUFrQkEsQ0FBQzZaLGNBQWNKO29CQUN6RCxNQUFNTSxtQkFBbUJSLGFBQWFPLGtCQUFrQjtvQkFDeEQsT0FBUUMsb0JBQ0pELG1CQUFtQkQsYUFBYXZVLEtBQUssR0FBR3VVLGFBQWF0VSxNQUFNLElBQzNEdVUsbUJBQW1CTCxTQUFTblUsS0FBSyxHQUFHbVUsU0FBU2xVLE1BQU07Z0JBQzNEO1lBQ0o7WUFDQXlVLG9CQUFvQixDQUFDVixZQUFZVyxNQUFNVixZQUFZLElBQUk7Z0JBQ25ELE1BQU1DLFNBQVMxWiw0REFBWUEsQ0FBQ3daO2dCQUM1QixNQUFNRyxXQUFXRCxTQUFTRixhQUFhdkMsWUFBWXVDO2dCQUNuRCxJQUFJLENBQUNHLFVBQVU7b0JBQ1gsT0FBTztnQkFDWDtnQkFDQSxNQUFNSyxrQkFBa0I5WixrRUFBa0JBLENBQUN5WixVQUFVUTtnQkFDckQsTUFBTUYsbUJBQW1CUixhQUFhTyxrQkFBa0I7Z0JBQ3hELE9BQVFDLG9CQUNKRCxtQkFBbUJHLEtBQUszVSxLQUFLLEdBQUcyVSxLQUFLMVUsTUFBTSxJQUMzQ3VVLG1CQUFtQkwsU0FBU25VLEtBQUssR0FBR21VLFNBQVNsVSxNQUFNO1lBQzNEO1lBQ0E0UjtZQUNBK0MsZ0JBQWdCLENBQUMxVCxJQUFJMlQsWUFBWTVOLFVBQVU7Z0JBQUVlLFNBQVM7WUFBTSxDQUFDO2dCQUN6RDZKLFdBQVczUSxJQUFJLENBQUNvQjtvQkFDWixNQUFNd1MsV0FBVyxPQUFPRCxlQUFlLGFBQWFBLFdBQVd2UyxRQUFRdVM7b0JBQ3ZFLE9BQU81TixRQUFRZSxPQUFPLEdBQUc7d0JBQUUsR0FBRzFGLElBQUk7d0JBQUV5UyxNQUFNRDtvQkFBUyxJQUFJO3dCQUFFLEdBQUd4UyxJQUFJO3dCQUFFeVMsTUFBTTs0QkFBRSxHQUFHelMsS0FBS3lTLElBQUk7NEJBQUUsR0FBR0QsUUFBUTt3QkFBQztvQkFBRTtnQkFDMUcsR0FBRzdOO1lBQ1A7WUFDQStLO1lBQ0FnRCxnQkFBZ0IsQ0FBQzlULElBQUkyVCxZQUFZNU4sVUFBVTtnQkFBRWUsU0FBUztZQUFNLENBQUM7Z0JBQ3pEZ0ssV0FBVzlRLElBQUksQ0FBQzBCO29CQUNaLE1BQU1rUyxXQUFXLE9BQU9ELGVBQWUsYUFBYUEsV0FBV2pTLFFBQVFpUztvQkFDdkUsT0FBTzVOLFFBQVFlLE9BQU8sR0FBRzt3QkFBRSxHQUFHcEYsSUFBSTt3QkFBRW1TLE1BQU1EO29CQUFTLElBQUk7d0JBQUUsR0FBR2xTLElBQUk7d0JBQUVtUyxNQUFNOzRCQUFFLEdBQUduUyxLQUFLbVMsSUFBSTs0QkFBRSxHQUFHRCxRQUFRO3dCQUFDO29CQUFFO2dCQUMxRyxHQUFHN047WUFDUDtZQUNBdE0sZ0JBQWdCLENBQUM0STtnQkFDYixNQUFNLEVBQUVoQixVQUFVLEVBQUUwQyxVQUFVLEVBQUUsR0FBRzNGLE1BQU1HLFFBQVE7Z0JBQ2pELE9BQU85RSw4REFBY0EsQ0FBQzRJLE9BQU87b0JBQUVoQjtvQkFBWTBDO2dCQUFXO1lBQzFEO1lBQ0FnUSxzQkFBc0IsQ0FBQyxFQUFFL0gsSUFBSSxFQUFFaE0sRUFBRSxFQUFFZ1UsTUFBTSxFQUFFLEdBQUt2TixNQUFNd04sSUFBSSxDQUFDN1YsTUFDdERHLFFBQVEsR0FDUjJWLGdCQUFnQixDQUFDL0gsR0FBRyxDQUFDLENBQUMsRUFBRTZILE9BQU8sQ0FBQyxFQUFFaEksS0FBSyxFQUFFaE0sS0FBSyxDQUFDLENBQUMsRUFBRUEsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQzVEdVAsWUFBWSxFQUFFO1lBQ3BCNEUsb0JBQW9CLENBQUMsRUFBRW5JLElBQUksRUFBRW9JLFFBQVEsRUFBRUosTUFBTSxFQUFFLEdBQUt2TixNQUFNd04sSUFBSSxDQUFDN1YsTUFDMURHLFFBQVEsR0FDUjJWLGdCQUFnQixDQUFDL0gsR0FBRyxDQUFDLENBQUMsRUFBRTZILE9BQU8sRUFBRWhJLE9BQVFvSSxXQUFXLENBQUMsQ0FBQyxFQUFFcEksS0FBSyxDQUFDLEVBQUVvSSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRXBJLEtBQUssQ0FBQyxHQUFJLEdBQUcsQ0FBQyxHQUM5RnVELFlBQVksRUFBRTtZQUNwQjhFLFNBQVMsT0FBT3RPO2dCQUNaLDJEQUEyRDtnQkFDM0QsMEZBQTBGO2dCQUMxRixNQUFNdU8sa0JBQWtCbFcsTUFBTUcsUUFBUSxHQUFHK1YsZUFBZSxJQUFJNWEsNkRBQWFBO2dCQUN6RSwyRUFBMkU7Z0JBQzNFMEUsTUFBTUksUUFBUSxDQUFDO29CQUFFcUcsZUFBZTtvQkFBTUMsZ0JBQWdCaUI7b0JBQVN1TztnQkFBZ0I7Z0JBQy9FdEUsYUFBYVAsU0FBUyxDQUFDbE8sSUFBSSxDQUFDLENBQUNjLFFBQVU7MkJBQUlBO3FCQUFNO2dCQUNqRCxPQUFPaVMsZ0JBQWdCQyxPQUFPO1lBQ2xDO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFDTCxPQUFPcGMsOENBQU9BLENBQUM7UUFDWCxPQUFPO1lBQ0gsR0FBR2tZLGFBQWE7WUFDaEIsR0FBR0YsY0FBYztZQUNqQkM7UUFDSjtJQUNKLEdBQUc7UUFBQ0E7S0FBb0I7QUFDNUI7QUFFQSxNQUFNOU8sV0FBVyxDQUFDNEYsT0FBU0EsS0FBSzVGLFFBQVE7QUFDeEMsTUFBTWtULFFBQVEsTUFBa0IsR0FBY3hQLENBQU1BLEdBQUd3SDtBQUN2RDs7OztDQUlDLEdBQ0QsU0FBU2lJLG9CQUFvQixFQUFFQyxhQUFhLEVBQUVDLHFCQUFxQixFQUFHO0lBQ2xFLE1BQU12VyxRQUFRRTtJQUNkLE1BQU0sRUFBRXNULGNBQWMsRUFBRSxHQUFHMUI7SUFDM0IsTUFBTTBFLG1CQUFtQi9PLFlBQVk2TyxlQUFlO1FBQUUxTyw0QkFBNEI7SUFBTTtJQUN4RixNQUFNNk8sMkJBQTJCaFAsWUFBWThPLHVCQUF1QjtRQUFFNVQsUUFBUXlUO0lBQU07SUFDcEZuYyxnREFBU0EsQ0FBQztRQUNOLElBQUl1YyxrQkFBa0I7WUFDbEIsTUFBTSxFQUFFdFMsS0FBSyxFQUFFRCxLQUFLLEVBQUUsR0FBR2pFLE1BQU1HLFFBQVE7WUFDdkNxVCxlQUFlO2dCQUFFdlAsT0FBT0EsTUFBTXVFLE1BQU0sQ0FBQ3RGO2dCQUFXZ0IsT0FBT0EsTUFBTXNFLE1BQU0sQ0FBQ3RGO1lBQVU7WUFDOUVsRCxNQUFNSSxRQUFRLENBQUM7Z0JBQUVzVyxzQkFBc0I7WUFBTTtRQUNqRDtJQUNKLEdBQUc7UUFBQ0Y7S0FBaUI7SUFDckJ2YyxnREFBU0EsQ0FBQztRQUNOK0YsTUFBTUksUUFBUSxDQUFDO1lBQUV1VyxzQkFBc0JGO1FBQXlCO0lBQ3BFLEdBQUc7UUFBQ0E7S0FBeUI7QUFDakM7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0csaUJBQWlCbEssT0FBTztJQUM3QixNQUFNMU0sUUFBUUU7SUFDZGpHLGdEQUFTQSxDQUFDO1FBQ04sTUFBTTRjLG1CQUFtQjtZQUNyQixJQUFJLENBQUNuSyxRQUFRckcsT0FBTyxJQUFJLENBQUVxRyxDQUFBQSxRQUFRckcsT0FBTyxDQUFDeVEsZUFBZSxRQUFRLElBQUcsR0FBSTtnQkFDcEUsT0FBTztZQUNYO1lBQ0EsTUFBTXZNLE9BQU8vTyw2REFBYUEsQ0FBQ2tSLFFBQVFyRyxPQUFPO1lBQzFDLElBQUlrRSxLQUFLNUosTUFBTSxLQUFLLEtBQUs0SixLQUFLN0osS0FBSyxLQUFLLEdBQUc7Z0JBQ3ZDVixNQUFNRyxRQUFRLEdBQUc0VyxPQUFPLEdBQUcsT0FBT3ZjLHlEQUFhLENBQUMsV0FBVztZQUMvRDtZQUNBd0YsTUFBTUksUUFBUSxDQUFDO2dCQUFFTSxPQUFPNkosS0FBSzdKLEtBQUssSUFBSTtnQkFBS0MsUUFBUTRKLEtBQUs1SixNQUFNLElBQUk7WUFBSTtRQUMxRTtRQUNBLElBQUkrTCxRQUFRckcsT0FBTyxFQUFFO1lBQ2pCd1E7WUFDQWpRLE9BQU9TLGdCQUFnQixDQUFDLFVBQVV3UDtZQUNsQyxNQUFNRyxpQkFBaUIsSUFBSUMsZUFBZSxJQUFNSjtZQUNoREcsZUFBZUUsT0FBTyxDQUFDeEssUUFBUXJHLE9BQU87WUFDdEMsT0FBTztnQkFDSE8sT0FBT1UsbUJBQW1CLENBQUMsVUFBVXVQO2dCQUNyQyxJQUFJRyxrQkFBa0J0SyxRQUFRckcsT0FBTyxFQUFFO29CQUNuQzJRLGVBQWVHLFNBQVMsQ0FBQ3pLLFFBQVFyRyxPQUFPO2dCQUM1QztZQUNKO1FBQ0o7SUFDSixHQUFHLEVBQUU7QUFDVDtBQUVBLE1BQU0rUSxpQkFBaUI7SUFDbkIzVyxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsUUFBUTtJQUNSMFcsS0FBSztJQUNMQyxNQUFNO0FBQ1Y7QUFFQSxNQUFNQyxhQUFhLENBQUNqVyxJQUFPO1FBQ3ZCa1cscUJBQXFCbFcsRUFBRWtXLG1CQUFtQjtRQUMxQ0MsS0FBS25XLEVBQUVtVyxHQUFHO1FBQ1ZDLHNCQUFzQnBXLEVBQUVxVyxVQUFVLENBQUNDLFVBQVU7SUFDakQ7QUFDQSxTQUFTQyxTQUFTLEVBQUVDLGlCQUFpQixFQUFFQyxlQUFlLElBQUksRUFBRUMsY0FBYyxJQUFJLEVBQUVDLGNBQWMsS0FBSyxFQUFFQyxtQkFBbUIsR0FBRyxFQUFFQyxrQkFBa0J6YywyREFBZUEsQ0FBQzBjLElBQUksRUFBRUMsb0JBQW9CLElBQUksRUFBRUMsWUFBWSxJQUFJLEVBQUU1VCxlQUFlLEVBQUVnQixlQUFlLEVBQUVFLE9BQU8sRUFBRUMsT0FBTyxFQUFFMFMscUJBQXFCLEVBQUVDLG1CQUFtQixJQUFJLEVBQUUzVyxRQUFRLEVBQUU0VyxnQkFBZ0IsRUFBRTFTLGNBQWMsRUFBRTJTLGdCQUFnQixFQUFFQyxvQkFBb0IsRUFBRUMsaUJBQWlCLEVBQUVDLGVBQWUsRUFBRztJQUMxYSxNQUFNN1ksUUFBUUU7SUFDZCxNQUFNNFksV0FBVzVlLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU0sRUFBRXNkLG1CQUFtQixFQUFFQyxHQUFHLEVBQUVDLG9CQUFvQixFQUFFLEdBQUc3WCxTQUFTMFgsWUFBWWhZLG9EQUFPQTtJQUN2RixNQUFNd1osMkJBQTJCdFIsWUFBWThRO0lBQzdDLE1BQU12TixVQUFVOVEsNkNBQU1BO0lBQ3RCMGMsaUJBQWlCa0M7SUFDakIsTUFBTUUsb0JBQW9CM2Usa0RBQVdBLENBQUMsQ0FBQ3FSO1FBQ25DZ04sbUJBQW1CO1lBQUUvVCxHQUFHK0csU0FBUyxDQUFDLEVBQUU7WUFBRTlHLEdBQUc4RyxTQUFTLENBQUMsRUFBRTtZQUFFN0csTUFBTTZHLFNBQVMsQ0FBQyxFQUFFO1FBQUM7UUFDMUUsSUFBSSxDQUFDaU4sc0JBQXNCO1lBQ3ZCM1ksTUFBTUksUUFBUSxDQUFDO2dCQUFFc0w7WUFBVTtRQUMvQjtJQUNKLEdBQUc7UUFBQ2dOO1FBQWtCQztLQUFxQjtJQUMzQzFlLGdEQUFTQSxDQUFDO1FBQ04sSUFBSTZlLFNBQVN6UyxPQUFPLEVBQUU7WUFDbEIyRSxRQUFRM0UsT0FBTyxHQUFHNUsseURBQVNBLENBQUM7Z0JBQ3hCaVIsU0FBU29NLFNBQVN6UyxPQUFPO2dCQUN6QlQ7Z0JBQ0FDO2dCQUNBSDtnQkFDQWtHLFVBQVVsSDtnQkFDVnVVLGtCQUFrQixDQUFDQyxlQUFpQmxaLE1BQU1JLFFBQVEsQ0FBQzt3QkFBRThZO29CQUFhO2dCQUNsRUMsZ0JBQWdCLENBQUNsUSxPQUFPbVE7b0JBQ3BCLE1BQU0sRUFBRUMscUJBQXFCLEVBQUVDLFdBQVcsRUFBRSxHQUFHdFosTUFBTUcsUUFBUTtvQkFDN0RtWixjQUFjclEsT0FBT21RO29CQUNyQkMsd0JBQXdCRDtnQkFDNUI7Z0JBQ0FHLFdBQVcsQ0FBQ3RRLE9BQU9tUTtvQkFDZixNQUFNLEVBQUVWLGdCQUFnQixFQUFFYyxNQUFNLEVBQUUsR0FBR3haLE1BQU1HLFFBQVE7b0JBQ25EcVosU0FBU3ZRLE9BQU9tUTtvQkFDaEJWLG1CQUFtQlU7Z0JBQ3ZCO2dCQUNBSyxjQUFjLENBQUN4USxPQUFPbVE7b0JBQ2xCLE1BQU0sRUFBRU0sbUJBQW1CLEVBQUVDLFNBQVMsRUFBRSxHQUFHM1osTUFBTUcsUUFBUTtvQkFDekR3WixZQUFZMVEsT0FBT21RO29CQUNuQk0sc0JBQXNCTjtnQkFDMUI7WUFDSjtZQUNBLE1BQU0sRUFBRXpVLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxJQUFJLEVBQUUsR0FBR21HLFFBQVEzRSxPQUFPLENBQUMyRixXQUFXO1lBQ2xEaE0sTUFBTUksUUFBUSxDQUFDO2dCQUNYNEssU0FBU0EsUUFBUTNFLE9BQU87Z0JBQ3hCcUYsV0FBVztvQkFBQy9HO29CQUFHQztvQkFBR0M7aUJBQUs7Z0JBQ3ZCNkgsU0FBU29NLFNBQVN6UyxPQUFPLENBQUN1VCxPQUFPLENBQUM7WUFDdEM7WUFDQSxPQUFPO2dCQUNINU8sUUFBUTNFLE9BQU8sRUFBRXdUO1lBQ3JCO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFDTDVmLGdEQUFTQSxDQUFDO1FBQ04rUSxRQUFRM0UsT0FBTyxFQUFFeVQsT0FBTztZQUNwQmhDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FFO1lBQ0FDO1lBQ0FTO1lBQ0FQO1lBQ0F6UztZQUNBeVI7WUFDQWlCO1lBQ0FoQjtZQUNBdUI7WUFDQXRCO1lBQ0FtQjtZQUNBRDtRQUNKO0lBQ0osR0FBRztRQUNDZDtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBRTtRQUNBQztRQUNBUztRQUNBUDtRQUNBelM7UUFDQXlSO1FBQ0FpQjtRQUNBaEI7UUFDQXVCO1FBQ0F0QjtRQUNBbUI7UUFDQUQ7S0FDSDtJQUNELE9BQVFoZixzREFBR0EsQ0FBQyxPQUFPO1FBQUVxSSxXQUFXO1FBQXdCRSxLQUFLMlc7UUFBVXhZLE9BQU84VztRQUFnQnZWLFVBQVVBO0lBQVM7QUFDckg7QUFFQSxNQUFNa1ksYUFBYSxDQUFDelksSUFBTztRQUN2QmtXLHFCQUFxQmxXLEVBQUVrVyxtQkFBbUI7UUFDMUN3QyxtQkFBbUIxWSxFQUFFMFksaUJBQWlCO0lBQzFDO0FBQ0EsU0FBU0M7SUFDTCxNQUFNLEVBQUV6QyxtQkFBbUIsRUFBRXdDLGlCQUFpQixFQUFFLEdBQUduYSxTQUFTa2EsWUFBWXhhLG9EQUFPQTtJQUMvRSxNQUFNMmEsV0FBVzFDLHVCQUF1QndDO0lBQ3hDLElBQUksQ0FBQ0UsVUFBVTtRQUNYLE9BQU87SUFDWDtJQUNBLE9BQVF0Z0Isc0RBQUdBLENBQUMsT0FBTztRQUFFcUksV0FBVztRQUErQzNCLE9BQU87WUFDOUVJLE9BQU9zWixrQkFBa0J0WixLQUFLO1lBQzlCQyxRQUFRcVosa0JBQWtCclosTUFBTTtZQUNoQytLLFdBQVcsQ0FBQyxVQUFVLEVBQUVzTyxrQkFBa0JyVixDQUFDLENBQUMsSUFBSSxFQUFFcVYsa0JBQWtCcFYsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUM5RTtJQUFFO0FBQ1Y7QUFFQSxNQUFNdVYsY0FBYyxDQUFDQyxTQUFTQztJQUMxQixPQUFPLENBQUNwUjtRQUNKLElBQUlBLE1BQU10RyxNQUFNLEtBQUswWCxhQUFhaFUsT0FBTyxFQUFFO1lBQ3ZDO1FBQ0o7UUFDQStULFVBQVVuUjtJQUNkO0FBQ0o7QUFDQSxNQUFNcVIsYUFBYSxDQUFDaFosSUFBTztRQUN2QmtXLHFCQUFxQmxXLEVBQUVrVyxtQkFBbUI7UUFDMUMxUixvQkFBb0J4RSxFQUFFd0Usa0JBQWtCO1FBQ3hDNFIsc0JBQXNCcFcsRUFBRXFXLFVBQVUsQ0FBQ0MsVUFBVTtRQUM3Q3RKLFVBQVVoTixFQUFFNFgsWUFBWTtJQUM1QjtBQUNBLFNBQVNxQixLQUFLLEVBQUVDLFdBQVcsRUFBRUMsbUJBQW1CLEVBQUVDLGdCQUFnQi9lLHlEQUFhQSxDQUFDZ2YsSUFBSSxFQUFFckMsU0FBUyxFQUFFTSxpQkFBaUIsRUFBRUMsZUFBZSxFQUFFK0IsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRUMsV0FBVyxFQUFFaEQsaUJBQWlCLEVBQUVpRCxZQUFZLEVBQUVDLGdCQUFnQixFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFclosUUFBUSxFQUFHO0lBQ2pSLE1BQU03QixRQUFRRTtJQUNkLE1BQU0sRUFBRXNYLG1CQUFtQixFQUFFMVIsa0JBQWtCLEVBQUV3SSxRQUFRLEVBQUVvSixvQkFBb0IsRUFBRSxHQUFHN1gsU0FBU3lhLFlBQVkvYSxvREFBT0E7SUFDaEgsTUFBTTRiLHFCQUFxQnJWLHNCQUF1QjBVLENBQUFBLGVBQWVoRCxtQkFBa0I7SUFDbkYsTUFBTTRELFlBQVlsaEIsNkNBQU1BLENBQUM7SUFDekIsTUFBTW1oQixrQkFBa0JuaEIsNkNBQU1BO0lBQzlCLE1BQU1vaEIsa0JBQWtCcGhCLDZDQUFNQSxDQUFDLElBQUkrTjtJQUNuQyxNQUFNc1Qsa0JBQWtCcmhCLDZDQUFNQSxDQUFDLElBQUkrTjtJQUNuQyw0RkFBNEY7SUFDNUYsTUFBTXVULHNCQUFzQnRoQiw2Q0FBTUEsQ0FBQztJQUNuQyxNQUFNdWhCLFVBQVUsQ0FBQ3hTO1FBQ2Isc0ZBQXNGO1FBQ3RGLGdFQUFnRTtRQUNoRSxJQUFJdVMsb0JBQW9CblYsT0FBTyxJQUFJcVIsc0JBQXNCO1lBQ3JEOEQsb0JBQW9CblYsT0FBTyxHQUFHO1lBQzlCO1FBQ0o7UUFDQXlVLGNBQWM3UjtRQUNkakosTUFBTUcsUUFBUSxHQUFHdWIscUJBQXFCO1FBQ3RDMWIsTUFBTUksUUFBUSxDQUFDO1lBQUVzVyxzQkFBc0I7UUFBTTtJQUNqRDtJQUNBLE1BQU1pRixnQkFBZ0IsQ0FBQzFTO1FBQ25CLElBQUlaLE1BQU1DLE9BQU8sQ0FBQ2dRLGNBQWNBLFdBQVd6TixTQUFTLElBQUk7WUFDcEQ1QixNQUFNYyxjQUFjO1lBQ3BCO1FBQ0o7UUFDQStOLG9CQUFvQjdPO0lBQ3hCO0lBQ0EsTUFBTTJTLFVBQVViLGVBQWUsQ0FBQzlSLFFBQVU4UixhQUFhOVIsU0FBU21GO0lBQ2hFLE1BQU15TixpQkFBaUIsQ0FBQzVTO1FBQ3BCLElBQUl1UyxvQkFBb0JuVixPQUFPLEVBQUU7WUFDN0I0QyxNQUFNNlMsZUFBZTtZQUNyQk4sb0JBQW9CblYsT0FBTyxHQUFHO1FBQ2xDO0lBQ0o7SUFDQSxxRUFBcUU7SUFDckUsMkRBQTJEO0lBQzNELE1BQU0wVix1QkFBdUIsQ0FBQzlTO1FBQzFCLE1BQU0sRUFBRXlELE9BQU8sRUFBRSxHQUFHMU0sTUFBTUcsUUFBUTtRQUNsQ2tiLGdCQUFnQmhWLE9BQU8sR0FBR3FHLFNBQVNHO1FBQ25DLElBQUksQ0FBQ3dPLGdCQUFnQmhWLE9BQU8sRUFDeEI7UUFDSixNQUFNMlYseUJBQXlCL1MsTUFBTXRHLE1BQU0sS0FBS3lZLFVBQVUvVSxPQUFPO1FBQ2pFLDJHQUEyRztRQUMzRyxNQUFNNFYsZUFBZSxDQUFDRCwwQkFBMEIsQ0FBQyxDQUFDL1MsTUFBTXRHLE1BQU0sQ0FBQ2lYLE9BQU8sQ0FBQztRQUN2RSxNQUFNc0Msb0JBQW9CLG1CQUFvQkYsMEJBQTJCdkI7UUFDekUsSUFBSXdCLGdCQUFnQixDQUFDekIsZUFBZSxDQUFDMEIscUJBQXFCalQsTUFBTWtULE1BQU0sS0FBSyxLQUFLLENBQUNsVCxNQUFNbVQsU0FBUyxFQUFFO1lBQzlGO1FBQ0o7UUFDQW5ULE1BQU10RyxNQUFNLEVBQUUwWixvQkFBb0JwVCxNQUFNcVQsU0FBUztRQUNqRGQsb0JBQW9CblYsT0FBTyxHQUFHO1FBQzlCLE1BQU0sRUFBRTFCLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUdoSixnRUFBZ0JBLENBQUNxTixNQUFNc1QsV0FBVyxFQUFFbEIsZ0JBQWdCaFYsT0FBTztRQUM1RXJHLE1BQU1JLFFBQVEsQ0FBQztZQUNYNFosbUJBQW1CO2dCQUNmdFosT0FBTztnQkFDUEMsUUFBUTtnQkFDUjZiLFFBQVE3WDtnQkFDUjhYLFFBQVE3WDtnQkFDUkQ7Z0JBQ0FDO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ29YLHdCQUF3QjtZQUN6Qi9TLE1BQU02UyxlQUFlO1lBQ3JCN1MsTUFBTWMsY0FBYztRQUN4QjtJQUNKO0lBQ0EsTUFBTTJTLGdCQUFnQixDQUFDelQ7UUFDbkIsTUFBTSxFQUFFK1EsaUJBQWlCLEVBQUV0TyxTQUFTLEVBQUV6SSxVQUFVLEVBQUVNLFVBQVUsRUFBRXVTLGdCQUFnQixFQUFFakMsa0JBQWtCLEVBQUVDLGtCQUFrQixFQUFFNkksa0JBQWtCLEVBQUVqQixxQkFBcUIsRUFBRyxHQUFHMWIsTUFBTUcsUUFBUTtRQUNyTCxJQUFJLENBQUNrYixnQkFBZ0JoVixPQUFPLElBQUksQ0FBQzJULG1CQUFtQjtZQUNoRDtRQUNKO1FBQ0EsTUFBTSxFQUFFclYsR0FBR2lZLE1BQU0sRUFBRWhZLEdBQUdpWSxNQUFNLEVBQUUsR0FBR2poQixnRUFBZ0JBLENBQUNxTixNQUFNc1QsV0FBVyxFQUFFbEIsZ0JBQWdCaFYsT0FBTztRQUM1RixNQUFNLEVBQUVtVyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHekM7UUFDM0IsSUFBSSxDQUFDd0Isb0JBQW9CblYsT0FBTyxFQUFFO1lBQzlCLE1BQU15VyxtQkFBbUJyQyxzQkFBc0IsSUFBSTdCO1lBQ25ELE1BQU1tRSxXQUFXQyxLQUFLQyxLQUFLLENBQUNMLFNBQVNKLFFBQVFLLFNBQVNKO1lBQ3RELElBQUlNLFlBQVlELGtCQUFrQjtnQkFDOUI7WUFDSjtZQUNBcEI7WUFDQWQsbUJBQW1CM1I7UUFDdkI7UUFDQXVTLG9CQUFvQm5WLE9BQU8sR0FBRztRQUM5QixNQUFNNlcscUJBQXFCO1lBQ3ZCVjtZQUNBQztZQUNBOVgsR0FBR2lZLFNBQVNKLFNBQVNJLFNBQVNKO1lBQzlCNVgsR0FBR2lZLFNBQVNKLFNBQVNJLFNBQVNKO1lBQzlCL2IsT0FBT3NjLEtBQUtHLEdBQUcsQ0FBQ1AsU0FBU0o7WUFDekI3YixRQUFRcWMsS0FBS0csR0FBRyxDQUFDTixTQUFTSjtRQUM5QjtRQUNBLE1BQU1XLHNCQUFzQjlCLGdCQUFnQmpWLE9BQU87UUFDbkQsTUFBTWdYLHNCQUFzQjlCLGdCQUFnQmxWLE9BQU87UUFDbkRpVixnQkFBZ0JqVixPQUFPLEdBQUcsSUFBSTRCLElBQUlwTSw4REFBY0EsQ0FBQ29ILFlBQVlpYSxvQkFBb0J4UixXQUFXZ1Asa0JBQWtCL2UseURBQWFBLENBQUMyaEIsT0FBTyxFQUFFLE1BQU16WixHQUFHLENBQUMsQ0FBQ2IsT0FBU0EsS0FBS3BCLEVBQUU7UUFDaEsyWixnQkFBZ0JsVixPQUFPLEdBQUcsSUFBSTRCO1FBQzlCLE1BQU1zVixrQkFBa0JaLG9CQUFvQmEsY0FBYztRQUMxRCx3REFBd0Q7UUFDeEQsS0FBSyxNQUFNNUgsVUFBVTBGLGdCQUFnQmpWLE9BQU8sQ0FBRTtZQUMxQyxNQUFNb1gsY0FBYzNILGlCQUFpQi9ILEdBQUcsQ0FBQzZIO1lBQ3pDLElBQUksQ0FBQzZILGFBQ0Q7WUFDSixLQUFLLE1BQU0sRUFBRUMsTUFBTSxFQUFFLElBQUlELFlBQVl0TSxNQUFNLEdBQUk7Z0JBQzNDLE1BQU03TixPQUFPQyxXQUFXd0ssR0FBRyxDQUFDMlA7Z0JBQzVCLElBQUlwYSxRQUFTQSxDQUFBQSxLQUFLa2EsVUFBVSxJQUFJRCxlQUFjLEdBQUk7b0JBQzlDaEMsZ0JBQWdCbFYsT0FBTyxDQUFDcUQsR0FBRyxDQUFDZ1U7Z0JBQ2hDO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQzVoQiw0REFBWUEsQ0FBQ3NoQixxQkFBcUI5QixnQkFBZ0JqVixPQUFPLEdBQUc7WUFDN0QsTUFBTWdILFVBQVV5QixvQkFBb0I3TCxZQUFZcVksZ0JBQWdCalYsT0FBTyxFQUFFO1lBQ3pFd04sbUJBQW1CeEc7UUFDdkI7UUFDQSxJQUFJLENBQUN2Uiw0REFBWUEsQ0FBQ3VoQixxQkFBcUI5QixnQkFBZ0JsVixPQUFPLEdBQUc7WUFDN0QsTUFBTWdILFVBQVV5QixvQkFBb0J2TCxZQUFZZ1ksZ0JBQWdCbFYsT0FBTztZQUN2RXlOLG1CQUFtQnpHO1FBQ3ZCO1FBQ0FyTixNQUFNSSxRQUFRLENBQUM7WUFDWDRaLG1CQUFtQmtEO1lBQ25CMUYscUJBQXFCO1lBQ3JCZCxzQkFBc0I7UUFDMUI7SUFDSjtJQUNBLE1BQU1pSCxjQUFjLENBQUMxVTtRQUNqQixJQUFJQSxNQUFNa1QsTUFBTSxLQUFLLEdBQUc7WUFDcEI7UUFDSjtRQUNBbFQsTUFBTXRHLE1BQU0sRUFBRWliLHdCQUF3QjNVLE1BQU1xVCxTQUFTO1FBQ3JEOzs7U0FHQyxHQUNELElBQUksQ0FBQzlFLHVCQUF1QnZPLE1BQU10RyxNQUFNLEtBQUt5WSxVQUFVL1UsT0FBTyxJQUFJckcsTUFBTUcsUUFBUSxHQUFHNlosaUJBQWlCLEVBQUU7WUFDbEd5QixVQUFVeFM7UUFDZDtRQUNBakosTUFBTUksUUFBUSxDQUFDO1lBQ1hvWCxxQkFBcUI7WUFDckJ3QyxtQkFBbUI7UUFDdkI7UUFDQSxJQUFJd0Isb0JBQW9CblYsT0FBTyxFQUFFO1lBQzdCd1UsaUJBQWlCNVI7WUFDakJqSixNQUFNSSxRQUFRLENBQUM7Z0JBQ1hzVyxzQkFBc0I0RSxnQkFBZ0JqVixPQUFPLENBQUNrRSxJQUFJLEdBQUc7WUFDekQ7UUFDSjtJQUNKO0lBQ0EsTUFBTXNULFlBQVl2RixjQUFjLFFBQVNqUSxNQUFNQyxPQUFPLENBQUNnUSxjQUFjQSxVQUFVek4sUUFBUSxDQUFDO0lBQ3hGLE9BQVFuUix1REFBSUEsQ0FBQyxPQUFPO1FBQUV1SSxXQUFXMUgsb0RBQUVBLENBQUM7WUFBQztZQUFvQjtnQkFBRXNqQjtnQkFBV3ZQO2dCQUFVd1AsV0FBV3REO1lBQVk7U0FBRTtRQUFHaUIsU0FBU04scUJBQXFCL00sWUFBWStMLFlBQVlzQixTQUFTTDtRQUFZTyxlQUFleEIsWUFBWXdCLGVBQWVQO1FBQVlRLFNBQVN6QixZQUFZeUIsU0FBU1I7UUFBWTJDLGdCQUFnQjVDLHFCQUFxQi9NLFlBQVk0TTtRQUFrQjBCLGVBQWV2QixxQkFBcUJ1QixnQkFBZ0J6QjtRQUFpQjBDLGFBQWF4QyxxQkFBcUJ3QyxjQUFjdlA7UUFBVzJOLHNCQUFzQloscUJBQXFCWSx1QkFBdUIzTjtRQUFXeU4sZ0JBQWdCVixxQkFBcUJVLGlCQUFpQnpOO1FBQVc0UCxnQkFBZ0I5QztRQUFrQi9ZLEtBQUtpWjtRQUFXOWEsT0FBTzhXO1FBQWdCdlYsVUFBVTtZQUFDQTtZQUFVakksc0RBQUdBLENBQUNxZ0IsZUFBZSxDQUFDO1NBQUc7SUFBQztBQUNsdUI7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNnRSxnQkFBZ0IsRUFBRXJjLEVBQUUsRUFBRTVCLEtBQUssRUFBRWtlLFdBQVcsS0FBSyxFQUFFQyxPQUFPLEVBQUc7SUFDOUQsTUFBTSxFQUFFQyxnQkFBZ0IsRUFBRUMscUJBQXFCLEVBQUUxSCxvQkFBb0IsRUFBRTFULFVBQVUsRUFBRThULE9BQU8sRUFBRSxHQUFHL1csTUFBTUcsUUFBUTtJQUM3RyxNQUFNNkMsT0FBT0MsV0FBVzhLLEdBQUcsQ0FBQ25NO0lBQzVCLElBQUksQ0FBQ29CLE1BQU07UUFDUCtULFVBQVUsT0FBT3ZjLHlEQUFhLENBQUMsV0FBVyxDQUFDb0g7UUFDM0M7SUFDSjtJQUNBNUIsTUFBTUksUUFBUSxDQUFDO1FBQUVzVyxzQkFBc0I7SUFBTTtJQUM3QyxJQUFJLENBQUMxVCxLQUFLRSxRQUFRLEVBQUU7UUFDaEJrYixpQkFBaUI7WUFBQ3hjO1NBQUc7SUFDekIsT0FDSyxJQUFJc2MsWUFBYWxiLEtBQUtFLFFBQVEsSUFBSXlULHNCQUF1QjtRQUMxRDBILHNCQUFzQjtZQUFFcGEsT0FBTztnQkFBQ2pCO2FBQUs7WUFBRWtCLE9BQU8sRUFBRTtRQUFDO1FBQ2pEa04sc0JBQXNCLElBQU0rTSxTQUFTOVgsU0FBU2lZO0lBQ2xEO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU0MsUUFBUSxFQUFFSixPQUFPLEVBQUVLLFdBQVcsS0FBSyxFQUFFQyxlQUFlLEVBQUVDLGNBQWMsRUFBRTlJLE1BQU0sRUFBRStJLFlBQVksRUFBRUMsaUJBQWlCLEVBQUc7SUFDckgsTUFBTTVlLFFBQVFFO0lBQ2QsTUFBTSxDQUFDb08sVUFBVXVRLFlBQVksR0FBRzFrQiwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNMmtCLFNBQVM1a0IsNkNBQU1BO0lBQ3JCRCxnREFBU0EsQ0FBQztRQUNONmtCLE9BQU96WSxPQUFPLEdBQUd0SyxzREFBTUEsQ0FBQztZQUNwQmdqQixlQUFlLElBQU0vZSxNQUFNRyxRQUFRO1lBQ25DNmUsaUJBQWlCLENBQUNwZDtnQkFDZHFjLGdCQUFnQjtvQkFDWnJjO29CQUNBNUI7b0JBQ0FtZTtnQkFDSjtZQUNKO1lBQ0FjLGFBQWE7Z0JBQ1RKLFlBQVk7WUFDaEI7WUFDQUssWUFBWTtnQkFDUkwsWUFBWTtZQUNoQjtRQUNKO0lBQ0osR0FBRyxFQUFFO0lBQ0w1a0IsZ0RBQVNBLENBQUM7UUFDTixJQUFJdWtCLFVBQVU7WUFDVk0sT0FBT3pZLE9BQU8sRUFBRXdUO1FBQ3BCLE9BQ0ssSUFBSXNFLFFBQVE5WCxPQUFPLEVBQUU7WUFDdEJ5WSxPQUFPelksT0FBTyxFQUFFeVQsT0FBTztnQkFDbkIyRTtnQkFDQUM7Z0JBQ0FoUyxTQUFTeVIsUUFBUTlYLE9BQU87Z0JBQ3hCc1k7Z0JBQ0EvSTtnQkFDQWdKO1lBQ0o7WUFDQSxPQUFPO2dCQUNIRSxPQUFPelksT0FBTyxFQUFFd1Q7WUFDcEI7UUFDSjtJQUNKLEdBQUc7UUFBQzRFO1FBQWlCQztRQUFnQkY7UUFBVUc7UUFBY1I7UUFBU3ZJO0tBQU87SUFDN0UsT0FBT3RIO0FBQ1g7QUFFQSxNQUFNNlEsdUJBQXVCLENBQUNDLGlCQUFtQixDQUFDN08sSUFBTUEsRUFBRXJOLFFBQVEsSUFBS3FOLENBQUFBLEVBQUVzTixTQUFTLElBQUt1QixrQkFBa0IsT0FBTzdPLEVBQUVzTixTQUFTLEtBQUssV0FBVztBQUMzSTs7Ozs7Q0FLQyxHQUNELFNBQVN3QjtJQUNMLE1BQU1yZixRQUFRRTtJQUNkLE1BQU1vZixvQkFBb0JqbEIsa0RBQVdBLENBQUMsQ0FBQzJKO1FBQ25DLE1BQU0sRUFBRXViLFVBQVUsRUFBRTlTLFVBQVUsRUFBRUQsUUFBUSxFQUFFNFMsY0FBYyxFQUFFckksT0FBTyxFQUFFeUksbUJBQW1CLEVBQUV2YyxVQUFVLEVBQUUwQyxVQUFVLEVBQUUsR0FBRzNGLE1BQU1HLFFBQVE7UUFDakksTUFBTXNmLGNBQWMsSUFBSWhTO1FBQ3hCLE1BQU1pUyxhQUFhUCxxQkFBcUJDO1FBQ3hDOzs7U0FHQyxHQUNELE1BQU1PLFFBQVFsVCxhQUFhRCxRQUFRLENBQUMsRUFBRSxHQUFHO1FBQ3pDLE1BQU1vVCxRQUFRblQsYUFBYUQsUUFBUSxDQUFDLEVBQUUsR0FBRztRQUN6QyxNQUFNcVQsUUFBUTdiLE9BQU84YixTQUFTLENBQUNuYixDQUFDLEdBQUdnYixRQUFRM2IsT0FBTytiLE1BQU07UUFDeEQsTUFBTUMsUUFBUWhjLE9BQU84YixTQUFTLENBQUNsYixDQUFDLEdBQUdnYixRQUFRNWIsT0FBTytiLE1BQU07UUFDeEQsS0FBSyxNQUFNLEdBQUcvYyxLQUFLLElBQUlDLFdBQVk7WUFDL0IsSUFBSSxDQUFDeWMsV0FBVzFjLE9BQU87Z0JBQ25CO1lBQ0o7WUFDQSxJQUFJaWQsZUFBZTtnQkFDZnRiLEdBQUczQixLQUFLSSxTQUFTLENBQUM0UixnQkFBZ0IsQ0FBQ3JRLENBQUMsR0FBR2tiO2dCQUN2Q2piLEdBQUc1QixLQUFLSSxTQUFTLENBQUM0UixnQkFBZ0IsQ0FBQ3BRLENBQUMsR0FBR29iO1lBQzNDO1lBQ0EsSUFBSXZULFlBQVk7Z0JBQ1p3VCxlQUFlamtCLDREQUFZQSxDQUFDaWtCLGNBQWN6VDtZQUM5QztZQUNBLE1BQU0sRUFBRS9MLFFBQVEsRUFBRXVVLGdCQUFnQixFQUFFLEdBQUcvWSxxRUFBcUJBLENBQUM7Z0JBQ3pEMlosUUFBUTVTLEtBQUtwQixFQUFFO2dCQUNmcWU7Z0JBQ0FoZDtnQkFDQXNjO2dCQUNBNVo7Z0JBQ0FvUjtZQUNKO1lBQ0EvVCxLQUFLdkMsUUFBUSxHQUFHQTtZQUNoQnVDLEtBQUtJLFNBQVMsQ0FBQzRSLGdCQUFnQixHQUFHQTtZQUNsQ3lLLFlBQVk1UixHQUFHLENBQUM3SyxLQUFLcEIsRUFBRSxFQUFFb0I7UUFDN0I7UUFDQXdjLG9CQUFvQkM7SUFDeEIsR0FBRyxFQUFFO0lBQ0wsT0FBT0g7QUFDWDtBQUVBLE1BQU1ZLDhCQUFnQnJtQixvREFBYUEsQ0FBQztBQUNwQyxNQUFNOEYsV0FBV3VnQixjQUFjdmdCLFFBQVE7QUFDdkN1Z0IsY0FBY0MsUUFBUTtBQUN0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkJDLEdBQ0QsTUFBTUMsWUFBWTtJQUNkLE1BQU14SyxTQUFTOWIsaURBQVVBLENBQUNvbUI7SUFDMUIsT0FBT3RLO0FBQ1g7QUFFQSxNQUFNeUssYUFBYSxDQUFDL2UsSUFBTztRQUN2QmdmLGdCQUFnQmhmLEVBQUVnZixjQUFjO1FBQ2hDdmEsZ0JBQWdCekUsRUFBRXlFLGNBQWM7UUFDaENwRSxNQUFNTCxFQUFFSyxJQUFJO0lBQ2hCO0FBQ0EsTUFBTTRlLHFCQUFxQixDQUFDM0ssUUFBUUksVUFBVXBJLE9BQVMsQ0FBQzRTO1FBQ3BELE1BQU0sRUFBRUMsNEJBQTRCQyxXQUFXLEVBQUVDLGNBQWMsRUFBRWhKLFVBQVUsRUFBRSxHQUFHNkk7UUFDaEYsTUFBTSxFQUFFSSxVQUFVLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFLEdBQUduSjtRQUMxQyxNQUFNb0osZUFBZUYsVUFBVWpMLFdBQVdBLFVBQVVpTCxVQUFVamYsT0FBT29VLFlBQVk2SyxVQUFValQsU0FBU0E7UUFDcEcsT0FBTztZQUNIb1QsZ0JBQWdCSixZQUFZaEwsV0FBV0EsVUFBVWdMLFlBQVloZixPQUFPb1UsWUFBWTRLLFlBQVloVCxTQUFTQTtZQUNyR21UO1lBQ0FFLGlCQUFpQlAsYUFBYTlLLFdBQVdBLFVBQVU4SyxhQUFhOWUsT0FBT29VLFlBQVkwSyxhQUFhOVMsU0FBU0E7WUFDekdzVCxxQkFBcUJQLG1CQUFtQnhrQiwwREFBY0EsQ0FBQ2dsQixNQUFNLEdBQ3ZEUCxZQUFZaFQsU0FBU0EsT0FDckJnSSxXQUFXZ0wsWUFBWWhMLFVBQVVJLGFBQWE0SyxZQUFZaGY7WUFDaEV3ZixxQkFBcUIsQ0FBQyxDQUFDUjtZQUN2QlMsMEJBQTBCLENBQUMsQ0FBQ1g7WUFDNUJZLE9BQU9QLGdCQUFnQkQ7UUFDM0I7SUFDSjtBQUNBLFNBQVNTLGdCQUFnQixFQUFFM1QsT0FBTyxRQUFRLEVBQUVuTixXQUFXdkUsb0RBQVFBLENBQUNzbEIsR0FBRyxFQUFFQyxpQkFBaUIsRUFBRUMsZ0JBQWdCLElBQUksRUFBRUMscUJBQXFCLElBQUksRUFBRUMsbUJBQW1CLElBQUksRUFBRWhnQixFQUFFLEVBQUVpZ0IsU0FBUyxFQUFFaGdCLFFBQVEsRUFBRUksU0FBUyxFQUFFNmYsV0FBVyxFQUFFQyxZQUFZLEVBQUUsR0FBRzdmLE1BQU0sRUFBRUMsR0FBRztJQUMzTyxNQUFNNlQsV0FBV3BVLE1BQU07SUFDdkIsTUFBTW9nQixXQUFXcFUsU0FBUztJQUMxQixNQUFNNU4sUUFBUUU7SUFDZCxNQUFNMFYsU0FBU3dLO0lBQ2YsTUFBTSxFQUFFRSxjQUFjLEVBQUV2YSxjQUFjLEVBQUVwRSxJQUFJLEVBQUUsR0FBRzlCLFNBQVN3Z0IsWUFBWTlnQixvREFBT0E7SUFDN0UsTUFBTSxFQUFFeWhCLGNBQWMsRUFBRUQsWUFBWSxFQUFFRSxlQUFlLEVBQUVDLG1CQUFtQixFQUFFRSxtQkFBbUIsRUFBRUMsd0JBQXdCLEVBQUVDLEtBQUssRUFBRyxHQUFHemhCLFNBQVMwZ0IsbUJBQW1CM0ssUUFBUUksVUFBVXBJLE9BQU9yTyxvREFBT0E7SUFDbE0sSUFBSSxDQUFDcVcsUUFBUTtRQUNUNVYsTUFBTUcsUUFBUSxHQUFHNFcsT0FBTyxHQUFHLE9BQU92Yyx5REFBYSxDQUFDLFdBQVc7SUFDL0Q7SUFDQSxNQUFNeW5CLG9CQUFvQixDQUFDamU7UUFDdkIsTUFBTSxFQUFFMlksa0JBQWtCLEVBQUVrRixXQUFXSyxlQUFlLEVBQUUzUSxlQUFlLEVBQUUsR0FBR3ZSLE1BQU1HLFFBQVE7UUFDMUYsTUFBTWdpQixhQUFhO1lBQ2YsR0FBR3hGLGtCQUFrQjtZQUNyQixHQUFHM1ksTUFBTTtRQUNiO1FBQ0EsSUFBSXVOLGlCQUFpQjtZQUNqQixNQUFNLEVBQUVyTixLQUFLLEVBQUVnQixRQUFRLEVBQUUsR0FBR2xGLE1BQU1HLFFBQVE7WUFDMUMrRSxTQUFTM0ksdURBQU9BLENBQUM0bEIsWUFBWWplO1FBQ2pDO1FBQ0FnZSxrQkFBa0JDO1FBQ2xCTixZQUFZTTtJQUNoQjtJQUNBLE1BQU1DLGdCQUFnQixDQUFDblo7UUFDbkIsSUFBSSxDQUFDMk0sUUFBUTtZQUNUO1FBQ0o7UUFDQSxNQUFNeU0sbUJBQW1Cam1CLDREQUFZQSxDQUFDNk0sTUFBTXNULFdBQVc7UUFDdkQsSUFBSW9GLHNCQUNDLHFCQUFxQjFZLE1BQU1rVCxNQUFNLEtBQUssS0FBTSxDQUFDa0csZ0JBQWUsR0FBSTtZQUNqRSxNQUFNQyxlQUFldGlCLE1BQU1HLFFBQVE7WUFDbkM5RCxvREFBUUEsQ0FBQytsQixhQUFhLENBQUNuWixNQUFNc1QsV0FBVyxFQUFFO2dCQUN0Q2dHLGVBQWV0WixNQUFNdVosYUFBYTtnQkFDbENDLGtCQUFrQkgsYUFBYUcsZ0JBQWdCO2dCQUMvQzlCLGdCQUFnQjJCLGFBQWEzQixjQUFjO2dCQUMzQytCLGtCQUFrQkosYUFBYUksZ0JBQWdCO2dCQUMvQ2hXLFNBQVM0VixhQUFhNVYsT0FBTztnQkFDN0J6SixZQUFZcWYsYUFBYXJmLFVBQVU7Z0JBQ25Dd1UsS0FBSzZLLGFBQWE3SyxHQUFHO2dCQUNyQnVLO2dCQUNBaE07Z0JBQ0FKO2dCQUNBK00sUUFBUUwsYUFBYTNnQixJQUFJO2dCQUN6QnpELE9BQU9va0IsYUFBYXBrQixLQUFLO2dCQUN6QjBrQixrQkFBa0JOLGFBQWFNLGdCQUFnQjtnQkFDL0NDLGdCQUFnQlAsYUFBYU8sY0FBYztnQkFDM0NDLGNBQWNSLGFBQWFRLFlBQVk7Z0JBQ3ZDQyxrQkFBa0JULGFBQWFTLGdCQUFnQjtnQkFDL0NsQixXQUFXSTtnQkFDWFIsbUJBQW1CQSxxQkFBcUJhLGFBQWFiLGlCQUFpQjtnQkFDdEV1QixjQUFjLElBQU1oakIsTUFBTUcsUUFBUSxHQUFHdUwsU0FBUztnQkFDOUN1WCxlQUFlLElBQU1qakIsTUFBTUcsUUFBUSxHQUFHd1gsVUFBVSxDQUFDaUosVUFBVTtnQkFDM0RzQyxjQUFjWixhQUFhWSxZQUFZO2dCQUN2Q0MsZUFBZWIsYUFBYWMsdUJBQXVCO1lBQ3ZEO1FBQ0o7UUFDQSxJQUFJZixrQkFBa0I7WUFDbEJQLGNBQWM3WTtRQUNsQixPQUNLO1lBQ0Q4WSxlQUFlOVk7UUFDbkI7SUFDSjtJQUNBLE1BQU13UyxVQUFVLENBQUN4UztRQUNiLE1BQU0sRUFBRW9hLG1CQUFtQixFQUFFQyxpQkFBaUIsRUFBRTdDLDBCQUEwQixFQUFFRSxjQUFjLEVBQUVjLG1CQUFtQjhCLHNCQUFzQixFQUFFOUwsR0FBRyxFQUFFOVYsTUFBTWdoQixNQUFNLEVBQUUxZixVQUFVLEVBQUUwVSxZQUFZNkwsZUFBZSxFQUFHLEdBQUd4akIsTUFBTUcsUUFBUTtRQUNyTixJQUFJLENBQUN5VixVQUFXLENBQUM2Syw4QkFBOEIsQ0FBQ2tCLG9CQUFxQjtZQUNqRTtRQUNKO1FBQ0EsSUFBSSxDQUFDbEIsNEJBQTRCO1lBQzdCNEMsc0JBQXNCcGEsTUFBTXNULFdBQVcsRUFBRTtnQkFBRTNHO2dCQUFRSTtnQkFBVXlOLFlBQVk3VjtZQUFLO1lBQzlFNU4sTUFBTUksUUFBUSxDQUFDO2dCQUFFcWdCLDRCQUE0QjtvQkFBRTdLO29CQUFRaEk7b0JBQU1oTSxJQUFJb1U7Z0JBQVM7WUFBRTtZQUM1RTtRQUNKO1FBQ0EsTUFBTTBOLE1BQU1wbkIsaUVBQWlCQSxDQUFDMk0sTUFBTXRHLE1BQU07UUFDMUMsTUFBTWdoQiwyQkFBMkJsQyxxQkFBcUI4QjtRQUN0RCxNQUFNLEVBQUU1TCxVQUFVLEVBQUVtSixPQUFPLEVBQUUsR0FBR3prQixvREFBUUEsQ0FBQ3lrQixPQUFPLENBQUM3WCxNQUFNc1QsV0FBVyxFQUFFO1lBQ2hFcUgsUUFBUTtnQkFDSmhPO2dCQUNBaFUsSUFBSW9VO2dCQUNKcEk7WUFDSjtZQUNBK1M7WUFDQWtELFlBQVlwRCwyQkFBMkI3SyxNQUFNO1lBQzdDa08sY0FBY3JELDJCQUEyQjdlLEVBQUUsSUFBSTtZQUMvQ21pQixVQUFVdEQsMkJBQTJCN1MsSUFBSTtZQUN6QzZULG1CQUFtQmtDO1lBQ25CaEI7WUFDQWU7WUFDQWpNO1lBQ0F4VTtRQUNKO1FBQ0EsSUFBSTZkLFdBQVduSixZQUFZO1lBQ3ZCc0ssa0JBQWtCdEs7UUFDdEI7UUFDQSxNQUFNcU0sa0JBQWtCQyxnQkFBZ0JUO1FBQ3hDLE9BQU9RLGdCQUFnQnBNLFVBQVU7UUFDakNvTSxnQkFBZ0JFLFVBQVUsR0FBR0YsZ0JBQWdCbkQsUUFBUSxHQUFHbUQsZ0JBQWdCbkQsUUFBUSxDQUFDcGdCLFFBQVEsR0FBRztRQUM1RjZpQixvQkFBb0JyYSxPQUFPK2E7UUFDM0Joa0IsTUFBTUksUUFBUSxDQUFDO1lBQUVxZ0IsNEJBQTRCO1FBQUs7SUFDdEQ7SUFDQSxPQUFRN21CLHNEQUFHQSxDQUFDLE9BQU87UUFBRSxpQkFBaUJvYztRQUFVLGVBQWVKO1FBQVEsa0JBQWtCblY7UUFBVSxXQUFXLENBQUMsRUFBRWtCLEtBQUssQ0FBQyxFQUFFaVUsT0FBTyxDQUFDLEVBQUVJLFNBQVMsQ0FBQyxFQUFFcEksS0FBSyxDQUFDO1FBQUUzTCxXQUFXMUgsb0RBQUVBLENBQUM7WUFDN0o7WUFDQSxDQUFDLG1CQUFtQixFQUFFa0csU0FBUyxDQUFDO1lBQ2hDO1lBQ0FzRjtZQUNBOUQ7WUFDQTtnQkFDSWtpQixRQUFRLENBQUNuQztnQkFDVHJmLFFBQVFxZjtnQkFDUm9DLGFBQWExQztnQkFDYjJDLGtCQUFrQjFDO2dCQUNsQjJDLGdCQUFnQjFDO2dCQUNoQjJDLGlCQUFpQnREO2dCQUNqQnVELGdCQUFnQnhEO2dCQUNoQnlELGNBQWMxRDtnQkFDZE87Z0JBQ0E7OztpQkFHQyxHQUNEb0QscUJBQXFCaEQsaUJBQ2hCLEVBQUNOLHVCQUF1QkYsbUJBQWtCLEtBQzFDRSxDQUFBQSx1QkFBdUJDLDJCQUEyQk8sbUJBQW1CRCxrQkFBaUI7WUFDL0Y7U0FDSDtRQUFHRyxhQUFhTTtRQUFlTCxjQUFjSztRQUFlM0csU0FBUzZFLGlCQUFpQjdFLFVBQVVyTjtRQUFXak0sS0FBS0E7UUFBSyxHQUFHRCxJQUFJO1FBQUVMLFVBQVVBO0lBQVM7QUFDMUo7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ0QsTUFBTThpQix1QkFBU3JxQiwyQ0FBSUEsQ0FBQ3VWLGdCQUFnQjBSO0FBRXBDLFNBQVNxRCxVQUFVLEVBQUVuUCxJQUFJLEVBQUVpTSxhQUFhLEVBQUVtRCxpQkFBaUIzb0Isb0RBQVFBLENBQUM0b0IsTUFBTSxFQUFFO0lBQ3hFLE9BQVFwckIsdURBQUlBLENBQUNDLHVEQUFRQSxFQUFFO1FBQUVrSSxVQUFVO1lBQUM0VCxNQUFNc1A7WUFBT25yQixzREFBR0EsQ0FBQytxQixRQUFRO2dCQUFFL1csTUFBTTtnQkFBVW5OLFVBQVVva0I7Z0JBQWdCbkQsZUFBZUE7WUFBYztTQUFHO0lBQUM7QUFDOUk7QUFFQSxTQUFTc0QsWUFBWSxFQUFFdlAsSUFBSSxFQUFFaU0sYUFBYSxFQUFFdUQsaUJBQWlCL29CLG9EQUFRQSxDQUFDc2xCLEdBQUcsRUFBRXFELGlCQUFpQjNvQixvREFBUUEsQ0FBQzRvQixNQUFNLEVBQUc7SUFDMUcsT0FBUXByQix1REFBSUEsQ0FBQ0MsdURBQVFBLEVBQUU7UUFBRWtJLFVBQVU7WUFBQ2pJLHNEQUFHQSxDQUFDK3FCLFFBQVE7Z0JBQUUvVyxNQUFNO2dCQUFVbk4sVUFBVXdrQjtnQkFBZ0J2RCxlQUFlQTtZQUFjO1lBQUlqTSxNQUFNc1A7WUFBT25yQixzREFBR0EsQ0FBQytxQixRQUFRO2dCQUFFL1csTUFBTTtnQkFBVW5OLFVBQVVva0I7Z0JBQWdCbkQsZUFBZUE7WUFBYztTQUFHO0lBQUM7QUFDdk87QUFFQSxTQUFTd0Q7SUFDTCxPQUFPO0FBQ1g7QUFFQSxTQUFTQyxXQUFXLEVBQUUxUCxJQUFJLEVBQUVpTSxhQUFhLEVBQUV1RCxpQkFBaUIvb0Isb0RBQVFBLENBQUNzbEIsR0FBRyxFQUFFO0lBQ3RFLE9BQVE5bkIsdURBQUlBLENBQUNDLHVEQUFRQSxFQUFFO1FBQUVrSSxVQUFVO1lBQUNqSSxzREFBR0EsQ0FBQytxQixRQUFRO2dCQUFFL1csTUFBTTtnQkFBVW5OLFVBQVV3a0I7Z0JBQWdCdkQsZUFBZUE7WUFBYztZQUFJak0sTUFBTXNQO1NBQU07SUFBQztBQUM5STtBQUVBLE1BQU1LLGdCQUFnQjtJQUNsQkMsU0FBUztRQUFFMWdCLEdBQUc7UUFBR0MsR0FBRyxDQUFDO0lBQUU7SUFDdkIwZ0IsV0FBVztRQUFFM2dCLEdBQUc7UUFBR0MsR0FBRztJQUFFO0lBQ3hCMmdCLFdBQVc7UUFBRTVnQixHQUFHLENBQUM7UUFBR0MsR0FBRztJQUFFO0lBQ3pCNGdCLFlBQVk7UUFBRTdnQixHQUFHO1FBQUdDLEdBQUc7SUFBRTtBQUM3QjtBQUNBLE1BQU02Z0IsbUJBQW1CO0lBQ3JCQyxPQUFPZDtJQUNQZSxTQUFTWDtJQUNUWSxRQUFRVDtJQUNSVSxPQUFPWDtBQUNYO0FBQ0EsU0FBU1ksNkJBQTZCOWlCLElBQUk7SUFDdEMsSUFBSUEsS0FBS0ksU0FBUyxDQUFDMmlCLFlBQVksS0FBSzNYLFdBQVc7UUFDM0MsT0FBTztZQUNIMU4sT0FBT3NDLEtBQUt0QyxLQUFLLElBQUlzQyxLQUFLZ2pCLFlBQVksSUFBSWhqQixLQUFLMUMsS0FBSyxFQUFFSTtZQUN0REMsUUFBUXFDLEtBQUtyQyxNQUFNLElBQUlxQyxLQUFLaWpCLGFBQWEsSUFBSWpqQixLQUFLMUMsS0FBSyxFQUFFSztRQUM3RDtJQUNKO0lBQ0EsT0FBTztRQUNIRCxPQUFPc0MsS0FBS3RDLEtBQUssSUFBSXNDLEtBQUsxQyxLQUFLLEVBQUVJO1FBQ2pDQyxRQUFRcUMsS0FBS3JDLE1BQU0sSUFBSXFDLEtBQUsxQyxLQUFLLEVBQUVLO0lBQ3ZDO0FBQ0o7QUFFQSxNQUFNdWxCLGFBQWEsQ0FBQzVrQjtJQUNoQixNQUFNLEVBQUVaLEtBQUssRUFBRUMsTUFBTSxFQUFFZ0UsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR3BJLHNFQUFzQkEsQ0FBQzhFLEVBQUUyQixVQUFVLEVBQUU7UUFDakV1RixRQUFRLENBQUN4RixPQUFTLENBQUMsQ0FBQ0EsS0FBS0UsUUFBUTtJQUNyQztJQUNBLE9BQU87UUFDSHhDLE9BQU9qRSx5REFBU0EsQ0FBQ2lFLFNBQVNBLFFBQVE7UUFDbENDLFFBQVFsRSx5REFBU0EsQ0FBQ2tFLFVBQVVBLFNBQVM7UUFDckM2VyxxQkFBcUJsVyxFQUFFa1csbUJBQW1CO1FBQzFDMk8saUJBQWlCLENBQUMsVUFBVSxFQUFFN2tCLEVBQUVvSyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRXBLLEVBQUVvSyxTQUFTLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRXBLLEVBQUVvSyxTQUFTLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRS9HLEVBQUUsR0FBRyxFQUFFQyxFQUFFLEdBQUcsQ0FBQztJQUMzSDtBQUNKO0FBQ0EsU0FBU3doQixlQUFlLEVBQUVDLHNCQUFzQixFQUFFdGdCLGNBQWMsRUFBRWhFLG1CQUFtQixFQUFHO0lBQ3BGLE1BQU0vQixRQUFRRTtJQUNkLE1BQU0sRUFBRVEsS0FBSyxFQUFFQyxNQUFNLEVBQUV3bEIsZUFBZSxFQUFFM08sbUJBQW1CLEVBQUUsR0FBRzNYLFNBQVNxbUIsWUFBWTNtQixvREFBT0E7SUFDNUYsTUFBTStmLG9CQUFvQkQ7SUFDMUIsTUFBTWxCLFVBQVVqa0IsNkNBQU1BLENBQUM7SUFDdkJELGdEQUFTQSxDQUFDO1FBQ04sSUFBSSxDQUFDOEgscUJBQXFCO1lBQ3RCb2MsUUFBUTlYLE9BQU8sRUFBRWlnQixNQUFNO2dCQUNuQkMsZUFBZTtZQUNuQjtRQUNKO0lBQ0osR0FBRztRQUFDeGtCO0tBQW9CO0lBQ3hCd2MsUUFBUTtRQUNKSjtJQUNKO0lBQ0EsSUFBSTNHLHVCQUF1QixDQUFDOVcsU0FBUyxDQUFDQyxRQUFRO1FBQzFDLE9BQU87SUFDWDtJQUNBLE1BQU1nYixnQkFBZ0IwSyx5QkFDaEIsQ0FBQ3BkO1FBQ0MsTUFBTW5HLGdCQUFnQjlDLE1BQU1HLFFBQVEsR0FBRzhELEtBQUssQ0FBQ3VFLE1BQU0sQ0FBQyxDQUFDK0gsSUFBTUEsRUFBRXJOLFFBQVE7UUFDckVtakIsdUJBQXVCcGQsT0FBT25HO0lBQ2xDLElBQ0VzTDtJQUNOLE1BQU1vWSxZQUFZLENBQUN2ZDtRQUNmLElBQUl3ZCxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDeEIsZUFBZW5jLE1BQU1rQixHQUFHLEdBQUc7WUFDaEVsQixNQUFNYyxjQUFjO1lBQ3BCdVYsa0JBQWtCO2dCQUNkUSxXQUFXc0YsYUFBYSxDQUFDbmMsTUFBTWtCLEdBQUcsQ0FBQztnQkFDbkM0VixRQUFROVcsTUFBTUcsUUFBUSxHQUFHLElBQUk7WUFDakM7UUFDSjtJQUNKO0lBQ0EsT0FBUXhQLHNEQUFHQSxDQUFDLE9BQU87UUFBRXFJLFdBQVcxSCxvREFBRUEsQ0FBQztZQUFDO1lBQThCO1lBQXlCd0w7U0FBZTtRQUFHekYsT0FBTztZQUM1R29MLFdBQVd5YTtRQUNmO1FBQUd0a0IsVUFBVWpJLHNEQUFHQSxDQUFDLE9BQU87WUFBRXVJLEtBQUtnYztZQUFTbGMsV0FBVztZQUFtQzBaLGVBQWVBO1lBQWVrTCxVQUFVOWtCLHNCQUFzQnFNLFlBQVksQ0FBQztZQUFHb1ksV0FBV3prQixzQkFBc0JxTSxZQUFZb1k7WUFBV2xtQixPQUFPO2dCQUMzTkk7Z0JBQ0FDO1lBQ0o7UUFBRTtJQUFHO0FBQ2pCO0FBRUEsTUFBTW1tQixNQUFNLE1BQWtCLEdBQWNsZ0IsQ0FBTUEsR0FBR3dIO0FBQ3JELE1BQU0yWSxhQUFhLENBQUN6bEI7SUFDaEIsT0FBTztRQUFFb1Ysc0JBQXNCcFYsRUFBRW9WLG9CQUFvQjtRQUFFYyxxQkFBcUJsVyxFQUFFa1csbUJBQW1CO0lBQUM7QUFDdEc7QUFDQSxTQUFTd1Asc0JBQXNCLEVBQUVubEIsUUFBUSxFQUFFaVosV0FBVyxFQUFFRSxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFQyxnQkFBZ0IsRUFBRXBELGlCQUFpQixFQUFFaUQsWUFBWSxFQUFFbkMsaUJBQWlCLEVBQUV0QyxhQUFhLEVBQUUyUSxnQkFBZ0IsRUFBRXBPLGVBQWUsRUFBRTZCLGFBQWEsRUFBRUUsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRXRFLHFCQUFxQixFQUFFMlEsb0JBQW9CLEVBQUUzTyxxQkFBcUIsRUFBRXpTLGtCQUFrQixFQUFFaVMsWUFBWSxFQUFFQyxXQUFXLEVBQUVDLGFBQWFrUCxZQUFZLEVBQUVqUCxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFRSxpQkFBaUIsRUFBRUMsV0FBVzhPLFVBQVUsRUFBRTFpQixlQUFlLEVBQUVnQixlQUFlLEVBQUVFLE9BQU8sRUFBRUMsT0FBTyxFQUFFMlMsZ0JBQWdCLEVBQUU2TixzQkFBc0IsRUFBRTVOLGdCQUFnQixFQUFFMVMsY0FBYyxFQUFFaEUsbUJBQW1CLEVBQUUyVyxnQkFBZ0IsRUFBRUMsb0JBQW9CLEVBQUc7SUFDenBCLE1BQU0sRUFBRWpDLG9CQUFvQixFQUFFYyxtQkFBbUIsRUFBRSxHQUFHM1gsU0FBU2tuQixZQUFZeG5CLG9EQUFPQTtJQUNsRixNQUFNa2Isc0JBQXNCaFQsWUFBWXdmLGtCQUFrQjtRQUFFdGtCLFFBQVFta0I7SUFBSTtJQUN4RSxNQUFNTywwQkFBMEI1ZixZQUFZeWYsc0JBQXNCO1FBQUV2a0IsUUFBUW1rQjtJQUFJO0lBQ2hGLE1BQU14TyxZQUFZK08sMkJBQTJCRDtJQUM3QyxNQUFNblAsY0FBY29QLDJCQUEyQkY7SUFDL0MsTUFBTUcsbUJBQW1Cek8sbUJBQW1CUCxjQUFjO0lBQzFELE1BQU1rQyxjQUFjQyx1QkFBdUJqRCx1QkFBdUI4UDtJQUNsRWpSLG9CQUFvQjtRQUFFQztRQUFlQztJQUFzQjtJQUMzRCxPQUFRM2Msc0RBQUdBLENBQUNpZSxVQUFVO1FBQUVDLG1CQUFtQkE7UUFBbUJoUyxvQkFBb0JBO1FBQW9CaVMsY0FBY0E7UUFBY0MsYUFBYUE7UUFBYUMsYUFBYUE7UUFBYUMsa0JBQWtCQTtRQUFrQkMsaUJBQWlCQTtRQUFpQkUsbUJBQW1CQTtRQUFtQkMsV0FBVyxDQUFDbUMsdUJBQXVCbkM7UUFBVzVULGlCQUFpQkE7UUFBaUJnQixpQkFBaUJBO1FBQWlCRSxTQUFTQTtRQUFTQyxTQUFTQTtRQUFTMFMsdUJBQXVCQTtRQUF1QkMsa0JBQWtCQTtRQUFrQkMsa0JBQWtCQTtRQUFrQjFTLGdCQUFnQkE7UUFBZ0IyUyxrQkFBa0JBO1FBQWtCQyxzQkFBc0JBO1FBQXNCQyxtQkFBbUJBO1FBQW1CQyxpQkFBaUJ5TztRQUFrQnpsQixVQUFVbkksdURBQUlBLENBQUM2Z0IsTUFBTTtZQUFFSyxrQkFBa0JBO1lBQWtCQyxnQkFBZ0JBO1lBQWdCQyxhQUFhQTtZQUFhRSxrQkFBa0JBO1lBQWtCQyxpQkFBaUJBO1lBQWlCQyxrQkFBa0JBO1lBQWtCcEQsbUJBQW1CQTtZQUFtQmlELGNBQWNBO1lBQWN6QyxXQUFXQTtZQUFXa0MsYUFBYSxDQUFDLENBQUNBO1lBQWFFLGVBQWVBO1lBQWVELHFCQUFxQkE7WUFBcUI3QixtQkFBbUJBO1lBQW1CQyxpQkFBaUJ5TztZQUFrQnpsQixVQUFVO2dCQUFDQTtnQkFBVTZVLHdCQUF5QjljLHNEQUFHQSxDQUFDd3NCLGdCQUFnQjtvQkFBRUMsd0JBQXdCQTtvQkFBd0J0Z0IsZ0JBQWdCQTtvQkFBZ0JoRSxxQkFBcUJBO2dCQUFvQjthQUFJO1FBQUM7SUFBRztBQUNwNUM7QUFDQWlsQixzQkFBc0Ixa0IsV0FBVyxHQUFHO0FBQ3BDLE1BQU1pbEIsNkJBQWVqdEIsMkNBQUlBLENBQUMwc0I7QUFFMUIsTUFBTVEsYUFBYSxDQUFDQyxvQkFBc0IsQ0FBQ25tQjtRQUN2QyxPQUFPbW1CLG9CQUNENXJCLDhEQUFjQSxDQUFDeUYsRUFBRTJCLFVBQVUsRUFBRTtZQUFFMEIsR0FBRztZQUFHQyxHQUFHO1lBQUdsRSxPQUFPWSxFQUFFWixLQUFLO1lBQUVDLFFBQVFXLEVBQUVYLE1BQU07UUFBQyxHQUFHVyxFQUFFb0ssU0FBUyxFQUFFLE1BQU03SCxHQUFHLENBQUMsQ0FBQ2IsT0FBU0EsS0FBS3BCLEVBQUUsSUFDdkh5RyxNQUFNd04sSUFBSSxDQUFDdlUsRUFBRTJCLFVBQVUsQ0FBQ3NGLElBQUk7SUFDdEM7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTbWYsa0JBQWtCRCxpQkFBaUI7SUFDeEMsTUFBTUUsVUFBVTluQixTQUFTeEYsa0RBQVdBLENBQUNtdEIsV0FBV0Msb0JBQW9CO1FBQUNBO0tBQWtCLEdBQUdsb0Isb0RBQU9BO0lBQ2pHLE9BQU9vb0I7QUFDWDtBQUVBLE1BQU1DLGFBQWEsQ0FBQ3RtQixJQUFNQSxFQUFFeEQsbUJBQW1CO0FBQy9DLFNBQVMrcEI7SUFDTCxNQUFNL3BCLHNCQUFzQitCLFNBQVMrbkI7SUFDckMsTUFBTSxDQUFDNVEsZUFBZSxHQUFHN2MsK0NBQVFBLENBQUM7UUFDOUIsSUFBSSxPQUFPOGMsbUJBQW1CLGFBQWE7WUFDdkMsT0FBTztRQUNYO1FBQ0EsT0FBTyxJQUFJQSxlQUFlLENBQUMzSDtZQUN2QixNQUFNd1ksVUFBVSxJQUFJcmE7WUFDcEI2QixRQUFRbEwsT0FBTyxDQUFDLENBQUMyakI7Z0JBQ2IsTUFBTW5tQixLQUFLbW1CLE1BQU1wbEIsTUFBTSxDQUFDcWxCLFlBQVksQ0FBQztnQkFDckNGLFFBQVFqYSxHQUFHLENBQUNqTSxJQUFJO29CQUNaQTtvQkFDQXFtQixhQUFhRixNQUFNcGxCLE1BQU07b0JBQ3pCdWxCLE9BQU87Z0JBQ1g7WUFDSjtZQUNBcHFCLG9CQUFvQmdxQjtRQUN4QjtJQUNKO0lBQ0E3dEIsZ0RBQVNBLENBQUM7UUFDTixPQUFPO1lBQ0grYyxnQkFBZ0JtUjtRQUNwQjtJQUNKLEdBQUc7UUFBQ25SO0tBQWU7SUFDbkIsT0FBT0E7QUFDWDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU29SLGdCQUFnQixFQUFFcGxCLElBQUksRUFBRXFsQixRQUFRLEVBQUVDLGFBQWEsRUFBRXRSLGNBQWMsRUFBRztJQUN2RSxNQUFNaFgsUUFBUUU7SUFDZCxNQUFNaWUsVUFBVWprQiw2Q0FBTUEsQ0FBQztJQUN2QixNQUFNcXVCLGVBQWVydUIsNkNBQU1BLENBQUM7SUFDNUIsTUFBTXN1QixxQkFBcUJ0dUIsNkNBQU1BLENBQUM4SSxLQUFLNmhCLGNBQWM7SUFDckQsTUFBTTRELHFCQUFxQnZ1Qiw2Q0FBTUEsQ0FBQzhJLEtBQUtpaUIsY0FBYztJQUNyRCxNQUFNeUQsV0FBV3h1Qiw2Q0FBTUEsQ0FBQ211QjtJQUN4QixNQUFNTSxnQkFBZ0JMLGlCQUFpQixDQUFDLENBQUN0bEIsS0FBS0ksU0FBUyxDQUFDMmlCLFlBQVk7SUFDcEU5ckIsZ0RBQVNBLENBQUM7UUFDTixJQUFJa2tCLFFBQVE5WCxPQUFPLElBQUksQ0FBQ3JELEtBQUs0bEIsTUFBTSxJQUFLLEVBQUNELGlCQUFpQkosYUFBYWxpQixPQUFPLEtBQUs4WCxRQUFROVgsT0FBTyxHQUFHO1lBQ2pHLElBQUlraUIsYUFBYWxpQixPQUFPLEVBQUU7Z0JBQ3RCMlEsZ0JBQWdCRyxVQUFVb1IsYUFBYWxpQixPQUFPO1lBQ2xEO1lBQ0EyUSxnQkFBZ0JFLFFBQVFpSCxRQUFROVgsT0FBTztZQUN2Q2tpQixhQUFhbGlCLE9BQU8sR0FBRzhYLFFBQVE5WCxPQUFPO1FBQzFDO0lBQ0osR0FBRztRQUFDc2lCO1FBQWUzbEIsS0FBSzRsQixNQUFNO0tBQUM7SUFDL0IzdUIsZ0RBQVNBLENBQUM7UUFDTixPQUFPO1lBQ0gsSUFBSXN1QixhQUFhbGlCLE9BQU8sRUFBRTtnQkFDdEIyUSxnQkFBZ0JHLFVBQVVvUixhQUFhbGlCLE9BQU87Z0JBQzlDa2lCLGFBQWFsaUIsT0FBTyxHQUFHO1lBQzNCO1FBQ0o7SUFDSixHQUFHLEVBQUU7SUFDTHBNLGdEQUFTQSxDQUFDO1FBQ04sSUFBSWtrQixRQUFROVgsT0FBTyxFQUFFO1lBQ2pCOzs7YUFHQyxHQUNELE1BQU13aUIsY0FBY0gsU0FBU3JpQixPQUFPLEtBQUtnaUI7WUFDekMsTUFBTVMsbUJBQW1CTixtQkFBbUJuaUIsT0FBTyxLQUFLckQsS0FBSzZoQixjQUFjO1lBQzNFLE1BQU1rRSxtQkFBbUJOLG1CQUFtQnBpQixPQUFPLEtBQUtyRCxLQUFLaWlCLGNBQWM7WUFDM0UsSUFBSTRELGVBQWVDLG9CQUFvQkMsa0JBQWtCO2dCQUNyREwsU0FBU3JpQixPQUFPLEdBQUdnaUI7Z0JBQ25CRyxtQkFBbUJuaUIsT0FBTyxHQUFHckQsS0FBSzZoQixjQUFjO2dCQUNoRDRELG1CQUFtQnBpQixPQUFPLEdBQUdyRCxLQUFLaWlCLGNBQWM7Z0JBQ2hEamxCLE1BQ0tHLFFBQVEsR0FDUnJDLG1CQUFtQixDQUFDLElBQUkyUCxJQUFJO29CQUFDO3dCQUFDekssS0FBS3BCLEVBQUU7d0JBQUU7NEJBQUVBLElBQUlvQixLQUFLcEIsRUFBRTs0QkFBRXFtQixhQUFhOUosUUFBUTlYLE9BQU87NEJBQUU2aEIsT0FBTzt3QkFBSztxQkFBRTtpQkFBQztZQUM1RztRQUNKO0lBQ0osR0FBRztRQUFDbGxCLEtBQUtwQixFQUFFO1FBQUV5bUI7UUFBVXJsQixLQUFLNmhCLGNBQWM7UUFBRTdoQixLQUFLaWlCLGNBQWM7S0FBQztJQUNoRSxPQUFPOUc7QUFDWDtBQUVBLFNBQVM2SyxZQUFZLEVBQUVwbkIsRUFBRSxFQUFFNlosT0FBTyxFQUFFd04sWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRXhOLGFBQWEsRUFBRXlOLGFBQWEsRUFBRWhLLGNBQWMsRUFBRXRaLGtCQUFrQixFQUFFdWpCLGdCQUFnQixFQUFFQyxjQUFjLEVBQUV0UyxjQUFjLEVBQUV5SCxlQUFlLEVBQUUxWSxjQUFjLEVBQUVoRSxtQkFBbUIsRUFBRUosSUFBSSxFQUFFNG5CLFNBQVMsRUFBRTNLLGlCQUFpQixFQUFFN0gsT0FBTyxFQUFHO0lBQ2pTLE1BQU0sRUFBRS9ULElBQUksRUFBRUksU0FBUyxFQUFFb21CLFFBQVEsRUFBRSxHQUFHM3BCLFNBQVMsQ0FBQ3lCO1FBQzVDLE1BQU0wQixPQUFPMUIsRUFBRTJCLFVBQVUsQ0FBQzhLLEdBQUcsQ0FBQ25NO1FBQzlCLE1BQU00bkIsV0FBV2xvQixFQUFFbW9CLFlBQVksQ0FBQzllLEdBQUcsQ0FBQy9JO1FBQ3BDLE9BQU87WUFDSG9CO1lBQ0FJLFdBQVdKLEtBQUtJLFNBQVM7WUFDekJvbUI7UUFDSjtJQUNKLEdBQUdqcUIsb0RBQU9BO0lBQ1YsSUFBSThvQixXQUFXcmxCLEtBQUs0SyxJQUFJLElBQUk7SUFDNUIsSUFBSThiLGdCQUFnQkgsV0FBVyxDQUFDbEIsU0FBUyxJQUFJNUMsZ0JBQWdCLENBQUM0QyxTQUFTO0lBQ3ZFLElBQUlxQixrQkFBa0J0YixXQUFXO1FBQzdCMkksVUFBVSxPQUFPdmMseURBQWEsQ0FBQyxXQUFXLENBQUM2dEI7UUFDM0NBLFdBQVc7UUFDWHFCLGdCQUFnQkgsV0FBVyxDQUFDLFVBQVUsSUFBSTlELGlCQUFpQkUsT0FBTztJQUN0RTtJQUNBLE1BQU1nRSxjQUFjLENBQUMsQ0FBRTNtQixDQUFBQSxLQUFLNmEsU0FBUyxJQUFLdUIsa0JBQWtCLE9BQU9wYyxLQUFLNmEsU0FBUyxLQUFLLFdBQVc7SUFDakcsTUFBTWMsZUFBZSxDQUFDLENBQUUzYixDQUFBQSxLQUFLd2EsVUFBVSxJQUFLMVgsc0JBQXNCLE9BQU85QyxLQUFLd2EsVUFBVSxLQUFLLFdBQVc7SUFDeEcsTUFBTWtFLGdCQUFnQixDQUFDLENBQUUxZSxDQUFBQSxLQUFLb2hCLFdBQVcsSUFBS2lGLG9CQUFvQixPQUFPcm1CLEtBQUtvaEIsV0FBVyxLQUFLLFdBQVc7SUFDekcsTUFBTXdGLGNBQWMsQ0FBQyxDQUFFNW1CLENBQUFBLEtBQUs2bUIsU0FBUyxJQUFLUCxrQkFBa0IsT0FBT3RtQixLQUFLNm1CLFNBQVMsS0FBSyxXQUFXO0lBQ2pHLE1BQU03cEIsUUFBUUU7SUFDZCxNQUFNb29CLGdCQUFnQjVyQixpRUFBaUJBLENBQUNzRztJQUN4QyxNQUFNbWIsVUFBVWlLLGdCQUFnQjtRQUFFcGxCO1FBQU1xbEI7UUFBVUM7UUFBZXRSO0lBQWU7SUFDaEYsTUFBTTFJLFdBQVdpUSxRQUFRO1FBQ3JCSjtRQUNBSyxVQUFVeGIsS0FBSzRsQixNQUFNLElBQUksQ0FBQ2U7UUFDMUJsTDtRQUNBQyxnQkFBZ0IxYixLQUFLOG1CLFVBQVU7UUFDL0JsVSxRQUFRaFU7UUFDUitjO1FBQ0FDO0lBQ0o7SUFDQSxNQUFNVSxvQkFBb0JEO0lBQzFCLElBQUlyYyxLQUFLNGxCLE1BQU0sRUFBRTtRQUNiLE9BQU87SUFDWDtJQUNBLE1BQU1tQixpQkFBaUJwdEIsaUVBQWlCQSxDQUFDcUc7SUFDekMsTUFBTWduQixtQkFBbUJsRSw2QkFBNkI5aUI7SUFDdEQsTUFBTWluQixtQkFBbUJ0TCxnQkFBZ0JnTCxlQUFlbE8sV0FBV3dOLGdCQUFnQkMsZUFBZUM7SUFDbEcsTUFBTWUsc0JBQXNCakIsZUFDdEIsQ0FBQ2hnQixRQUFVZ2dCLGFBQWFoZ0IsT0FBTztZQUFFLEdBQUc3RixVQUFVQyxRQUFRO1FBQUMsS0FDdkQrSztJQUNOLE1BQU0rYixxQkFBcUJqQixjQUNyQixDQUFDamdCLFFBQVVpZ0IsWUFBWWpnQixPQUFPO1lBQUUsR0FBRzdGLFVBQVVDLFFBQVE7UUFBQyxLQUN0RCtLO0lBQ04sTUFBTWdjLHNCQUFzQmpCLGVBQ3RCLENBQUNsZ0IsUUFBVWtnQixhQUFhbGdCLE9BQU87WUFBRSxHQUFHN0YsVUFBVUMsUUFBUTtRQUFDLEtBQ3ZEK0s7SUFDTixNQUFNaWMsdUJBQXVCMU8sZ0JBQ3ZCLENBQUMxUyxRQUFVMFMsY0FBYzFTLE9BQU87WUFBRSxHQUFHN0YsVUFBVUMsUUFBUTtRQUFDLEtBQ3hEK0s7SUFDTixNQUFNa2MsdUJBQXVCbEIsZ0JBQ3ZCLENBQUNuZ0IsUUFBVW1nQixjQUFjbmdCLE9BQU87WUFBRSxHQUFHN0YsVUFBVUMsUUFBUTtRQUFDLEtBQ3hEK0s7SUFDTixNQUFNbWMsc0JBQXNCLENBQUN0aEI7UUFDekIsTUFBTSxFQUFFdWhCLGlCQUFpQixFQUFFQyxpQkFBaUIsRUFBRSxHQUFHenFCLE1BQU1HLFFBQVE7UUFDL0QsSUFBSXdlLGdCQUFpQixFQUFDNkwscUJBQXFCLENBQUNiLGVBQWVjLG9CQUFvQixJQUFJO1lBQy9FOzs7YUFHQyxHQUNEeE0sZ0JBQWdCO2dCQUNacmM7Z0JBQ0E1QjtnQkFDQW1lO1lBQ0o7UUFDSjtRQUNBLElBQUkxQyxTQUFTO1lBQ1RBLFFBQVF4UyxPQUFPO2dCQUFFLEdBQUc3RixVQUFVQyxRQUFRO1lBQUM7UUFDM0M7SUFDSjtJQUNBLE1BQU1takIsWUFBWSxDQUFDdmQ7UUFDZixJQUFJdE8sOERBQWNBLENBQUNzTyxNQUFNc1QsV0FBVyxLQUFLeGEscUJBQXFCO1lBQzFEO1FBQ0o7UUFDQSxJQUFJbkYsZ0VBQW9CQSxDQUFDaU8sUUFBUSxDQUFDNUIsTUFBTWtCLEdBQUcsS0FBS3dVLGNBQWM7WUFDMUQsTUFBTVQsV0FBV2pWLE1BQU1rQixHQUFHLEtBQUs7WUFDL0I4VCxnQkFBZ0I7Z0JBQ1pyYztnQkFDQTVCO2dCQUNBa2U7Z0JBQ0FDO1lBQ0o7UUFDSixPQUNLLElBQUl3TCxlQUFlM21CLEtBQUtFLFFBQVEsSUFBSXVqQixPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDeEIsZUFBZW5jLE1BQU1rQixHQUFHLEdBQUc7WUFDckcsMkVBQTJFO1lBQzNFbEIsTUFBTWMsY0FBYztZQUNwQixNQUFNLEVBQUV0SSxlQUFlLEVBQUUsR0FBR3pCLE1BQU1HLFFBQVE7WUFDMUNILE1BQU1JLFFBQVEsQ0FBQztnQkFDWG1CLGlCQUFpQkUsZUFBZSxDQUFDLHVDQUF1QyxDQUFDO29CQUNyRXFlLFdBQVc3VyxNQUFNa0IsR0FBRyxDQUFDekIsT0FBTyxDQUFDLFNBQVMsSUFBSWdpQixXQUFXO29CQUNyRC9sQixHQUFHLENBQUMsQ0FBQ3ZCLFVBQVU0UixnQkFBZ0IsQ0FBQ3JRLENBQUM7b0JBQ2pDQyxHQUFHLENBQUMsQ0FBQ3hCLFVBQVU0UixnQkFBZ0IsQ0FBQ3BRLENBQUM7Z0JBQ3JDO1lBQ0o7WUFDQTBhLGtCQUFrQjtnQkFDZFEsV0FBV3NGLGFBQWEsQ0FBQ25jLE1BQU1rQixHQUFHLENBQUM7Z0JBQ25DNFYsUUFBUTlXLE1BQU1HLFFBQVEsR0FBRyxJQUFJO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBLE1BQU11aEIsVUFBVTtRQUNaLElBQUk1b0IsdUJBQXVCLENBQUNvYyxRQUFROVgsT0FBTyxFQUFFZSxRQUFRLG1CQUFtQjtZQUNwRTtRQUNKO1FBQ0EsTUFBTSxFQUFFc0UsU0FBUyxFQUFFaEwsS0FBSyxFQUFFQyxNQUFNLEVBQUVpcUIsa0JBQWtCLEVBQUUzZSxTQUFTLEVBQUUsR0FBR2pNLE1BQU1HLFFBQVE7UUFDbEYsSUFBSSxDQUFDeXFCLG9CQUFvQjtZQUNyQjtRQUNKO1FBQ0EsTUFBTUMsaUJBQWlCaHZCLDhEQUFjQSxDQUFDLElBQUk0UixJQUFJO1lBQUM7Z0JBQUM3TDtnQkFBSW9CO2FBQUs7U0FBQyxHQUFHO1lBQUUyQixHQUFHO1lBQUdDLEdBQUc7WUFBR2xFO1lBQU9DO1FBQU8sR0FBRytLLFdBQVcsTUFBTXBCLE1BQU0sR0FBRztRQUN0SCxJQUFJLENBQUN1Z0IsZ0JBQWdCO1lBQ2pCNWUsVUFBVWpKLEtBQUt2QyxRQUFRLENBQUNrRSxDQUFDLEdBQUdvbEIsZUFBZXJwQixLQUFLLEdBQUcsR0FBR3NDLEtBQUt2QyxRQUFRLENBQUNtRSxDQUFDLEdBQUdtbEIsZUFBZXBwQixNQUFNLEdBQUcsR0FBRztnQkFDL0ZrRSxNQUFNNkcsU0FBUyxDQUFDLEVBQUU7WUFDdEI7UUFDSjtJQUNKO0lBQ0EsT0FBUTlSLHNEQUFHQSxDQUFDLE9BQU87UUFBRXFJLFdBQVcxSCxvREFBRUEsQ0FBQztZQUMzQjtZQUNBLENBQUMsaUJBQWlCLEVBQUU4dEIsU0FBUyxDQUFDO1lBQzlCO2dCQUNJLDBEQUEwRDtnQkFDMUQsQ0FBQ3RpQixlQUFlLEVBQUU0akI7WUFDdEI7WUFDQTNtQixLQUFLZixTQUFTO1lBQ2Q7Z0JBQ0lpQixVQUFVRixLQUFLRSxRQUFRO2dCQUN2QnNhLFlBQVltQjtnQkFDWm1NLFFBQVF0QjtnQkFDUjNMLFdBQVc4TDtnQkFDWHJiO1lBQ0o7U0FDSDtRQUFHbk0sS0FBS2djO1FBQVM3ZCxPQUFPO1lBQ3JCeXFCLFFBQVEzbkIsVUFBVTRuQixDQUFDO1lBQ25CdGYsV0FBVyxDQUFDLFVBQVUsRUFBRXRJLFVBQVU0UixnQkFBZ0IsQ0FBQ3JRLENBQUMsQ0FBQyxHQUFHLEVBQUV2QixVQUFVNFIsZ0JBQWdCLENBQUNwUSxDQUFDLENBQUMsR0FBRyxDQUFDO1lBQzNGcW1CLGVBQWVoQixtQkFBbUIsUUFBUTtZQUMxQ2lCLFlBQVk1QyxnQkFBZ0IsWUFBWTtZQUN4QyxHQUFHdGxCLEtBQUsxQyxLQUFLO1lBQ2IsR0FBRzBwQixnQkFBZ0I7UUFDdkI7UUFBRyxXQUFXcG9CO1FBQUksZUFBZSxDQUFDLFNBQVMsRUFBRUEsR0FBRyxDQUFDO1FBQUVxbkIsY0FBY2lCO1FBQXFCaEIsYUFBYWlCO1FBQW9CaEIsY0FBY2lCO1FBQXFCek8sZUFBZTBPO1FBQXNCNU8sU0FBUzhPO1FBQXFCbkIsZUFBZWtCO1FBQXNCOUQsV0FBV29ELGNBQWNwRCxZQUFZcFk7UUFBV3lZLFVBQVUrQyxjQUFjLElBQUl4YjtRQUFXdWMsU0FBU2YsY0FBY2UsVUFBVXZjO1FBQVcrYyxNQUFNbm9CLEtBQUtvb0IsUUFBUSxJQUFLeEIsQ0FBQUEsY0FBYyxVQUFVeGIsU0FBUTtRQUFJLHdCQUF3QjtRQUFRLG9CQUFvQnJNLHNCQUFzQnFNLFlBQVksQ0FBQyxFQUFFbE4sbUJBQW1CLENBQUMsRUFBRVMsS0FBSyxDQUFDO1FBQUUsY0FBY3FCLEtBQUtxb0IsU0FBUztRQUFFLEdBQUdyb0IsS0FBS3NvQixhQUFhO1FBQUV6cEIsVUFBVWpJLHNEQUFHQSxDQUFDK0YsVUFBVTtZQUFFK1IsT0FBTzlQO1lBQUlDLFVBQVVqSSxzREFBR0EsQ0FBQzh2QixlQUFlO2dCQUFFOW5CLElBQUlBO2dCQUFJNlQsTUFBTXpTLEtBQUt5UyxJQUFJO2dCQUFFN0gsTUFBTXlhO2dCQUFVa0QsbUJBQW1Cbm9CLFVBQVU0UixnQkFBZ0IsQ0FBQ3JRLENBQUM7Z0JBQUU2bUIsbUJBQW1CcG9CLFVBQVU0UixnQkFBZ0IsQ0FBQ3BRLENBQUM7Z0JBQUUxQixVQUFVRixLQUFLRSxRQUFRLElBQUk7Z0JBQU9zYSxZQUFZbUI7Z0JBQWNkLFdBQVc4TDtnQkFBYThCLFdBQVd6b0IsS0FBS3lvQixTQUFTLElBQUk7Z0JBQU0vSixlQUFlQTtnQkFBZW1ELGdCQUFnQjdoQixLQUFLNmhCLGNBQWM7Z0JBQUVJLGdCQUFnQmppQixLQUFLaWlCLGNBQWM7Z0JBQUUzVyxVQUFVQTtnQkFBVXdiLFlBQVk5bUIsS0FBSzhtQixVQUFVO2dCQUFFaUIsUUFBUTNuQixVQUFVNG5CLENBQUM7Z0JBQUUzWSxVQUFVclAsS0FBS3FQLFFBQVE7Z0JBQUUsR0FBRzBYLGNBQWM7WUFBQztRQUFHO0lBQUc7QUFDMXBDO0FBQ0EsSUFBSTJCLDhCQUFnQnB4QiwyQ0FBSUEsQ0FBQzB1QjtBQUV6QixNQUFNMkMsYUFBYSxDQUFDcnFCLElBQU87UUFDdkI4ZCxnQkFBZ0I5ZCxFQUFFOGQsY0FBYztRQUNoQ2lLLGtCQUFrQi9uQixFQUFFK25CLGdCQUFnQjtRQUNwQ0MsZ0JBQWdCaG9CLEVBQUVnb0IsY0FBYztRQUNoQ3hqQixvQkFBb0J4RSxFQUFFd0Usa0JBQWtCO1FBQ3hDaVIsU0FBU3pWLEVBQUV5VixPQUFPO0lBQ3RCO0FBQ0EsU0FBUzZVLHNCQUFzQjNsQixLQUFLO0lBQ2hDLE1BQU0sRUFBRW1aLGNBQWMsRUFBRWlLLGdCQUFnQixFQUFFQyxjQUFjLEVBQUV4akIsa0JBQWtCLEVBQUVpUixPQUFPLEVBQUUsR0FBR2xYLFNBQVM4ckIsWUFBWXBzQixvREFBT0E7SUFDdEgsTUFBTW9vQixVQUFVRCxrQkFBa0J6aEIsTUFBTTRsQix5QkFBeUI7SUFDakUsTUFBTTdVLGlCQUFpQjZRO0lBQ3ZCLE9BQVFqdUIsc0RBQUdBLENBQUMsT0FBTztRQUFFcUksV0FBVztRQUFxQjNCLE9BQU84VztRQUFnQnZWLFVBQVU4bEIsUUFBUTlqQixHQUFHLENBQUMsQ0FBQytSO1lBQzNGLE9BQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQXdCQyxHQUNEaGMsc0RBQUdBLENBQUM4eEIsZUFBZTtnQkFBRTlwQixJQUFJZ1U7Z0JBQVEyVCxXQUFXdGpCLE1BQU1zakIsU0FBUztnQkFBRWhLLFlBQVl0WixNQUFNc1osVUFBVTtnQkFBRTlELFNBQVN4VixNQUFNNmxCLFdBQVc7Z0JBQUU3QyxjQUFjaGpCLE1BQU04bEIsZ0JBQWdCO2dCQUFFN0MsYUFBYWpqQixNQUFNK2xCLGVBQWU7Z0JBQUU3QyxjQUFjbGpCLE1BQU1nbUIsZ0JBQWdCO2dCQUFFdFEsZUFBZTFWLE1BQU1pbUIsaUJBQWlCO2dCQUFFOUMsZUFBZW5qQixNQUFNa21CLGlCQUFpQjtnQkFBRTFOLGlCQUFpQnhZLE1BQU13WSxlQUFlO2dCQUFFMVksZ0JBQWdCRSxNQUFNRixjQUFjO2dCQUFFcEUsTUFBTXNFLE1BQU10RSxJQUFJO2dCQUFFSSxxQkFBcUJrRSxNQUFNbEUsbUJBQW1CO2dCQUFFaVYsZ0JBQWdCQTtnQkFBZ0JvSSxnQkFBZ0JBO2dCQUFnQmlLLGtCQUFrQkE7Z0JBQWtCQyxnQkFBZ0JBO2dCQUFnQnhqQixvQkFBb0JBO2dCQUFvQjhZLG1CQUFtQjNZLE1BQU0yWSxpQkFBaUI7Z0JBQUU3SCxTQUFTQTtZQUFRLEdBQUduQjtRQUN2ckI7SUFBRztBQUNYO0FBQ0FnVyxzQkFBc0J0cEIsV0FBVyxHQUFHO0FBQ3BDLE1BQU04cEIsNkJBQWU5eEIsMkNBQUlBLENBQUNzeEI7QUFFMUI7Ozs7OztDQU1DLEdBQ0QsU0FBU1Msa0JBQWtCNUUsaUJBQWlCO0lBQ3hDLE1BQU02RSxVQUFVenNCLFNBQVN4RixrREFBV0EsQ0FBQyxDQUFDaUg7UUFDbEMsSUFBSSxDQUFDbW1CLG1CQUFtQjtZQUNwQixPQUFPbm1CLEVBQUU0QyxLQUFLLENBQUNMLEdBQUcsQ0FBQyxDQUFDUCxPQUFTQSxLQUFLMUIsRUFBRTtRQUN4QztRQUNBLE1BQU0ycUIsaUJBQWlCLEVBQUU7UUFDekIsSUFBSWpyQixFQUFFWixLQUFLLElBQUlZLEVBQUVYLE1BQU0sRUFBRTtZQUNyQixLQUFLLE1BQU0yQyxRQUFRaEMsRUFBRTRDLEtBQUssQ0FBRTtnQkFDeEIsTUFBTXNvQixhQUFhbHJCLEVBQUUyQixVQUFVLENBQUM4SyxHQUFHLENBQUN6SyxLQUFLNmdCLE1BQU07Z0JBQy9DLE1BQU1zSSxhQUFhbnJCLEVBQUUyQixVQUFVLENBQUM4SyxHQUFHLENBQUN6SyxLQUFLWCxNQUFNO2dCQUMvQyxJQUFJNnBCLGNBQ0FDLGNBQ0E1dkIsNkRBQWFBLENBQUM7b0JBQ1YydkI7b0JBQ0FDO29CQUNBL3JCLE9BQU9ZLEVBQUVaLEtBQUs7b0JBQ2RDLFFBQVFXLEVBQUVYLE1BQU07b0JBQ2hCK0ssV0FBV3BLLEVBQUVvSyxTQUFTO2dCQUMxQixJQUFJO29CQUNKNmdCLGVBQWVwcEIsSUFBSSxDQUFDRyxLQUFLMUIsRUFBRTtnQkFDL0I7WUFDSjtRQUNKO1FBQ0EsT0FBTzJxQjtJQUNYLEdBQUc7UUFBQzlFO0tBQWtCLEdBQUdsb0Isb0RBQU9BO0lBQ2hDLE9BQU8rc0I7QUFDWDtBQUVBLE1BQU1JLGNBQWMsQ0FBQyxFQUFFQyxRQUFRLE1BQU0sRUFBRUMsY0FBYyxDQUFDLEVBQUU7SUFDcEQsTUFBTXRzQixRQUFRO1FBQ1Zzc0I7UUFDQSxHQUFJRCxTQUFTO1lBQUVFLFFBQVFGO1FBQU0sQ0FBQztJQUNsQztJQUNBLE9BQVEveUIsc0RBQUdBLENBQUMsWUFBWTtRQUFFcUksV0FBVztRQUFTM0IsT0FBT0E7UUFBT3dzQixlQUFlO1FBQVNDLE1BQU07UUFBUUMsZ0JBQWdCO1FBQVNDLFFBQVE7SUFBaUI7QUFDeEo7QUFDQSxNQUFNQyxvQkFBb0IsQ0FBQyxFQUFFUCxRQUFRLE1BQU0sRUFBRUMsY0FBYyxDQUFDLEVBQUU7SUFDMUQsTUFBTXRzQixRQUFRO1FBQ1Zzc0I7UUFDQSxHQUFJRCxTQUFTO1lBQUVFLFFBQVFGO1lBQU9JLE1BQU1KO1FBQU0sQ0FBQztJQUMvQztJQUNBLE9BQVEveUIsc0RBQUdBLENBQUMsWUFBWTtRQUFFcUksV0FBVztRQUFlM0IsT0FBT0E7UUFBT3dzQixlQUFlO1FBQVNFLGdCQUFnQjtRQUFTQyxRQUFRO0lBQXVCO0FBQ3RKO0FBQ0EsTUFBTUUsZ0JBQWdCO0lBQ2xCLENBQUNyd0Isc0RBQVVBLENBQUNzd0IsS0FBSyxDQUFDLEVBQUVWO0lBQ3BCLENBQUM1dkIsc0RBQVVBLENBQUN1d0IsV0FBVyxDQUFDLEVBQUVIO0FBQzlCO0FBQ0EsU0FBU0ksZ0JBQWdCMWYsSUFBSTtJQUN6QixNQUFNNU4sUUFBUUU7SUFDZCxNQUFNcXRCLFNBQVN4ekIsOENBQU9BLENBQUM7UUFDbkIsTUFBTXl6QixlQUFlL0csT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ3VHLGVBQWV2ZjtRQUN6RSxJQUFJLENBQUM0ZixjQUFjO1lBQ2Z4dEIsTUFBTUcsUUFBUSxHQUFHNFcsT0FBTyxHQUFHLE9BQU92Yyx5REFBYSxDQUFDLFdBQVcsQ0FBQ29UO1lBQzVELE9BQU87UUFDWDtRQUNBLE9BQU91ZixhQUFhLENBQUN2ZixLQUFLO0lBQzlCLEdBQUc7UUFBQ0E7S0FBSztJQUNULE9BQU8yZjtBQUNYO0FBRUEsTUFBTUUsU0FBUyxDQUFDLEVBQUU3ckIsRUFBRSxFQUFFZ00sSUFBSSxFQUFFK2UsS0FBSyxFQUFFanNCLFFBQVEsSUFBSSxFQUFFQyxTQUFTLElBQUksRUFBRStzQixjQUFjLGFBQWEsRUFBRWQsV0FBVyxFQUFFZSxTQUFTLG9CQUFvQixFQUFHO0lBQ3RJLE1BQU1DLFVBQVNOLGdCQUFnQjFmO0lBQy9CLElBQUksQ0FBQ2dnQixTQUFRO1FBQ1QsT0FBTztJQUNYO0lBQ0EsT0FBUWgwQixzREFBR0EsQ0FBQyxVQUFVO1FBQUVxSSxXQUFXO1FBQXlCTCxJQUFJQTtRQUFJaXNCLGFBQWEsQ0FBQyxFQUFFbnRCLE1BQU0sQ0FBQztRQUFFb3RCLGNBQWMsQ0FBQyxFQUFFbnRCLE9BQU8sQ0FBQztRQUFFb3RCLFNBQVM7UUFBaUJMLGFBQWFBO1FBQWFDLFFBQVFBO1FBQVFLLE1BQU07UUFBS0MsTUFBTTtRQUFLcHNCLFVBQVVqSSxzREFBR0EsQ0FBQ2cwQixTQUFRO1lBQUVqQixPQUFPQTtZQUFPQyxhQUFhQTtRQUFZO0lBQUc7QUFDeFI7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTXNCLG9CQUFvQixDQUFDLEVBQUVDLFlBQVksRUFBRXhzQixJQUFJLEVBQUU7SUFDN0MsTUFBTXVDLFFBQVFyRSxTQUFTLENBQUN5QixJQUFNQSxFQUFFNEMsS0FBSztJQUNyQyxNQUFNeVkscUJBQXFCOWMsU0FBUyxDQUFDeUIsSUFBTUEsRUFBRXFiLGtCQUFrQjtJQUMvRCxNQUFNeVIsVUFBVXIwQiw4Q0FBT0EsQ0FBQztRQUNwQixNQUFNcTBCLFVBQVVyeEIsK0RBQWVBLENBQUNtSCxPQUFPO1lBQ25DdEMsSUFBSUQ7WUFDSndzQjtZQUNBRSxvQkFBb0IxUixvQkFBb0IyUjtZQUN4Q0Msa0JBQWtCNVIsb0JBQW9CNlI7UUFDMUM7UUFDQSxPQUFPSjtJQUNYLEdBQUc7UUFBQ2xxQjtRQUFPeVk7UUFBb0JoYjtRQUFNd3NCO0tBQWE7SUFDbEQsSUFBSSxDQUFDQyxRQUFROWpCLE1BQU0sRUFBRTtRQUNqQixPQUFPO0lBQ1g7SUFDQSxPQUFRMVEsc0RBQUdBLENBQUMsT0FBTztRQUFFcUksV0FBVztRQUFzQixlQUFlO1FBQVFKLFVBQVVqSSxzREFBR0EsQ0FBQyxRQUFRO1lBQUVpSSxVQUFVdXNCLFFBQVF2cUIsR0FBRyxDQUFDLENBQUM0cUIsU0FBWTcwQixzREFBR0EsQ0FBQzZ6QixRQUFRO29CQUFFN3JCLElBQUk2c0IsT0FBTzdzQixFQUFFO29CQUFFZ00sTUFBTTZnQixPQUFPN2dCLElBQUk7b0JBQUUrZSxPQUFPOEIsT0FBTzlCLEtBQUs7b0JBQUVqc0IsT0FBTyt0QixPQUFPL3RCLEtBQUs7b0JBQUVDLFFBQVE4dEIsT0FBTzl0QixNQUFNO29CQUFFK3NCLGFBQWFlLE9BQU9mLFdBQVc7b0JBQUVkLGFBQWE2QixPQUFPN0IsV0FBVztvQkFBRWUsUUFBUWMsT0FBT2QsTUFBTTtnQkFBQyxHQUFHYyxPQUFPN3NCLEVBQUU7UUFBSTtJQUFHO0FBQ3hXO0FBQ0Fzc0Isa0JBQWtCNXJCLFdBQVcsR0FBRztBQUNoQyxJQUFJb3NCLG9DQUFzQnAwQiwyQ0FBSUEsQ0FBQzR6QjtBQUUvQixTQUFTUyxrQkFBa0IsRUFBRWhxQixDQUFDLEVBQUVDLENBQUMsRUFBRW1nQixLQUFLLEVBQUU2SixVQUFVLEVBQUVDLGNBQWMsSUFBSSxFQUFFQyxZQUFZLEVBQUVDLGlCQUFpQjtJQUFDO0lBQUc7Q0FBRSxFQUFFQyxzQkFBc0IsQ0FBQyxFQUFFbnRCLFFBQVEsRUFBRUksU0FBUyxFQUFFLEdBQUdDLE1BQU07SUFDcEssTUFBTSxDQUFDK3NCLGNBQWNDLGdCQUFnQixHQUFHLzBCLCtDQUFRQSxDQUFDO1FBQUV3SyxHQUFHO1FBQUdDLEdBQUc7UUFBR2xFLE9BQU87UUFBR0MsUUFBUTtJQUFFO0lBQ25GLE1BQU13dUIsa0JBQWtCNTBCLG9EQUFFQSxDQUFDO1FBQUM7UUFBZ0MwSDtLQUFVO0lBQ3RFLE1BQU1tdEIsY0FBY2wxQiw2Q0FBTUEsQ0FBQztJQUMzQkQsZ0RBQVNBLENBQUM7UUFDTixJQUFJbTFCLFlBQVkvb0IsT0FBTyxFQUFFO1lBQ3JCLE1BQU1ncEIsV0FBV0QsWUFBWS9vQixPQUFPLENBQUNpcEIsT0FBTztZQUM1Q0osZ0JBQWdCO2dCQUNadnFCLEdBQUcwcUIsU0FBUzFxQixDQUFDO2dCQUNiQyxHQUFHeXFCLFNBQVN6cUIsQ0FBQztnQkFDYmxFLE9BQU8ydUIsU0FBUzN1QixLQUFLO2dCQUNyQkMsUUFBUTB1QixTQUFTMXVCLE1BQU07WUFDM0I7UUFDSjtJQUNKLEdBQUc7UUFBQ29rQjtLQUFNO0lBQ1YsSUFBSSxDQUFDQSxPQUFPO1FBQ1IsT0FBTztJQUNYO0lBQ0EsT0FBUXJyQix1REFBSUEsQ0FBQyxLQUFLO1FBQUVnUyxXQUFXLENBQUMsVUFBVSxFQUFFL0csSUFBSXNxQixhQUFhdnVCLEtBQUssR0FBRyxFQUFFLENBQUMsRUFBRWtFLElBQUlxcUIsYUFBYXR1QixNQUFNLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFBRXNCLFdBQVdrdEI7UUFBaUJqRSxZQUFZK0QsYUFBYXZ1QixLQUFLLEdBQUcsWUFBWTtRQUFVLEdBQUd3QixJQUFJO1FBQUVMLFVBQVU7WUFBQ2d0QixlQUFnQmoxQixzREFBR0EsQ0FBQyxRQUFRO2dCQUFFOEcsT0FBT3V1QixhQUFhdnVCLEtBQUssR0FBRyxJQUFJcXVCLGNBQWMsQ0FBQyxFQUFFO2dCQUFFcHFCLEdBQUcsQ0FBQ29xQixjQUFjLENBQUMsRUFBRTtnQkFBRW5xQixHQUFHLENBQUNtcUIsY0FBYyxDQUFDLEVBQUU7Z0JBQUVwdUIsUUFBUXN1QixhQUFhdHVCLE1BQU0sR0FBRyxJQUFJb3VCLGNBQWMsQ0FBQyxFQUFFO2dCQUFFOXNCLFdBQVc7Z0JBQTJCM0IsT0FBT3d1QjtnQkFBY1MsSUFBSVA7Z0JBQXFCUSxJQUFJUjtZQUFvQjtZQUFLcDFCLHNEQUFHQSxDQUFDLFFBQVE7Z0JBQUVxSSxXQUFXO2dCQUF5QjJDLEdBQUdxcUIsYUFBYXR1QixNQUFNLEdBQUc7Z0JBQUc4dUIsSUFBSTtnQkFBU3R0QixLQUFLaXRCO2dCQUFhOXVCLE9BQU9zdUI7Z0JBQVkvc0IsVUFBVWtqQjtZQUFNO1lBQUlsakI7U0FBUztJQUFDO0FBQ3hwQjtBQUNBOHNCLGtCQUFrQnJzQixXQUFXLEdBQUc7QUFDaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FDRCxNQUFNb3RCLHlCQUFXcDFCLDJDQUFJQSxDQUFDcTBCO0FBRXRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBCQyxHQUNELFNBQVNnQixTQUFTLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUUvSyxLQUFLLEVBQUU2SixVQUFVLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxjQUFjLEVBQUVDLG1CQUFtQixFQUFFZSxtQkFBbUIsRUFBRSxFQUFFLEdBQUc5cEIsT0FBTztJQUMxSixPQUFRdk0sdURBQUlBLENBQUNDLHVEQUFRQSxFQUFFO1FBQUVrSSxVQUFVO1lBQUNqSSxzREFBR0EsQ0FBQyxRQUFRO2dCQUFFLEdBQUdxTSxLQUFLO2dCQUFFK3BCLEdBQUdKO2dCQUFNN0MsTUFBTTtnQkFBUTlxQixXQUFXMUgsb0RBQUVBLENBQUM7b0JBQUM7b0JBQXlCMEwsTUFBTWhFLFNBQVM7aUJBQUM7WUFBRTtZQUFJOHRCLG1CQUFvQm4yQixzREFBR0EsQ0FBQyxRQUFRO2dCQUFFbzJCLEdBQUdKO2dCQUFNN0MsTUFBTTtnQkFBUWtELGVBQWU7Z0JBQUdyRCxhQUFhbUQ7Z0JBQWtCOXRCLFdBQVc7WUFBK0IsS0FBTTtZQUFNOGlCLFNBQVN0b0IseURBQVNBLENBQUNvekIsV0FBV3B6Qix5REFBU0EsQ0FBQ3F6QixVQUFXbDJCLHNEQUFHQSxDQUFDODFCLFVBQVU7Z0JBQUUvcUIsR0FBR2tyQjtnQkFBUWpyQixHQUFHa3JCO2dCQUFRL0ssT0FBT0E7Z0JBQU82SixZQUFZQTtnQkFBWUMsYUFBYUE7Z0JBQWFDLGNBQWNBO2dCQUFjQyxnQkFBZ0JBO2dCQUFnQkMscUJBQXFCQTtZQUFvQixLQUFNO1NBQUs7SUFBQztBQUMvakI7QUFFQSxTQUFTa0IsV0FBVyxFQUFFQyxHQUFHLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtJQUN2QyxJQUFJSixRQUFRajBCLG9EQUFRQSxDQUFDczBCLElBQUksSUFBSUwsUUFBUWowQixvREFBUUEsQ0FBQ3UwQixLQUFLLEVBQUU7UUFDakQsT0FBTztZQUFDLE1BQU9MLENBQUFBLEtBQUtFLEVBQUM7WUFBSUQ7U0FBRztJQUNoQztJQUNBLE9BQU87UUFBQ0Q7UUFBSSxNQUFPQyxDQUFBQSxLQUFLRSxFQUFDO0tBQUc7QUFDaEM7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTRyxvQkFBb0IsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUUvTCxpQkFBaUIzb0Isb0RBQVFBLENBQUM0b0IsTUFBTSxFQUFFK0wsT0FBTyxFQUFFQyxPQUFPLEVBQUU3TCxpQkFBaUIvb0Isb0RBQVFBLENBQUNzbEIsR0FBRyxFQUFHO0lBQ2pJLE1BQU0sQ0FBQ3VQLGdCQUFnQkMsZUFBZSxHQUFHZCxXQUFXO1FBQ2hEQyxLQUFLdEw7UUFDTHVMLElBQUlPO1FBQ0pOLElBQUlPO1FBQ0pOLElBQUlPO1FBQ0pOLElBQUlPO0lBQ1I7SUFDQSxNQUFNLENBQUNHLGdCQUFnQkMsZUFBZSxHQUFHaEIsV0FBVztRQUNoREMsS0FBS2xMO1FBQ0xtTCxJQUFJUztRQUNKUixJQUFJUztRQUNKUixJQUFJSztRQUNKSixJQUFJSztJQUNSO0lBQ0EsTUFBTSxDQUFDZixRQUFRQyxRQUFRcUIsU0FBU0MsUUFBUSxHQUFHcDBCLG1FQUFtQkEsQ0FBQztRQUMzRDJ6QjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsT0FBTztRQUNILENBQUMsQ0FBQyxFQUFFUCxRQUFRLENBQUMsRUFBRUMsUUFBUSxFQUFFLEVBQUVHLGVBQWUsQ0FBQyxFQUFFQyxlQUFlLENBQUMsRUFBRUMsZUFBZSxDQUFDLEVBQUVDLGVBQWUsQ0FBQyxFQUFFTCxRQUFRLENBQUMsRUFBRUMsUUFBUSxDQUFDO1FBQ3ZIakI7UUFDQUM7UUFDQXFCO1FBQ0FDO0tBQ0g7QUFDTDtBQUNBLFNBQVNDLHVCQUF1QnJ0QixNQUFNO0lBQ2xDLDhDQUE4QztJQUM5QyxxQkFBTzFKLDJDQUFJQSxDQUFDLENBQUMsRUFBRXNILEVBQUUsRUFBRSt1QixPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVqTSxjQUFjLEVBQUVJLGNBQWMsRUFBRUYsS0FBSyxFQUFFNkosVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxtQkFBbUIsRUFBRTF1QixLQUFLLEVBQUVrdUIsU0FBUyxFQUFFRixXQUFXLEVBQUV5QixnQkFBZ0IsRUFBRztRQUN4TixNQUFNLENBQUNILE1BQU1DLFFBQVFDLE9BQU8sR0FBR1ksb0JBQW9CO1lBQy9DQztZQUNBQztZQUNBL0w7WUFDQWdNO1lBQ0FDO1lBQ0E3TDtRQUNKO1FBQ0EsTUFBTXFNLE1BQU10dEIsT0FBT3V0QixVQUFVLEdBQUduakIsWUFBWXhNO1FBQzVDLE9BQVFoSSxzREFBR0EsQ0FBQysxQixVQUFVO1lBQUUvdEIsSUFBSTB2QjtZQUFLMUIsTUFBTUE7WUFBTUMsUUFBUUE7WUFBUUMsUUFBUUE7WUFBUS9LLE9BQU9BO1lBQU82SixZQUFZQTtZQUFZQyxhQUFhQTtZQUFhQyxjQUFjQTtZQUFjQyxnQkFBZ0JBO1lBQWdCQyxxQkFBcUJBO1lBQXFCMXVCLE9BQU9BO1lBQU9rdUIsV0FBV0E7WUFBV0YsYUFBYUE7WUFBYXlCLGtCQUFrQkE7UUFBaUI7SUFDeFY7QUFDSjtBQUNBLE1BQU15QixtQkFBbUJILHVCQUF1QjtJQUFFRSxZQUFZO0FBQU07QUFDcEUsTUFBTUUsMkJBQTJCSix1QkFBdUI7SUFBRUUsWUFBWTtBQUFLO0FBQzNFQyxpQkFBaUJsdkIsV0FBVyxHQUFHO0FBQy9CbXZCLHlCQUF5Qm52QixXQUFXLEdBQUc7QUFFdkMsU0FBU292QixxQkFBcUIxdEIsTUFBTTtJQUNoQyw4Q0FBOEM7SUFDOUMscUJBQU8xSiwyQ0FBSUEsQ0FBQyxDQUFDLEVBQUVzSCxFQUFFLEVBQUUrdUIsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFL0wsS0FBSyxFQUFFNkosVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxtQkFBbUIsRUFBRTF1QixLQUFLLEVBQUV1a0IsaUJBQWlCM29CLG9EQUFRQSxDQUFDNG9CLE1BQU0sRUFBRUcsaUJBQWlCL29CLG9EQUFRQSxDQUFDc2xCLEdBQUcsRUFBRWdOLFNBQVMsRUFBRUYsV0FBVyxFQUFFcUQsV0FBVyxFQUFFNUIsZ0JBQWdCLEVBQUc7UUFDdFEsTUFBTSxDQUFDSCxNQUFNQyxRQUFRQyxPQUFPLEdBQUc3eUIsaUVBQWlCQSxDQUFDO1lBQzdDMHpCO1lBQ0FDO1lBQ0EvTDtZQUNBZ007WUFDQUM7WUFDQTdMO1lBQ0EyTSxjQUFjRCxhQUFhQztZQUMzQkMsUUFBUUYsYUFBYUU7WUFDckJDLGNBQWNILGFBQWFHO1FBQy9CO1FBQ0EsTUFBTVIsTUFBTXR0QixPQUFPdXRCLFVBQVUsR0FBR25qQixZQUFZeE07UUFDNUMsT0FBUWhJLHNEQUFHQSxDQUFDKzFCLFVBQVU7WUFBRS90QixJQUFJMHZCO1lBQUsxQixNQUFNQTtZQUFNQyxRQUFRQTtZQUFRQyxRQUFRQTtZQUFRL0ssT0FBT0E7WUFBTzZKLFlBQVlBO1lBQVlDLGFBQWFBO1lBQWFDLGNBQWNBO1lBQWNDLGdCQUFnQkE7WUFBZ0JDLHFCQUFxQkE7WUFBcUIxdUIsT0FBT0E7WUFBT2t1QixXQUFXQTtZQUFXRixhQUFhQTtZQUFheUIsa0JBQWtCQTtRQUFpQjtJQUN4VjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxNQUFNZ0MsaUJBQWlCTCxxQkFBcUI7SUFBRUgsWUFBWTtBQUFNO0FBQ2hFOztDQUVDLEdBQ0QsTUFBTVMseUJBQXlCTixxQkFBcUI7SUFBRUgsWUFBWTtBQUFLO0FBQ3ZFUSxlQUFlenZCLFdBQVcsR0FBRztBQUM3QjB2Qix1QkFBdUIxdkIsV0FBVyxHQUFHO0FBRXJDLFNBQVMydkIsZUFBZWp1QixNQUFNO0lBQzFCLDhDQUE4QztJQUM5QyxxQkFBTzFKLDJDQUFJQSxDQUFDLENBQUMsRUFBRXNILEVBQUUsRUFBRSxHQUFHcUUsT0FBTztRQUN6QixNQUFNcXJCLE1BQU10dEIsT0FBT3V0QixVQUFVLEdBQUduakIsWUFBWXhNO1FBQzVDLE9BQVFoSSxzREFBR0EsQ0FBQ200QixnQkFBZ0I7WUFBRSxHQUFHOXJCLEtBQUs7WUFBRXJFLElBQUkwdkI7WUFBS0ssYUFBYTUzQiw4Q0FBT0EsQ0FBQyxJQUFPO29CQUFFNjNCLGNBQWM7b0JBQUdDLFFBQVE1ckIsTUFBTTByQixXQUFXLEVBQUVFO2dCQUFPLElBQUk7Z0JBQUM1ckIsTUFBTTByQixXQUFXLEVBQUVFO2FBQU87UUFBRTtJQUN2SztBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxNQUFNSyxXQUFXRCxlQUFlO0lBQUVWLFlBQVk7QUFBTTtBQUNwRDs7Q0FFQyxHQUNELE1BQU1ZLG1CQUFtQkYsZUFBZTtJQUFFVixZQUFZO0FBQUs7QUFDM0RXLFNBQVM1dkIsV0FBVyxHQUFHO0FBQ3ZCNnZCLGlCQUFpQjd2QixXQUFXLEdBQUc7QUFFL0IsU0FBUzh2QixtQkFBbUJwdUIsTUFBTTtJQUM5Qiw4Q0FBOEM7SUFDOUMscUJBQU8xSiwyQ0FBSUEsQ0FBQyxDQUFDLEVBQUVzSCxFQUFFLEVBQUUrdUIsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFL0wsS0FBSyxFQUFFNkosVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxtQkFBbUIsRUFBRTF1QixLQUFLLEVBQUVrdUIsU0FBUyxFQUFFRixXQUFXLEVBQUV5QixnQkFBZ0IsRUFBRztRQUN4TCxNQUFNLENBQUNILE1BQU1DLFFBQVFDLE9BQU8sR0FBRzV5QiwrREFBZUEsQ0FBQztZQUFFeXpCO1lBQVNDO1lBQVNDO1lBQVNDO1FBQVE7UUFDcEYsTUFBTVEsTUFBTXR0QixPQUFPdXRCLFVBQVUsR0FBR25qQixZQUFZeE07UUFDNUMsT0FBUWhJLHNEQUFHQSxDQUFDKzFCLFVBQVU7WUFBRS90QixJQUFJMHZCO1lBQUsxQixNQUFNQTtZQUFNQyxRQUFRQTtZQUFRQyxRQUFRQTtZQUFRL0ssT0FBT0E7WUFBTzZKLFlBQVlBO1lBQVlDLGFBQWFBO1lBQWFDLGNBQWNBO1lBQWNDLGdCQUFnQkE7WUFBZ0JDLHFCQUFxQkE7WUFBcUIxdUIsT0FBT0E7WUFBT2t1QixXQUFXQTtZQUFXRixhQUFhQTtZQUFheUIsa0JBQWtCQTtRQUFpQjtJQUN4VjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ0QsTUFBTXNDLGVBQWVELG1CQUFtQjtJQUFFYixZQUFZO0FBQU07QUFDNUQ7O0NBRUMsR0FDRCxNQUFNZSx1QkFBdUJGLG1CQUFtQjtJQUFFYixZQUFZO0FBQUs7QUFDbkVjLGFBQWEvdkIsV0FBVyxHQUFHO0FBQzNCZ3dCLHFCQUFxQmh3QixXQUFXLEdBQUc7QUFFbkMsU0FBU2l3QixpQkFBaUJ2dUIsTUFBTTtJQUM1Qiw4Q0FBOEM7SUFDOUMscUJBQU8xSiwyQ0FBSUEsQ0FBQyxDQUFDLEVBQUVzSCxFQUFFLEVBQUUrdUIsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFak0saUJBQWlCM29CLG9EQUFRQSxDQUFDNG9CLE1BQU0sRUFBRUcsaUJBQWlCL29CLG9EQUFRQSxDQUFDc2xCLEdBQUcsRUFBRXVELEtBQUssRUFBRTZKLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGNBQWMsRUFBRUMsbUJBQW1CLEVBQUUxdUIsS0FBSyxFQUFFa3VCLFNBQVMsRUFBRUYsV0FBVyxFQUFFcUQsV0FBVyxFQUFFNUIsZ0JBQWdCLEVBQUc7UUFDdFEsTUFBTSxDQUFDSCxNQUFNQyxRQUFRQyxPQUFPLEdBQUczeUIsNkRBQWFBLENBQUM7WUFDekN3ekI7WUFDQUM7WUFDQS9MO1lBQ0FnTTtZQUNBQztZQUNBN0w7WUFDQXVOLFdBQVdiLGFBQWFhO1FBQzVCO1FBQ0EsTUFBTWxCLE1BQU10dEIsT0FBT3V0QixVQUFVLEdBQUduakIsWUFBWXhNO1FBQzVDLE9BQVFoSSxzREFBR0EsQ0FBQysxQixVQUFVO1lBQUUvdEIsSUFBSTB2QjtZQUFLMUIsTUFBTUE7WUFBTUMsUUFBUUE7WUFBUUMsUUFBUUE7WUFBUS9LLE9BQU9BO1lBQU82SixZQUFZQTtZQUFZQyxhQUFhQTtZQUFhQyxjQUFjQTtZQUFjQyxnQkFBZ0JBO1lBQWdCQyxxQkFBcUJBO1lBQXFCMXVCLE9BQU9BO1lBQU9rdUIsV0FBV0E7WUFBV0YsYUFBYUE7WUFBYXlCLGtCQUFrQkE7UUFBaUI7SUFDeFY7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsTUFBTTBDLGFBQWFGLGlCQUFpQjtJQUFFaEIsWUFBWTtBQUFNO0FBQ3hEOztDQUVDLEdBQ0QsTUFBTW1CLHFCQUFxQkgsaUJBQWlCO0lBQUVoQixZQUFZO0FBQUs7QUFDL0RrQixXQUFXbndCLFdBQVcsR0FBRztBQUN6Qm93QixtQkFBbUJwd0IsV0FBVyxHQUFHO0FBRWpDLE1BQU1xd0IsbUJBQW1CO0lBQ3JCaE4sU0FBUytNO0lBQ1RFLFVBQVVOO0lBQ1ZPLE1BQU1WO0lBQ05XLFlBQVlkO0lBQ1plLGNBQWN0QjtBQUNsQjtBQUNBLE1BQU11QixlQUFlO0lBQ2pCckMsU0FBUztJQUNUQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsU0FBUztJQUNUak0sZ0JBQWdCO0lBQ2hCSSxnQkFBZ0I7QUFDcEI7QUFFQSxNQUFNZ08sU0FBUyxDQUFDdHVCLEdBQUd1dUIsT0FBT3p5QjtJQUN0QixJQUFJQSxhQUFhdkUsb0RBQVFBLENBQUNzMEIsSUFBSSxFQUMxQixPQUFPN3JCLElBQUl1dUI7SUFDZixJQUFJenlCLGFBQWF2RSxvREFBUUEsQ0FBQ3UwQixLQUFLLEVBQzNCLE9BQU85ckIsSUFBSXV1QjtJQUNmLE9BQU92dUI7QUFDWDtBQUNBLE1BQU13dUIsU0FBUyxDQUFDdnVCLEdBQUdzdUIsT0FBT3p5QjtJQUN0QixJQUFJQSxhQUFhdkUsb0RBQVFBLENBQUNzbEIsR0FBRyxFQUN6QixPQUFPNWMsSUFBSXN1QjtJQUNmLElBQUl6eUIsYUFBYXZFLG9EQUFRQSxDQUFDNG9CLE1BQU0sRUFDNUIsT0FBT2xnQixJQUFJc3VCO0lBQ2YsT0FBT3R1QjtBQUNYO0FBQ0EsTUFBTXd1Qix1QkFBdUI7QUFDN0I7O0NBRUMsR0FDRCxTQUFTQyxXQUFXLEVBQUU1eUIsUUFBUSxFQUFFNnlCLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUUsRUFBRTFSLFdBQVcsRUFBRW1ILFlBQVksRUFBRXdLLFVBQVUsRUFBRTdsQixJQUFJLEVBQUc7SUFDekcsT0FBUWhVLHNEQUFHQSxDQUFDLFVBQVU7UUFBRWtvQixhQUFhQTtRQUFhbUgsY0FBY0E7UUFBY3dLLFlBQVlBO1FBQVl4eEIsV0FBVzFILG9EQUFFQSxDQUFDO1lBQUM2NEI7WUFBc0IsQ0FBQyxFQUFFQSxxQkFBcUIsQ0FBQyxFQUFFeGxCLEtBQUssQ0FBQztTQUFDO1FBQUc4bEIsSUFBSVQsT0FBT0ssU0FBU0UsUUFBUS95QjtRQUFXa3pCLElBQUlSLE9BQU9JLFNBQVNDLFFBQVEveUI7UUFBV216QixHQUFHSjtRQUFRM0csUUFBUTtRQUFlRSxNQUFNO0lBQWM7QUFDeFQ7QUFFQSxTQUFTOEcsa0JBQWtCLEVBQUVDLGVBQWUsRUFBRUMsZUFBZSxFQUFFendCLElBQUksRUFBRXF0QixPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVqTSxjQUFjLEVBQUVJLGNBQWMsRUFBRStPLFdBQVcsRUFBRUMsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUc7SUFDdE4sTUFBTXAwQixRQUFRRTtJQUNkLE1BQU1tMEIsb0JBQW9CLENBQUNwckIsT0FBT3FyQjtRQUM5Qix5REFBeUQ7UUFDekQsSUFBSXJyQixNQUFNa1QsTUFBTSxLQUFLLEdBQUc7WUFDcEI7UUFDSjtRQUNBLE1BQU0sRUFBRXNHLGdCQUFnQixFQUFFL1YsT0FBTyxFQUFFK1UsaUJBQWlCLEVBQUVkLGNBQWMsRUFBRStCLGdCQUFnQixFQUFFakwsR0FBRyxFQUFFb0wsY0FBYyxFQUFFQyxZQUFZLEVBQUVGLGdCQUFnQixFQUFFM2YsVUFBVSxFQUFFdEIsTUFBTWdoQixNQUFNLEVBQUV6a0IsS0FBSyxFQUFFNmtCLGdCQUFnQixFQUFHLEdBQUcvaUIsTUFBTUcsUUFBUTtRQUNsTixNQUFNNmhCLFdBQVdzUyxlQUFlMW1CLElBQUksS0FBSztRQUN6QyxNQUFNMm1CLGtCQUFrQixDQUFDQyxLQUFLaFI7WUFDMUIyUSxnQkFBZ0I7WUFDaEJELGlCQUFpQk0sS0FBS2x4QixNQUFNZ3hCLGVBQWUxbUIsSUFBSSxFQUFFNFY7UUFDckQ7UUFDQSxNQUFNaVIsZ0JBQWdCLENBQUM5YyxhQUFlcWMsY0FBYzF3QixNQUFNcVU7UUFDMUQsTUFBTStjLGtCQUFrQixDQUFDQyxRQUFRM3dCO1lBQzdCbXdCLGdCQUFnQjtZQUNoQkYsbUJBQW1CaHJCLE9BQU8zRixNQUFNZ3hCLGVBQWUxbUIsSUFBSTtZQUNuRGlWLGlCQUFpQjhSLFFBQVEzd0I7UUFDN0I7UUFDQTNILG9EQUFRQSxDQUFDK2xCLGFBQWEsQ0FBQ25aLE1BQU1zVCxXQUFXLEVBQUU7WUFDdENrRztZQUNBOUI7WUFDQStCO1lBQ0FoVztZQUNBc0osVUFBVXNlLGVBQWUxeUIsRUFBRTtZQUMzQmdVLFFBQVEwZSxlQUFlMWUsTUFBTTtZQUM3QjNTO1lBQ0ErZTtZQUNBNFMsaUJBQWlCTixlQUFlMW1CLElBQUk7WUFDcEM2SjtZQUNBa0w7WUFDQUM7WUFDQTFrQjtZQUNBdWpCO1lBQ0FJLFdBQVc0UztZQUNYNVIsZ0JBQWdCNlI7WUFDaEI1UjtZQUNBb1IsZ0JBQWdCSztZQUNoQnhSO1lBQ0FDLGNBQWMsSUFBTWhqQixNQUFNRyxRQUFRLEdBQUd1TCxTQUFTO1lBQzlDdVgsZUFBZSxJQUFNampCLE1BQU1HLFFBQVEsR0FBR3dYLFVBQVUsQ0FBQ2lKLFVBQVU7WUFDM0R1QyxlQUFlbmpCLE1BQU1HLFFBQVEsR0FBR2lqQix1QkFBdUI7WUFDdkRiLGVBQWV0WixNQUFNdVosYUFBYTtRQUN0QztJQUNKO0lBQ0EsTUFBTXFTLDZCQUE2QixDQUFDNXJCLFFBQVVvckIsa0JBQWtCcHJCLE9BQU87WUFBRTJNLFFBQVF0UyxLQUFLWCxNQUFNO1lBQUVmLElBQUkwQixLQUFLd3hCLFlBQVksSUFBSTtZQUFNbG5CLE1BQU07UUFBUztJQUM1SSxNQUFNbW5CLDZCQUE2QixDQUFDOXJCLFFBQVVvckIsa0JBQWtCcHJCLE9BQU87WUFBRTJNLFFBQVF0UyxLQUFLNmdCLE1BQU07WUFBRXZpQixJQUFJMEIsS0FBSzB4QixZQUFZLElBQUk7WUFBTXBuQixNQUFNO1FBQVM7SUFDNUksTUFBTXFuQix3QkFBd0IsSUFBTWIsZUFBZTtJQUNuRCxNQUFNYyxzQkFBc0IsSUFBTWQsZUFBZTtJQUNqRCxPQUFRMTZCLHVEQUFJQSxDQUFDQyx1REFBUUEsRUFBRTtRQUFFa0ksVUFBVTtZQUFFaXlCLENBQUFBLG9CQUFvQixRQUFRQSxvQkFBb0IsUUFBTyxLQUFPbDZCLHNEQUFHQSxDQUFDeTVCLFlBQVk7Z0JBQUU1eUIsVUFBVW9rQjtnQkFBZ0J5TyxTQUFTM0M7Z0JBQVM0QyxTQUFTM0M7Z0JBQVM0QyxRQUFRTztnQkFBaUJqUyxhQUFhK1M7Z0JBQTRCNUwsY0FBY2dNO2dCQUF1QnhCLFlBQVl5QjtnQkFBcUJ0bkIsTUFBTTtZQUFTO1lBQU1rbUIsQ0FBQUEsb0JBQW9CLFFBQVFBLG9CQUFvQixRQUFPLEtBQU9sNkIsc0RBQUdBLENBQUN5NUIsWUFBWTtnQkFBRTV5QixVQUFVd2tCO2dCQUFnQnFPLFNBQVN6QztnQkFBUzBDLFNBQVN6QztnQkFBUzBDLFFBQVFPO2dCQUFpQmpTLGFBQWFpVDtnQkFBNEI5TCxjQUFjZ007Z0JBQXVCeEIsWUFBWXlCO2dCQUFxQnRuQixNQUFNO1lBQVM7U0FBSTtJQUFDO0FBQzluQjtBQUVBLFNBQVN1bkIsWUFBWSxFQUFFdnpCLEVBQUUsRUFBRXd6QixjQUFjLEVBQUVDLGtCQUFrQixFQUFFdnZCLGtCQUFrQixFQUFFMlYsT0FBTyxFQUFFMk4sYUFBYSxFQUFFek4sYUFBYSxFQUFFc04sWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRTRLLGVBQWUsRUFBRUMsV0FBVyxFQUFFQyxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFdnlCLElBQUksRUFBRTJ6QixTQUFTLEVBQUV2dkIsY0FBYyxFQUFFZ1IsT0FBTyxFQUFFaFYsbUJBQW1CLEVBQUc7SUFDL1IsSUFBSXVCLE9BQU96RCxTQUFTLENBQUN5QixJQUFNQSxFQUFFaUMsVUFBVSxDQUFDd0ssR0FBRyxDQUFDbk07SUFDNUMsTUFBTSthLHFCQUFxQjljLFNBQVMsQ0FBQ3lCLElBQU1BLEVBQUVxYixrQkFBa0I7SUFDL0RyWixPQUFPcVoscUJBQXFCO1FBQUUsR0FBR0Esa0JBQWtCO1FBQUUsR0FBR3JaLElBQUk7SUFBQyxJQUFJQTtJQUNqRSxJQUFJaXlCLFdBQVdqeUIsS0FBS3NLLElBQUksSUFBSTtJQUM1QixJQUFJNG5CLGdCQUFnQkYsV0FBVyxDQUFDQyxTQUFTLElBQUk1QyxnQkFBZ0IsQ0FBQzRDLFNBQVM7SUFDdkUsSUFBSUMsa0JBQWtCcG5CLFdBQVc7UUFDN0IySSxVQUFVLE9BQU92Yyx5REFBYSxDQUFDLFdBQVcsQ0FBQys2QjtRQUMzQ0EsV0FBVztRQUNYQyxnQkFBZ0JGLFdBQVcsQ0FBQyxVQUFVLElBQUkzQyxpQkFBaUJoTixPQUFPO0lBQ3RFO0lBQ0EsTUFBTWlFLGNBQWMsQ0FBQyxDQUFFdG1CLENBQUFBLEtBQUt1bUIsU0FBUyxJQUFLdUwsa0JBQWtCLE9BQU85eEIsS0FBS3VtQixTQUFTLEtBQUssV0FBVztJQUNqRyxNQUFNaUssa0JBQWtCLE9BQU9FLGdCQUFnQixlQUMxQzF3QixDQUFBQSxLQUFLbXlCLGFBQWEsSUFBS0osc0JBQXNCLE9BQU8veEIsS0FBS215QixhQUFhLEtBQUssV0FBVztJQUMzRixNQUFNOVcsZUFBZSxDQUFDLENBQUVyYixDQUFBQSxLQUFLa2EsVUFBVSxJQUFLMVgsc0JBQXNCLE9BQU94QyxLQUFLa2EsVUFBVSxLQUFLLFdBQVc7SUFDeEcsTUFBTWtZLFVBQVV4N0IsNkNBQU1BLENBQUM7SUFDdkIsTUFBTSxDQUFDeTdCLGFBQWF2QixlQUFlLEdBQUdqNkIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDeTdCLGNBQWN6QixnQkFBZ0IsR0FBR2g2QiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNNkYsUUFBUUU7SUFDZCxNQUFNLEVBQUU2cUIsTUFBTSxFQUFFNEYsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFak0sY0FBYyxFQUFFSSxjQUFjLEVBQUUsR0FBR3BsQixTQUFTeEYsa0RBQVdBLENBQUMsQ0FBQzJGO1FBQ3pHLE1BQU13c0IsYUFBYXhzQixNQUFNaUQsVUFBVSxDQUFDOEssR0FBRyxDQUFDekssS0FBSzZnQixNQUFNO1FBQ25ELE1BQU1zSSxhQUFhenNCLE1BQU1pRCxVQUFVLENBQUM4SyxHQUFHLENBQUN6SyxLQUFLWCxNQUFNO1FBQ25ELElBQUksQ0FBQzZwQixjQUFjLENBQUNDLFlBQVk7WUFDNUIsT0FBTztnQkFDSDFCLFFBQVF6bkIsS0FBS3luQixNQUFNO2dCQUNuQixHQUFHaUksWUFBWTtZQUNuQjtRQUNKO1FBQ0EsTUFBTTZDLGVBQWV6NEIsK0RBQWVBLENBQUM7WUFDakN3RTtZQUNBNHFCO1lBQ0FDO1lBQ0F1SSxjQUFjMXhCLEtBQUsweEIsWUFBWSxJQUFJO1lBQ25DRixjQUFjeHhCLEtBQUt3eEIsWUFBWSxJQUFJO1lBQ25DblUsZ0JBQWdCM2dCLE1BQU0yZ0IsY0FBYztZQUNwQzVKO1FBQ0o7UUFDQSxNQUFNZ1UsU0FBUzF0QixxRUFBcUJBLENBQUM7WUFDakM2RixVQUFVSSxLQUFLSixRQUFRO1lBQ3ZCNm5CLFFBQVF6bkIsS0FBS3luQixNQUFNO1lBQ25CeUI7WUFDQUM7WUFDQXFKLGlCQUFpQjkxQixNQUFNKzFCLG9CQUFvQjtZQUMzQ0MsWUFBWWgyQixNQUFNZzJCLFVBQVU7UUFDaEM7UUFDQSxPQUFPO1lBQ0hqTDtZQUNBLEdBQUk4SyxnQkFBZ0I3QyxZQUFZO1FBQ3BDO0lBQ0osR0FBRztRQUFDMXZCLEtBQUs2Z0IsTUFBTTtRQUFFN2dCLEtBQUtYLE1BQU07UUFBRVcsS0FBSzB4QixZQUFZO1FBQUUxeEIsS0FBS3d4QixZQUFZO1FBQUV4eEIsS0FBS0osUUFBUTtRQUFFSSxLQUFLeW5CLE1BQU07S0FBQyxHQUFHeHJCLG9EQUFPQTtJQUN6RyxNQUFNMDJCLGlCQUFpQmw4Qiw4Q0FBT0EsQ0FBQyxJQUFPdUosS0FBS2dyQixXQUFXLEdBQUcsQ0FBQyxNQUFNLEVBQUVoeEIsMkRBQVdBLENBQUNnRyxLQUFLZ3JCLFdBQVcsRUFBRTNzQixNQUFNLEVBQUUsQ0FBQyxHQUFHeU0sV0FBWTtRQUFDOUssS0FBS2dyQixXQUFXO1FBQUUzc0I7S0FBSztJQUNoSixNQUFNdTBCLGVBQWVuOEIsOENBQU9BLENBQUMsSUFBT3VKLEtBQUtrckIsU0FBUyxHQUFHLENBQUMsTUFBTSxFQUFFbHhCLDJEQUFXQSxDQUFDZ0csS0FBS2tyQixTQUFTLEVBQUU3c0IsTUFBTSxFQUFFLENBQUMsR0FBR3lNLFdBQVk7UUFBQzlLLEtBQUtrckIsU0FBUztRQUFFN3NCO0tBQUs7SUFDeEksSUFBSTJCLEtBQUtzbEIsTUFBTSxJQUFJK0gsWUFBWSxRQUFRQyxZQUFZLFFBQVFDLFlBQVksUUFBUUMsWUFBWSxNQUFNO1FBQzdGLE9BQU87SUFDWDtJQUNBLE1BQU1xRixjQUFjLENBQUNsdEI7UUFDakIsTUFBTSxFQUFFbXRCLGdCQUFnQixFQUFFL1gscUJBQXFCLEVBQUUxSCxvQkFBb0IsRUFBRSxHQUFHM1csTUFBTUcsUUFBUTtRQUN4RixJQUFJd2UsY0FBYztZQUNkM2UsTUFBTUksUUFBUSxDQUFDO2dCQUFFc1csc0JBQXNCO1lBQU07WUFDN0MsSUFBSXBULEtBQUtKLFFBQVEsSUFBSXlULHNCQUFzQjtnQkFDdkMwSCxzQkFBc0I7b0JBQUVwYSxPQUFPLEVBQUU7b0JBQUVDLE9BQU87d0JBQUNaO3FCQUFLO2dCQUFDO2dCQUNqRG95QixRQUFRcnZCLE9BQU8sRUFBRWlZO1lBQ3JCLE9BQ0s7Z0JBQ0Q4WCxpQkFBaUI7b0JBQUN4MEI7aUJBQUc7WUFDekI7UUFDSjtRQUNBLElBQUk2WixTQUFTO1lBQ1RBLFFBQVF4UyxPQUFPM0Y7UUFDbkI7SUFDSjtJQUNBLE1BQU0reUIsb0JBQW9Cak4sZ0JBQ3BCLENBQUNuZ0I7UUFDQ21nQixjQUFjbmdCLE9BQU87WUFBRSxHQUFHM0YsSUFBSTtRQUFDO0lBQ25DLElBQ0U4SztJQUNOLE1BQU1rb0Isb0JBQW9CM2EsZ0JBQ3BCLENBQUMxUztRQUNDMFMsY0FBYzFTLE9BQU87WUFBRSxHQUFHM0YsSUFBSTtRQUFDO0lBQ25DLElBQ0U4SztJQUNOLE1BQU1tb0IsbUJBQW1CdE4sZUFDbkIsQ0FBQ2hnQjtRQUNDZ2dCLGFBQWFoZ0IsT0FBTztZQUFFLEdBQUczRixJQUFJO1FBQUM7SUFDbEMsSUFDRThLO0lBQ04sTUFBTW9vQixrQkFBa0J0TixjQUNsQixDQUFDamdCO1FBQ0NpZ0IsWUFBWWpnQixPQUFPO1lBQUUsR0FBRzNGLElBQUk7UUFBQztJQUNqQyxJQUNFOEs7SUFDTixNQUFNcW9CLG1CQUFtQnROLGVBQ25CLENBQUNsZ0I7UUFDQ2tnQixhQUFhbGdCLE9BQU87WUFBRSxHQUFHM0YsSUFBSTtRQUFDO0lBQ2xDLElBQ0U4SztJQUNOLE1BQU1vWSxZQUFZLENBQUN2ZDtRQUNmLElBQUksQ0FBQ2xILHVCQUF1Qm5GLGdFQUFvQkEsQ0FBQ2lPLFFBQVEsQ0FBQzVCLE1BQU1rQixHQUFHLEtBQUt3VSxjQUFjO1lBQ2xGLE1BQU0sRUFBRU4scUJBQXFCLEVBQUUrWCxnQkFBZ0IsRUFBRSxHQUFHcDJCLE1BQU1HLFFBQVE7WUFDbEUsTUFBTStkLFdBQVdqVixNQUFNa0IsR0FBRyxLQUFLO1lBQy9CLElBQUkrVCxVQUFVO2dCQUNWd1gsUUFBUXJ2QixPQUFPLEVBQUVpWTtnQkFDakJELHNCQUFzQjtvQkFBRW5hLE9BQU87d0JBQUNaO3FCQUFLO2dCQUFDO1lBQzFDLE9BQ0s7Z0JBQ0Q4eUIsaUJBQWlCO29CQUFDeDBCO2lCQUFHO1lBQ3pCO1FBQ0o7SUFDSjtJQUNBLE9BQVFoSSxzREFBR0EsQ0FBQyxPQUFPO1FBQUUwRyxPQUFPO1lBQUV5cUI7UUFBTztRQUFHbHBCLFVBQVVuSSx1REFBSUEsQ0FBQyxLQUFLO1lBQUV1SSxXQUFXMUgsb0RBQUVBLENBQUM7Z0JBQ2hFO2dCQUNBLENBQUMsaUJBQWlCLEVBQUVnN0IsU0FBUyxDQUFDO2dCQUM5Qmp5QixLQUFLckIsU0FBUztnQkFDZDhEO2dCQUNBO29CQUNJN0MsVUFBVUksS0FBS0osUUFBUTtvQkFDdkJ3ekIsVUFBVXB6QixLQUFLb3pCLFFBQVE7b0JBQ3ZCQyxVQUFVLENBQUNoWSxnQkFBZ0IsQ0FBQ2xEO29CQUM1Qm1iLFVBQVVqQjtvQkFDVm5ZLFlBQVltQjtnQkFDaEI7YUFDSDtZQUFHbEQsU0FBUzBhO1lBQWEvTSxlQUFlaU47WUFBbUIxYSxlQUFlMmE7WUFBbUJyTixjQUFjc047WUFBa0JyTixhQUFhc047WUFBaUJyTixjQUFjc047WUFBa0JqUSxXQUFXb0QsY0FBY3BELFlBQVlwWTtZQUFXeVksVUFBVStDLGNBQWMsSUFBSXhiO1lBQVcrYyxNQUFNN25CLEtBQUs4bkIsUUFBUSxJQUFLeEIsQ0FBQUEsY0FBYyxVQUFVLEtBQUk7WUFBSSx3QkFBd0I7WUFBUSxXQUFXaG9CO1lBQUksZUFBZSxDQUFDLFNBQVMsRUFBRUEsR0FBRyxDQUFDO1lBQUUsY0FBYzBCLEtBQUsrbkIsU0FBUyxLQUFLLE9BQU9qZCxZQUFZOUssS0FBSytuQixTQUFTLElBQUksQ0FBQyxVQUFVLEVBQUUvbkIsS0FBSzZnQixNQUFNLENBQUMsSUFBSSxFQUFFN2dCLEtBQUtYLE1BQU0sQ0FBQyxDQUFDO1lBQUUsb0JBQW9CaW5CLGNBQWMsQ0FBQyxFQUFFem9CLG1CQUFtQixDQUFDLEVBQUVRLEtBQUssQ0FBQyxHQUFHeU07WUFBV2pNLEtBQUt1ekI7WUFBUyxHQUFHcHlCLEtBQUtnb0IsYUFBYTtZQUFFenBCLFVBQVU7Z0JBQUMsQ0FBQyt6QixnQkFBaUJoOEIsc0RBQUdBLENBQUM0N0IsZUFBZTtvQkFBRTV6QixJQUFJQTtvQkFBSXVpQixRQUFRN2dCLEtBQUs2Z0IsTUFBTTtvQkFBRXhoQixRQUFRVyxLQUFLWCxNQUFNO29CQUFFaUwsTUFBTXRLLEtBQUtzSyxJQUFJO29CQUFFMUssVUFBVUksS0FBS0osUUFBUTtvQkFBRXd6QixVQUFVcHpCLEtBQUtvekIsUUFBUTtvQkFBRWxaLFlBQVltQjtvQkFBYzhNLFdBQVdub0IsS0FBS21vQixTQUFTLElBQUk7b0JBQU0xRyxPQUFPemhCLEtBQUt5aEIsS0FBSztvQkFBRTZKLFlBQVl0ckIsS0FBS3NyQixVQUFVO29CQUFFQyxhQUFhdnJCLEtBQUt1ckIsV0FBVztvQkFBRUMsY0FBY3hyQixLQUFLd3JCLFlBQVk7b0JBQUVDLGdCQUFnQnpyQixLQUFLeXJCLGNBQWM7b0JBQUVDLHFCQUFxQjFyQixLQUFLMHJCLG1CQUFtQjtvQkFBRTJCLFNBQVNBO29CQUFTQyxTQUFTQTtvQkFBU0MsU0FBU0E7b0JBQVNDLFNBQVNBO29CQUFTak0sZ0JBQWdCQTtvQkFBZ0JJLGdCQUFnQkE7b0JBQWdCeFAsTUFBTW5TLEtBQUttUyxJQUFJO29CQUFFblYsT0FBT2dELEtBQUtoRCxLQUFLO29CQUFFdTJCLGdCQUFnQnZ6QixLQUFLMHhCLFlBQVk7b0JBQUU4QixnQkFBZ0J4ekIsS0FBS3d4QixZQUFZO29CQUFFeEcsYUFBYTJIO29CQUFnQnpILFdBQVcwSDtvQkFBY3ZFLGFBQWEsaUJBQWlCcnVCLE9BQU9BLEtBQUtxdUIsV0FBVyxHQUFHdmpCO29CQUFXMmhCLGtCQUFrQnpzQixLQUFLeXNCLGdCQUFnQjtnQkFBQztnQkFBSytELG1CQUFvQmw2QixzREFBR0EsQ0FBQ2k2QixtQkFBbUI7b0JBQUV2d0IsTUFBTUE7b0JBQU13d0IsaUJBQWlCQTtvQkFBaUJDLGlCQUFpQkE7b0JBQWlCQyxhQUFhQTtvQkFBYUMsa0JBQWtCQTtvQkFBa0JDLGdCQUFnQkE7b0JBQWdCdkQsU0FBU0E7b0JBQVNDLFNBQVNBO29CQUFTQyxTQUFTQTtvQkFBU0MsU0FBU0E7b0JBQVNqTSxnQkFBZ0JBO29CQUFnQkksZ0JBQWdCQTtvQkFBZ0JtUCxnQkFBZ0JBO29CQUFnQkQsaUJBQWlCQTtnQkFBZ0I7YUFBSTtRQUFDO0lBQUc7QUFDMzNEO0FBQ0EsSUFBSTRDLDhCQUFnQno4QiwyQ0FBSUEsQ0FBQzY2QjtBQUV6QixNQUFNNkIsYUFBYSxDQUFDMTFCLElBQU87UUFDdkI4ekIsZ0JBQWdCOXpCLEVBQUU4ekIsY0FBYztRQUNoQ0Msb0JBQW9CL3pCLEVBQUUrekIsa0JBQWtCO1FBQ3hDdnZCLG9CQUFvQnhFLEVBQUV3RSxrQkFBa0I7UUFDeEM2YSxnQkFBZ0JyZixFQUFFcWYsY0FBYztRQUNoQzVKLFNBQVN6VixFQUFFeVYsT0FBTztJQUN0QjtBQUNBLFNBQVNrZ0Isc0JBQXNCLEVBQUVDLGtCQUFrQixFQUFFckwseUJBQXlCLEVBQUVscUIsSUFBSSxFQUFFMnpCLFNBQVMsRUFBRXZ2QixjQUFjLEVBQUVpdUIsV0FBVyxFQUFFc0MsaUJBQWlCLEVBQUVDLGdCQUFnQixFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFTixXQUFXLEVBQUVwQyxlQUFlLEVBQUVzQyxpQkFBaUIsRUFBRXBDLGdCQUFnQixFQUFFQyxjQUFjLEVBQUVueUIsbUJBQW1CLEVBQUc7SUFDM1MsTUFBTSxFQUFFcXpCLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUV2dkIsa0JBQWtCLEVBQUVpUixPQUFPLEVBQUUsR0FBR2xYLFNBQVNtM0IsWUFBWXozQixvREFBT0E7SUFDeEcsTUFBTStzQixVQUFVRCxrQkFBa0JSO0lBQ2xDLE9BQVFueUIsdURBQUlBLENBQUMsT0FBTztRQUFFdUksV0FBVztRQUFxQkosVUFBVTtZQUFDakksc0RBQUdBLENBQUM4MEIscUJBQXFCO2dCQUFFUCxjQUFjK0k7Z0JBQW9CdjFCLE1BQU1BO1lBQUs7WUFBSTJxQixRQUFRem9CLEdBQUcsQ0FBQyxDQUFDakM7Z0JBQzlJLE9BQVFoSSxzREFBR0EsQ0FBQ205QixlQUFlO29CQUFFbjFCLElBQUlBO29CQUFJd3pCLGdCQUFnQkE7b0JBQWdCQyxvQkFBb0JBO29CQUFvQnZ2QixvQkFBb0JBO29CQUFvQkMsZ0JBQWdCQTtvQkFBZ0JpdUIsYUFBYUE7b0JBQWFyWSxlQUFlMmE7b0JBQW1Cck4sY0FBY3NOO29CQUFrQnJOLGFBQWFzTjtvQkFBaUJyTixjQUFjc047b0JBQWtCaGIsU0FBUzBhO29CQUFhcEMsaUJBQWlCQTtvQkFBaUIzSyxlQUFlaU47b0JBQW1CcEMsa0JBQWtCQTtvQkFBa0JDLGdCQUFnQkE7b0JBQWdCdnlCLE1BQU1BO29CQUFNb1YsU0FBU0E7b0JBQVN1ZSxXQUFXQTtvQkFBV3Z6QixxQkFBcUJBO2dCQUFvQixHQUFHSDtZQUNqbEI7U0FBRztJQUFDO0FBQ2hCO0FBQ0FxMUIsc0JBQXNCMzBCLFdBQVcsR0FBRztBQUNwQyxNQUFNNjBCLDZCQUFlNzhCLDJDQUFJQSxDQUFDMjhCO0FBRTFCLE1BQU1HLGFBQWEsQ0FBQzkxQixJQUFNLENBQUMsVUFBVSxFQUFFQSxFQUFFb0ssU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUVwSyxFQUFFb0ssU0FBUyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUVwSyxFQUFFb0ssU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDdkcsU0FBUzJyQixTQUFTLEVBQUV4MUIsUUFBUSxFQUFFO0lBQzFCLE1BQU02SixZQUFZN0wsU0FBU3UzQjtJQUMzQixPQUFReDlCLHNEQUFHQSxDQUFDLE9BQU87UUFBRXFJLFdBQVc7UUFBK0QzQixPQUFPO1lBQUVvTDtRQUFVO1FBQUc3SixVQUFVQTtJQUFTO0FBQzVJO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVN5MUIsaUJBQWlCQyxNQUFNO0lBQzVCLE1BQU1DLGFBQWExbEI7SUFDbkIsTUFBTTZXLGdCQUFnQnp1Qiw2Q0FBTUEsQ0FBQztJQUM3QkQsZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUMwdUIsY0FBY3RpQixPQUFPLElBQUlteEIsV0FBV3hsQixtQkFBbUIsSUFBSXVsQixRQUFRO1lBQ3BFRSxXQUFXLElBQU1GLE9BQU9DLGFBQWE7WUFDckM3TyxjQUFjdGlCLE9BQU8sR0FBRztRQUM1QjtJQUNKLEdBQUc7UUFBQ2t4QjtRQUFRQyxXQUFXeGxCLG1CQUFtQjtLQUFDO0FBQy9DO0FBRUEsTUFBTTBsQixhQUFhLENBQUNsWCxRQUFVQSxNQUFNeFYsT0FBTyxFQUFFMnNCO0FBQzdDOzs7OztDQUtDLEdBQ0QsU0FBU0MsZ0JBQWdCaHNCLFFBQVE7SUFDN0IsTUFBTStyQixlQUFlOTNCLFNBQVM2M0I7SUFDOUIsTUFBTTEzQixRQUFRRTtJQUNkakcsZ0RBQVNBLENBQUM7UUFDTixJQUFJMlIsVUFBVTtZQUNWK3JCLGVBQWUvckI7WUFDZjVMLE1BQU1JLFFBQVEsQ0FBQztnQkFBRXNMLFdBQVc7b0JBQUNFLFNBQVNqSCxDQUFDO29CQUFFaUgsU0FBU2hILENBQUM7b0JBQUVnSCxTQUFTL0csSUFBSTtpQkFBQztZQUFDO1FBQ3hFO0lBQ0osR0FBRztRQUFDK0c7UUFBVStyQjtLQUFhO0lBQzNCLE9BQU87QUFDWDtBQUVBLFNBQVNFLGdCQUFnQnYyQixDQUFDO0lBQ3RCLE9BQU9BLEVBQUVxVyxVQUFVLENBQUNDLFVBQVUsR0FDeEI7UUFBRSxHQUFHdFcsRUFBRXFXLFVBQVU7UUFBRW1nQixJQUFJajlCLG9FQUFvQkEsQ0FBQ3lHLEVBQUVxVyxVQUFVLENBQUNtZ0IsRUFBRSxFQUFFeDJCLEVBQUVvSyxTQUFTO0lBQUUsSUFDMUU7UUFBRSxHQUFHcEssRUFBRXFXLFVBQVU7SUFBQztBQUM1QjtBQUNBLFNBQVNvZ0IsWUFBWUMsa0JBQWtCO0lBQ25DLElBQUlBLG9CQUFvQjtRQUNwQixNQUFNQyxtQkFBbUIsQ0FBQzMyQjtZQUN0QixNQUFNcVcsYUFBYWtnQixnQkFBZ0J2MkI7WUFDbkMsT0FBTzAyQixtQkFBbUJyZ0I7UUFDOUI7UUFDQSxPQUFPc2dCO0lBQ1g7SUFDQSxPQUFPSjtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDRCxTQUFTSyxjQUFjRixrQkFBa0I7SUFDckMsTUFBTUMsbUJBQW1CRixZQUFZQztJQUNyQyxPQUFPbjRCLFNBQVNvNEIsa0JBQWtCMTRCLG9EQUFPQTtBQUM3QztBQUVBLE1BQU00NEIsYUFBYSxDQUFDNzJCLElBQU87UUFDdkIrbkIsa0JBQWtCL25CLEVBQUUrbkIsZ0JBQWdCO1FBQ3BDdkksU0FBU3hmLEVBQUVxVyxVQUFVLENBQUNtSixPQUFPO1FBQzdCbEosWUFBWXRXLEVBQUVxVyxVQUFVLENBQUNDLFVBQVU7UUFDbkNsWCxPQUFPWSxFQUFFWixLQUFLO1FBQ2RDLFFBQVFXLEVBQUVYLE1BQU07SUFDcEI7QUFDQSxTQUFTeTNCLHNCQUFzQixFQUFFaGhCLGNBQWMsRUFBRTlXLEtBQUssRUFBRXNOLElBQUksRUFBRXlxQixTQUFTLEVBQUc7SUFDdEUsTUFBTSxFQUFFaFAsZ0JBQWdCLEVBQUUzb0IsS0FBSyxFQUFFQyxNQUFNLEVBQUVtZ0IsT0FBTyxFQUFFbEosVUFBVSxFQUFFLEdBQUcvWCxTQUFTczRCLFlBQVk1NEIsb0RBQU9BO0lBQzdGLE1BQU0rNEIsbUJBQW1CLENBQUMsQ0FBRTUzQixDQUFBQSxTQUFTMm9CLG9CQUFvQnpSLFVBQVM7SUFDbEUsSUFBSSxDQUFDMGdCLGtCQUFrQjtRQUNuQixPQUFPO0lBQ1g7SUFDQSxPQUFRMStCLHNEQUFHQSxDQUFDLE9BQU87UUFBRTBHLE9BQU84VztRQUFnQjFXLE9BQU9BO1FBQU9DLFFBQVFBO1FBQVFzQixXQUFXO1FBQW9ESixVQUFVakksc0RBQUdBLENBQUMsS0FBSztZQUFFcUksV0FBVzFILG9EQUFFQSxDQUFDO2dCQUFDO2dCQUEwQmdELG1FQUFtQkEsQ0FBQ3VqQjthQUFTO1lBQUdqZixVQUFVakksc0RBQUdBLENBQUMyK0IsZ0JBQWdCO2dCQUFFajRCLE9BQU9BO2dCQUFPc04sTUFBTUE7Z0JBQU00cUIsaUJBQWlCSDtnQkFBV3ZYLFNBQVNBO1lBQVE7UUFBRztJQUFHO0FBQ3hWO0FBQ0EsTUFBTXlYLGlCQUFpQixDQUFDLEVBQUVqNEIsS0FBSyxFQUFFc04sT0FBT3BRLDhEQUFrQkEsQ0FBQ2k3QixNQUFNLEVBQUVELGVBQWUsRUFBRTFYLE9BQU8sRUFBRztJQUMxRixNQUFNLEVBQUVsSixVQUFVLEVBQUUvQixJQUFJLEVBQUU2aUIsUUFBUSxFQUFFOVgsVUFBVSxFQUFFK1gsWUFBWSxFQUFFYixFQUFFLEVBQUVjLE1BQU0sRUFBRS9YLFFBQVEsRUFBRXFELFVBQVUsRUFBRTJVLE9BQU8sRUFBRSxHQUFHWDtJQUM1RyxJQUFJLENBQUN0Z0IsWUFBWTtRQUNiO0lBQ0o7SUFDQSxJQUFJNGdCLGlCQUFpQjtRQUNqQixPQUFRNStCLHNEQUFHQSxDQUFDNCtCLGlCQUFpQjtZQUFFTSxvQkFBb0JsckI7WUFBTW1yQixxQkFBcUJ6NEI7WUFBT280QixVQUFVQTtZQUFVOVgsWUFBWUE7WUFBWW9ZLE9BQU9uakIsS0FBS2xSLENBQUM7WUFBRXMwQixPQUFPcGpCLEtBQUtqUixDQUFDO1lBQUVzMEIsS0FBS3BCLEdBQUduekIsQ0FBQztZQUFFdzBCLEtBQUtyQixHQUFHbHpCLENBQUM7WUFBRSt6QixjQUFjQTtZQUFjelUsWUFBWUE7WUFBWWtWLGtCQUFrQjc3QixtRUFBbUJBLENBQUN1akI7WUFBVThYLFFBQVFBO1lBQVEvWCxVQUFVQTtZQUFVZ1ksU0FBU0E7UUFBUTtJQUNsVjtJQUNBLElBQUlqSixPQUFPO0lBQ1gsTUFBTXlKLGFBQWE7UUFDZjFJLFNBQVM5YSxLQUFLbFIsQ0FBQztRQUNmaXNCLFNBQVMvYSxLQUFLalIsQ0FBQztRQUNmaWdCLGdCQUFnQjhUO1FBQ2hCOUgsU0FBU2lILEdBQUduekIsQ0FBQztRQUNibXNCLFNBQVNnSCxHQUFHbHpCLENBQUM7UUFDYnFnQixnQkFBZ0JmO0lBQ3BCO0lBQ0EsT0FBUXRXO1FBQ0osS0FBS3BRLDhEQUFrQkEsQ0FBQ2k3QixNQUFNO1lBQzFCLENBQUM3SSxLQUFLLEdBQUd6eUIsNkRBQWFBLENBQUNrOEI7WUFDdkI7UUFDSixLQUFLNzdCLDhEQUFrQkEsQ0FBQzg3QixZQUFZO1lBQ2hDLENBQUMxSixLQUFLLEdBQUdjLG9CQUFvQjJJO1lBQzdCO1FBQ0osS0FBSzc3Qiw4REFBa0JBLENBQUMrN0IsSUFBSTtZQUN4QixDQUFDM0osS0FBSyxHQUFHM3lCLGlFQUFpQkEsQ0FBQztnQkFDdkIsR0FBR284QixVQUFVO2dCQUNiekgsY0FBYztZQUNsQjtZQUNBO1FBQ0osS0FBS3AwQiw4REFBa0JBLENBQUNnOEIsVUFBVTtZQUM5QixDQUFDNUosS0FBSyxHQUFHM3lCLGlFQUFpQkEsQ0FBQ284QjtZQUMzQjtRQUNKO1lBQ0ksQ0FBQ3pKLEtBQUssR0FBRzF5QiwrREFBZUEsQ0FBQ204QjtJQUNqQztJQUNBLE9BQU96L0Isc0RBQUdBLENBQUMsUUFBUTtRQUFFbzJCLEdBQUdKO1FBQU03QyxNQUFNO1FBQVE5cUIsV0FBVztRQUErQjNCLE9BQU9BO0lBQU07QUFDdkc7QUFDQWk0QixlQUFlajJCLFdBQVcsR0FBRztBQUU3QixNQUFNbTNCLGFBQWEsQ0FBQztBQUNwQiw4REFBOEQ7QUFDOUQsU0FBU0MsMEJBQTBCQyxrQkFBa0JGLFVBQVU7SUFDM0QsTUFBTUcsV0FBVzEvQiw2Q0FBTUEsQ0FBQ3kvQjtJQUN4QixNQUFNMzVCLFFBQVFFO0lBQ2RqRyxnREFBU0EsQ0FBQztRQUNOLElBQUk0L0IsSUFBeUIsRUFBZTtZQUN4QyxNQUFNQyxXQUFXLElBQUk3eEIsSUFBSTttQkFBSXdlLE9BQU9sZSxJQUFJLENBQUNxeEIsU0FBU3Z6QixPQUFPO21CQUFNb2dCLE9BQU9sZSxJQUFJLENBQUNveEI7YUFBaUI7WUFDNUYsS0FBSyxNQUFNeHZCLE9BQU8ydkIsU0FBVTtnQkFDeEIsSUFBSUYsU0FBU3Z6QixPQUFPLENBQUM4RCxJQUFJLEtBQUt3dkIsZUFBZSxDQUFDeHZCLElBQUksRUFBRTtvQkFDaERuSyxNQUFNRyxRQUFRLEdBQUc0VyxPQUFPLEdBQUcsT0FBT3ZjLHlEQUFhLENBQUMsV0FBVztvQkFDM0Q7Z0JBQ0o7WUFDSjtZQUNBby9CLFNBQVN2ekIsT0FBTyxHQUFHc3pCO1FBQ3ZCO0lBQ0osR0FBRztRQUFDQTtLQUFnQjtBQUN4QjtBQUVBLFNBQVNJO0lBQ0wsTUFBTS81QixRQUFRRTtJQUNkLE1BQU04NUIsVUFBVTkvQiw2Q0FBTUEsQ0FBQztJQUN2QkQsZ0RBQVNBLENBQUM7UUFDTixJQUFJNC9CLElBQXlCLEVBQWU7WUFDeEMsSUFBSSxDQUFDRyxRQUFRM3pCLE9BQU8sRUFBRTtnQkFDbEIsTUFBTTR6QixPQUFPenlCLFNBQVMweUIsYUFBYSxDQUFDO2dCQUNwQyxJQUFJRCxRQUFRLENBQUVyekIsQ0FBQUEsT0FBT3V6QixnQkFBZ0IsQ0FBQ0YsTUFBTWxQLE1BQU0sS0FBSyxHQUFFLEdBQUk7b0JBQ3pEL3FCLE1BQU1HLFFBQVEsR0FBRzRXLE9BQU8sR0FBRyxPQUFPdmMseURBQWEsQ0FBQyxXQUFXLENBQUM7Z0JBQ2hFO2dCQUNBdy9CLFFBQVEzekIsT0FBTyxHQUFHO1lBQ3RCO1FBQ0o7SUFDSixHQUFHLEVBQUU7QUFDVDtBQUVBLFNBQVMrekIsbUJBQW1CLEVBQUU3USxTQUFTLEVBQUUrTCxTQUFTLEVBQUVpQyxNQUFNLEVBQUV6TCxXQUFXLEVBQUVxSyxXQUFXLEVBQUVoSyxpQkFBaUIsRUFBRWtLLGlCQUFpQixFQUFFdEssZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVDLGlCQUFpQixFQUFFN0Ysc0JBQXNCLEVBQUV6TCxnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFaWUsa0JBQWtCLEVBQUVDLG1CQUFtQixFQUFFc0IsdUJBQXVCLEVBQUVDLDRCQUE0QixFQUFFclQsZ0JBQWdCLEVBQUVwTyxlQUFlLEVBQUU2QixhQUFhLEVBQUVuRSxxQkFBcUIsRUFBRTJRLG9CQUFvQixFQUFFM08scUJBQXFCLEVBQUVqQyxhQUFhLEVBQUV1Vix5QkFBeUIsRUFBRS9sQixrQkFBa0IsRUFBRXBCLGVBQWUsRUFBRWdCLGVBQWUsRUFBRUUsT0FBTyxFQUFFQyxPQUFPLEVBQUUyUyxnQkFBZ0IsRUFBRTBlLGtCQUFrQixFQUFFbmYsWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUUsaUJBQWlCLEVBQUVDLFNBQVMsRUFBRXdDLFdBQVcsRUFBRUUsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVILFlBQVksRUFBRWpELGlCQUFpQixFQUFFYyxpQkFBaUIsRUFBRWdHLGlCQUFpQixFQUFFMFgsaUJBQWlCLEVBQUVDLGdCQUFnQixFQUFFQyxlQUFlLEVBQUVDLGdCQUFnQixFQUFFMUMsZUFBZSxFQUFFQyxXQUFXLEVBQUVDLGdCQUFnQixFQUFFQyxjQUFjLEVBQUV6VixlQUFlLEVBQUVoRyxnQkFBZ0IsRUFBRTFTLGNBQWMsRUFBRWhFLG1CQUFtQixFQUFFd2QsVUFBVSxFQUFFNWQsSUFBSSxFQUFFaUssUUFBUSxFQUFFOE0sZ0JBQWdCLEVBQUc7SUFDemxDZ2hCLDBCQUEwQm5RO0lBQzFCbVEsMEJBQTBCcEU7SUFDMUJ5RTtJQUNBekMsaUJBQWlCQztJQUNqQkssZ0JBQWdCaHNCO0lBQ2hCLE9BQVFoUyxzREFBR0EsQ0FBQzJ0QixjQUFjO1FBQUV6TSxhQUFhQTtRQUFhRSxrQkFBa0JBO1FBQWtCQyxpQkFBaUJBO1FBQWlCQyxrQkFBa0JBO1FBQWtCcEQsbUJBQW1CQTtRQUFtQmlELGNBQWNBO1FBQWNuQyxtQkFBbUJBO1FBQW1CdEMsZUFBZUE7UUFBZTJRLGtCQUFrQkE7UUFBa0JwTyxpQkFBaUJBO1FBQWlCNkIsZUFBZUE7UUFBZUUsa0JBQWtCQTtRQUFrQkMsZ0JBQWdCQTtRQUFnQnRFLHVCQUF1QkE7UUFBdUIyUSxzQkFBc0JBO1FBQXNCM08sdUJBQXVCQTtRQUF1QnpTLG9CQUFvQkE7UUFBb0JpUyxjQUFjQTtRQUFjQyxhQUFhQTtRQUFhSyxtQkFBbUJBO1FBQW1CSixhQUFhQTtRQUFhQyxrQkFBa0JBO1FBQWtCQyxpQkFBaUJBO1FBQWlCRyxXQUFXQTtRQUFXNVQsaUJBQWlCQTtRQUFpQmdCLGlCQUFpQkE7UUFBaUJFLFNBQVNBO1FBQVNDLFNBQVNBO1FBQVN3Z0Isd0JBQXdCQTtRQUF3QjdOLGtCQUFrQkE7UUFBa0JpRyxpQkFBaUJBO1FBQWlCaEcsa0JBQWtCQTtRQUFrQjFTLGdCQUFnQkE7UUFBZ0JoRSxxQkFBcUJBO1FBQXFCMlcsa0JBQWtCQTtRQUFrQkMsc0JBQXNCLENBQUMsQ0FBQy9NO1FBQVUvSixVQUFVbkksdURBQUlBLENBQUMyOUIsVUFBVTtZQUFFeDFCLFVBQVU7Z0JBQUNqSSxzREFBR0EsQ0FBQ3U5QixjQUFjO29CQUFFN0IsV0FBV0E7b0JBQVdhLGFBQWFBO29CQUFhRSxtQkFBbUJBO29CQUFtQnJDLGFBQWFBO29CQUFhQyxrQkFBa0JBO29CQUFrQkMsZ0JBQWdCQTtvQkFBZ0JySSwyQkFBMkJBO29CQUEyQnlLLG1CQUFtQkE7b0JBQW1CQyxrQkFBa0JBO29CQUFrQkMsaUJBQWlCQTtvQkFBaUJDLGtCQUFrQkE7b0JBQWtCMUMsaUJBQWlCQTtvQkFBaUJtRCxvQkFBb0JBO29CQUFvQm54QixnQkFBZ0JBO29CQUFnQmhFLHFCQUFxQkE7b0JBQXFCSixNQUFNQTtnQkFBSztnQkFBSS9ILHNEQUFHQSxDQUFDdytCLHVCQUF1QjtvQkFBRTkzQixPQUFPeTRCO29CQUFxQm5yQixNQUFNa3JCO29CQUFvQlQsV0FBV2dDO29CQUF5QmpqQixnQkFBZ0JrakI7Z0JBQTZCO2dCQUFJMWdDLHNEQUFHQSxDQUFDLE9BQU87b0JBQUVxSSxXQUFXO2dCQUFpQztnQkFBSXJJLHNEQUFHQSxDQUFDd3lCLGNBQWM7b0JBQUU3QyxXQUFXQTtvQkFBV3VDLGFBQWFBO29CQUFhSyxtQkFBbUJBO29CQUFtQkosa0JBQWtCQTtvQkFBa0JDLGlCQUFpQkE7b0JBQWlCQyxrQkFBa0JBO29CQUFrQkMsbUJBQW1CQTtvQkFBbUJ0TixtQkFBbUJBO29CQUFtQmlOLDJCQUEyQkE7b0JBQTJCOWxCLGdCQUFnQkE7b0JBQWdCMFksaUJBQWlCQTtvQkFBaUIxYyxxQkFBcUJBO29CQUFxQndkLFlBQVlBO29CQUFZNWQsTUFBTUE7Z0JBQUs7Z0JBQUkvSCxzREFBR0EsQ0FBQyxPQUFPO29CQUFFcUksV0FBVztnQkFBOEI7YUFBRztRQUFDO0lBQUc7QUFDeGtGO0FBQ0FtNEIsbUJBQW1COTNCLFdBQVcsR0FBRztBQUNqQyxNQUFNaTRCLDBCQUFZamdDLDJDQUFJQSxDQUFDOC9CO0FBRXZCLE1BQU1JLGtCQUFrQixDQUFDLEVBQUV2MkIsS0FBSyxFQUFFQyxLQUFLLEVBQUVnQyxZQUFZLEVBQUVDLFlBQVksRUFBRXpGLEtBQUssRUFBRUMsTUFBTSxFQUFFc1YsT0FBTyxFQUFFdlAsY0FBYyxFQUFFZCxVQUFVLEdBQUcsRUFBRUMsVUFBVSxDQUFDLEVBQUVGLFVBQVUsRUFBRTRaLFVBQVUsRUFBRXlXLGFBQWEsT0FBTyxFQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3pMLE1BQU0veUIsYUFBYSxJQUFJd0s7SUFDdkIsTUFBTWdjLGVBQWUsSUFBSWhjO0lBQ3pCLE1BQU1xSSxtQkFBbUIsSUFBSXJJO0lBQzdCLE1BQU1sSyxhQUFhLElBQUlrSztJQUN2QixNQUFNZ3RCLGFBQWF0MEIsZ0JBQWdCakMsU0FBUyxFQUFFO0lBQzlDLE1BQU13MkIsYUFBYXgwQixnQkFBZ0JqQyxTQUFTLEVBQUU7SUFDOUMsTUFBTTAyQixrQkFBa0JoMUIsY0FBYztRQUFDO1FBQUc7S0FBRTtJQUM1QyxNQUFNaTFCLGtCQUFrQnJiLGNBQWM3a0IsMERBQWNBO0lBQ3BEK0Msc0VBQXNCQSxDQUFDcVksa0JBQWtCdlMsWUFBWWszQjtJQUNyRCxNQUFNSSxtQkFBbUJuOUIsOERBQWNBLENBQUNnOUIsWUFBWXozQixZQUFZd21CLGNBQWM7UUFDMUU5akIsWUFBWWcxQjtRQUNacGIsWUFBWXFiO1FBQ1o1RTtJQUNKO0lBQ0EsSUFBSXRxQixZQUFZO1FBQUM7UUFBRztRQUFHO0tBQUU7SUFDekIsSUFBSXVLLFdBQVd2VixTQUFTQyxRQUFRO1FBQzVCLE1BQU13TCxTQUFTM1Asc0VBQXNCQSxDQUFDeUcsWUFBWTtZQUM5Q3VGLFFBQVEsQ0FBQ3hGLE9BQVMsQ0FBQyxDQUFFLEVBQUNBLEtBQUt0QyxLQUFLLElBQUlzQyxLQUFLZ2pCLFlBQVksS0FBTWhqQixDQUFBQSxLQUFLckMsTUFBTSxJQUFJcUMsS0FBS2lqQixhQUFhO1FBQ2hHO1FBQ0EsTUFBTSxFQUFFdGhCLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxJQUFJLEVBQUUsR0FBR2pLLG9FQUFvQkEsQ0FBQ3VSLFFBQVF6TCxPQUFPQyxRQUFRaUYsU0FBU0MsU0FBU2EsZ0JBQWdCNUYsV0FBVztRQUNoSDRLLFlBQVk7WUFBQy9HO1lBQUdDO1lBQUdDO1NBQUs7SUFDNUI7SUFDQSxPQUFPO1FBQ0hsRCxNQUFNO1FBQ05qQixPQUFPQSxTQUFTO1FBQ2hCQyxRQUFRQSxVQUFVO1FBQ2xCK0s7UUFDQXpILE9BQU95MkI7UUFDUEc7UUFDQTUzQjtRQUNBd21CO1FBQ0F2bEIsT0FBT3UyQjtRQUNQbDNCO1FBQ0F1UztRQUNBaEYsZUFBZTtRQUNmVSxlQUFlO1FBQ2ZYLGlCQUFpQjNLLGlCQUFpQmtJO1FBQ2xDbUQsaUJBQWlCcEwsaUJBQWlCaUk7UUFDbENwRCxTQUFTO1FBQ1RwRjtRQUNBQztRQUNBSCxpQkFBaUJoTCwwREFBY0E7UUFDL0I2a0IsWUFBWXFiO1FBQ1psa0Isc0JBQXNCO1FBQ3RCYyxxQkFBcUI7UUFDckJ3QyxtQkFBbUI7UUFDbkIyRyxnQkFBZ0J4a0IsMERBQWNBLENBQUNnbEIsTUFBTTtRQUNyQ3pVLFNBQVM7UUFDVHdNLGNBQWM7UUFDZG5ULGdCQUFnQjtRQUNoQkosWUFBWWcxQjtRQUNabFEsbUJBQW1CO1FBQ25CckgseUJBQXlCO1FBQ3pCNVcsVUFBVTtZQUFDO1lBQUk7U0FBRztRQUNsQkMsWUFBWTtRQUNaMlMsZ0JBQWdCO1FBQ2hCaUssa0JBQWtCO1FBQ2xCQyxnQkFBZ0I7UUFDaEI4TCxnQkFBZ0I7UUFDaEJDLG9CQUFvQjtRQUNwQnZ2QixvQkFBb0I7UUFDcEJnMUIsc0JBQXNCO1FBQ3RCL0Usc0JBQXNCO1FBQ3RCdkwsbUJBQW1CO1FBQ25CN1Qsc0JBQXNCO1FBQ3RCbFEsZUFBZXdQLFdBQVc7UUFDMUJ2UDtRQUNBd1AsaUJBQWlCO1FBQ2pCeUIsWUFBWTtZQUFFLEdBQUdoYSw2REFBaUI7UUFBQztRQUNuQzhpQiw0QkFBNEI7UUFDNUJILGdCQUFnQjtRQUNoQi9lLGlCQUFpQjtRQUNqQmtoQixrQkFBa0I7UUFDbEJzWSxtQkFBbUI7UUFDbkJuUSxvQkFBb0I7UUFDcEIxSCxjQUFjO1FBQ2RSLGtCQUFrQjtRQUNsQjNMLFNBQVNuWixtREFBT0E7UUFDaEI2akIsbUJBQW1CclQ7UUFDbkJqSywyQkFBMkIsRUFBRTtRQUM3QnNULEtBQUs7UUFDTHVqQixPQUFPO1FBQ1B2NUIsaUJBQWlCNUQsa0VBQXNCQTtRQUN2Q200QjtRQUNBamxCLDRCQUE0QixJQUFJdEQ7UUFDaEN3dEIsNEJBQTRCLElBQUl4dEI7SUFDcEM7QUFDSjtBQUVBLE1BQU15dEIsY0FBYyxDQUFDLEVBQUVqM0IsS0FBSyxFQUFFQyxLQUFLLEVBQUVnQyxZQUFZLEVBQUVDLFlBQVksRUFBRXpGLEtBQUssRUFBRUMsTUFBTSxFQUFFc1YsT0FBTyxFQUFFdlAsY0FBYyxFQUFFZCxPQUFPLEVBQUVDLE9BQU8sRUFBRUYsVUFBVSxFQUFFNFosVUFBVSxFQUFFeVcsVUFBVSxFQUFHLEdBQUsxMkIseUVBQW9CQSxDQUFDLENBQUN1TyxLQUFLRTtRQUM1TCxlQUFlb3RCO1lBQ1gsTUFBTSxFQUFFbDRCLFVBQVUsRUFBRStILE9BQU8sRUFBRXRFLGNBQWMsRUFBRXdQLGVBQWUsRUFBRXhWLEtBQUssRUFBRUMsTUFBTSxFQUFFaUYsT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBR2tJO1lBQ2xHLElBQUksQ0FBQy9DLFNBQVM7Z0JBQ1Y7WUFDSjtZQUNBLE1BQU03TSwyREFBV0EsQ0FBQztnQkFDZDhGLE9BQU9oQjtnQkFDUHZDO2dCQUNBQztnQkFDQXFLO2dCQUNBcEY7Z0JBQ0FDO1lBQ0osR0FBR2E7WUFDSHdQLGlCQUFpQjlLLFFBQVE7WUFDekI7OztTQUdDLEdBQ0R5QyxJQUFJO2dCQUFFcUksaUJBQWlCO1lBQUs7UUFDaEM7UUFDQSxPQUFPO1lBQ0gsR0FBR3NrQixnQkFBZ0I7Z0JBQ2Z2MkI7Z0JBQ0FDO2dCQUNBeEQ7Z0JBQ0FDO2dCQUNBc1Y7Z0JBQ0F2UDtnQkFDQWQ7Z0JBQ0FDO2dCQUNBRjtnQkFDQTRaO2dCQUNBclo7Z0JBQ0FDO2dCQUNBNnZCO1lBQ0osRUFBRTtZQUNGL3dCLFVBQVUsQ0FBQ2hCO2dCQUNQLE1BQU0sRUFBRWhCLFVBQVUsRUFBRXdtQixZQUFZLEVBQUU5akIsVUFBVSxFQUFFbTFCLG9CQUFvQixFQUFFcjBCLGFBQWEsRUFBRXV2QixVQUFVLEVBQUUsR0FBR2pvQjtnQkFDbEc7Ozs7Ozs7YUFPQyxHQUNELE1BQU04c0IsbUJBQW1CbjlCLDhEQUFjQSxDQUFDdUcsT0FBT2hCLFlBQVl3bUIsY0FBYztvQkFDckU5akI7b0JBQ0E0WjtvQkFDQXViO29CQUNBTSxlQUFlO29CQUNmcEY7Z0JBQ0o7Z0JBQ0EsSUFBSXZ2QixpQkFBaUJvMEIsa0JBQWtCO29CQUNuQ007b0JBQ0F0dEIsSUFBSTt3QkFBRTVKO3dCQUFPNDJCO3dCQUFrQnAwQixlQUFlO3dCQUFPQyxnQkFBZ0IwSDtvQkFBVTtnQkFDbkYsT0FDSztvQkFDRFAsSUFBSTt3QkFBRTVKO3dCQUFPNDJCO29CQUFpQjtnQkFDbEM7WUFDSjtZQUNBMzFCLFVBQVUsQ0FBQ2hCO2dCQUNQLE1BQU0sRUFBRTRSLGdCQUFnQixFQUFFdlMsVUFBVSxFQUFFLEdBQUd3SztnQkFDekN0USxzRUFBc0JBLENBQUNxWSxrQkFBa0J2UyxZQUFZVztnQkFDckQySixJQUFJO29CQUFFM0o7Z0JBQU07WUFDaEI7WUFDQXNCLHlCQUF5QixDQUFDdkIsT0FBT0M7Z0JBQzdCLElBQUlELE9BQU87b0JBQ1AsTUFBTSxFQUFFZ0IsUUFBUSxFQUFFLEdBQUc4STtvQkFDckI5SSxTQUFTaEI7b0JBQ1Q0SixJQUFJO3dCQUFFZ0QsaUJBQWlCO29CQUFLO2dCQUNoQztnQkFDQSxJQUFJM00sT0FBTztvQkFDUCxNQUFNLEVBQUVnQixRQUFRLEVBQUUsR0FBRzZJO29CQUNyQjdJLFNBQVNoQjtvQkFDVDJKLElBQUk7d0JBQUUwRCxpQkFBaUI7b0JBQUs7Z0JBQ2hDO1lBQ0o7WUFDQTs7OztTQUlDLEdBQ0R6VCxxQkFBcUIsQ0FBQ2dxQjtnQkFDbEIsTUFBTSxFQUFFalUsa0JBQWtCLEVBQUU1USxVQUFVLEVBQUV3bUIsWUFBWSxFQUFFL2MsT0FBTyxFQUFFL0csVUFBVSxFQUFFNFosVUFBVSxFQUFFeWIsS0FBSyxFQUFFdjBCLGFBQWEsRUFBRXV2QixVQUFVLEVBQUcsR0FBR2pvQjtnQkFDN0gsTUFBTSxFQUFFVixPQUFPLEVBQUVndUIsZ0JBQWdCLEVBQUUsR0FBR3Y5QixtRUFBbUJBLENBQUNncUIsU0FBUzdrQixZQUFZd21CLGNBQWMvYyxTQUFTL0csWUFBWTRaLFlBQVl5VztnQkFDOUgsSUFBSSxDQUFDcUYsa0JBQWtCO29CQUNuQjtnQkFDSjtnQkFDQXQ5Qix1RUFBdUJBLENBQUNrRixZQUFZd21CLGNBQWM7b0JBQUU5akI7b0JBQVk0WjtvQkFBWXlXO2dCQUFXO2dCQUN2RixJQUFJdnZCLGVBQWU7b0JBQ2YwMEI7b0JBQ0F0dEIsSUFBSTt3QkFBRXBILGVBQWU7d0JBQU9DLGdCQUFnQjBIO29CQUFVO2dCQUMxRCxPQUNLO29CQUNELGtGQUFrRjtvQkFDbEZQLElBQUksQ0FBQztnQkFDVDtnQkFDQSxJQUFJUixTQUFTL0MsU0FBUyxHQUFHO29CQUNyQixJQUFJMHdCLE9BQU87d0JBQ1BNLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0NsdUI7b0JBQ3BEO29CQUNBd0cscUJBQXFCeEc7Z0JBQ3pCO1lBQ0o7WUFDQW1TLHFCQUFxQixDQUFDZ2MsZUFBZWx0QixXQUFXLEtBQUs7Z0JBQ2pELE1BQU1tdEIsdUJBQXVCLEVBQUU7Z0JBQy9CLElBQUlwdUIsVUFBVSxFQUFFO2dCQUNoQixNQUFNLEVBQUVwSyxVQUFVLEVBQUU0USxrQkFBa0IsRUFBRThELFVBQVUsRUFBRW9MLGdCQUFnQixFQUFFaFMsMEJBQTBCLEVBQUUsR0FBR2hEO2dCQUNyRyxLQUFLLE1BQU0sQ0FBQ25NLElBQUk4NUIsU0FBUyxJQUFJRixjQUFlO29CQUN4Qyw0RkFBNEY7b0JBQzVGLE1BQU14NEIsT0FBT0MsV0FBVzhLLEdBQUcsQ0FBQ25NO29CQUM1QixNQUFNKzVCLGVBQWUsQ0FBQyxDQUFFMzRCLENBQUFBLE1BQU0yNEIsZ0JBQWdCMzRCLE1BQU1xUCxZQUFZcXBCLFVBQVVqN0IsUUFBTztvQkFDakYsTUFBTWtOLFNBQVM7d0JBQ1gvTDt3QkFDQWdNLE1BQU07d0JBQ05uTixVQUFVazdCLGVBQ0o7NEJBQ0VoM0IsR0FBR3FZLEtBQUs0ZSxHQUFHLENBQUMsR0FBR0YsU0FBU2o3QixRQUFRLENBQUNrRSxDQUFDOzRCQUNsQ0MsR0FBR29ZLEtBQUs0ZSxHQUFHLENBQUMsR0FBR0YsU0FBU2o3QixRQUFRLENBQUNtRSxDQUFDO3dCQUN0QyxJQUNFODJCLFNBQVNqN0IsUUFBUTt3QkFDdkI2TjtvQkFDSjtvQkFDQSxJQUFJdEwsUUFBUTJVLFdBQVdDLFVBQVUsSUFBSUQsV0FBVytnQixRQUFRLENBQUM5MkIsRUFBRSxLQUFLb0IsS0FBS3BCLEVBQUUsRUFBRTt3QkFDckUsTUFBTWk2QixjQUFjNzlCLGlFQUFpQkEsQ0FBQ2dGLE1BQU0yVSxXQUFXaUosVUFBVSxFQUFFMWtCLG9EQUFRQSxDQUFDczBCLElBQUksRUFBRTt3QkFDbEZ6TixpQkFBaUI7NEJBQUUsR0FBR3BMLFVBQVU7NEJBQUU5QixNQUFNZ21CO3dCQUFZO29CQUN4RDtvQkFDQSxJQUFJRixnQkFBZ0IzNEIsS0FBS3FQLFFBQVEsRUFBRTt3QkFDL0JvcEIscUJBQXFCdDRCLElBQUksQ0FBQzs0QkFDdEJ2Qjs0QkFDQXlRLFVBQVVyUCxLQUFLcVAsUUFBUTs0QkFDdkJ5cEIsTUFBTTtnQ0FDRixHQUFHSixTQUFTdDRCLFNBQVMsQ0FBQzRSLGdCQUFnQjtnQ0FDdEN0VSxPQUFPZzdCLFNBQVNsdEIsUUFBUSxDQUFDOU4sS0FBSyxJQUFJO2dDQUNsQ0MsUUFBUSs2QixTQUFTbHRCLFFBQVEsQ0FBQzdOLE1BQU0sSUFBSTs0QkFDeEM7d0JBQ0o7b0JBQ0o7b0JBQ0EwTSxRQUFRbEssSUFBSSxDQUFDd0s7Z0JBQ2pCO2dCQUNBLElBQUk4dEIscUJBQXFCbnhCLE1BQU0sR0FBRyxHQUFHO29CQUNqQyxNQUFNLEVBQUVtZixZQUFZLEVBQUU5akIsVUFBVSxFQUFFLEdBQUdvSTtvQkFDckMsTUFBTWd1QixzQkFBc0I5OUIsa0VBQWtCQSxDQUFDdzlCLHNCQUFzQng0QixZQUFZd21CLGNBQWM5akI7b0JBQy9GMEgsUUFBUWxLLElBQUksSUFBSTQ0QjtnQkFDcEI7Z0JBQ0EsS0FBSyxNQUFNN3FCLGNBQWNILDJCQUEyQkksTUFBTSxHQUFJO29CQUMxRDlELFVBQVU2RCxXQUFXN0Q7Z0JBQ3pCO2dCQUNBd0csbUJBQW1CeEc7WUFDdkI7WUFDQXdHLG9CQUFvQixDQUFDeEc7Z0JBQ2pCLE1BQU0sRUFBRXlELGFBQWEsRUFBRTdMLFFBQVEsRUFBRWhCLEtBQUssRUFBRTRNLGVBQWUsRUFBRW1xQixLQUFLLEVBQUUsR0FBR2p0QjtnQkFDbkUsSUFBSVYsU0FBUy9DLFFBQVE7b0JBQ2pCLElBQUl1RyxpQkFBaUI7d0JBQ2pCLE1BQU1tckIsZUFBZXJ0QixpQkFBaUJ0QixTQUFTcEo7d0JBQy9DZ0IsU0FBUysyQjtvQkFDYjtvQkFDQSxJQUFJaEIsT0FBTzt3QkFDUE0sUUFBUUMsR0FBRyxDQUFDLG9DQUFvQ2x1QjtvQkFDcEQ7b0JBQ0F5RCxnQkFBZ0J6RDtnQkFDcEI7WUFDSjtZQUNBeUcsb0JBQW9CLENBQUN6RztnQkFDakIsTUFBTSxFQUFFbUUsYUFBYSxFQUFFdE0sUUFBUSxFQUFFaEIsS0FBSyxFQUFFcU4sZUFBZSxFQUFFeXBCLEtBQUssRUFBRSxHQUFHanRCO2dCQUNuRSxJQUFJVixTQUFTL0MsUUFBUTtvQkFDakIsSUFBSWlILGlCQUFpQjt3QkFDakIsTUFBTTBxQixlQUFlcnRCLGlCQUFpQnZCLFNBQVNuSjt3QkFDL0NnQixTQUFTKzJCO29CQUNiO29CQUNBLElBQUlqQixPQUFPO3dCQUNQTSxRQUFRQyxHQUFHLENBQUMsb0NBQW9DbHVCO29CQUNwRDtvQkFDQW1FLGdCQUFnQm5FO2dCQUNwQjtZQUNKO1lBQ0ErUSxrQkFBa0IsQ0FBQzlDO2dCQUNmLE1BQU0sRUFBRTNFLG9CQUFvQixFQUFFcFQsVUFBVSxFQUFFTixVQUFVLEVBQUU0USxrQkFBa0IsRUFBRUMsa0JBQWtCLEVBQUUsR0FBRy9GO2dCQUNqRyxJQUFJNEksc0JBQXNCO29CQUN0QixNQUFNckMsY0FBY2dILGdCQUFnQnpYLEdBQUcsQ0FBQyxDQUFDK1IsU0FBVy9HLHNCQUFzQitHLFFBQVE7b0JBQ2xGL0IsbUJBQW1CUztvQkFDbkI7Z0JBQ0o7Z0JBQ0FULG1CQUFtQi9FLG9CQUFvQjdMLFlBQVksSUFBSWdGLElBQUk7dUJBQUlxVDtpQkFBZ0IsR0FBRztnQkFDbEZ4SCxtQkFBbUJoRixvQkFBb0J2TDtZQUMzQztZQUNBNnlCLGtCQUFrQixDQUFDN2E7Z0JBQ2YsTUFBTSxFQUFFNUUsb0JBQW9CLEVBQUVwVCxVQUFVLEVBQUVOLFVBQVUsRUFBRTRRLGtCQUFrQixFQUFFQyxrQkFBa0IsRUFBRSxHQUFHL0Y7Z0JBQ2pHLElBQUk0SSxzQkFBc0I7b0JBQ3RCLE1BQU11bEIsZUFBZTNnQixnQkFBZ0IxWCxHQUFHLENBQUMsQ0FBQzZaLFNBQVc3TyxzQkFBc0I2TyxRQUFRO29CQUNuRjVKLG1CQUFtQm9vQjtvQkFDbkI7Z0JBQ0o7Z0JBQ0Fwb0IsbUJBQW1CaEYsb0JBQW9CdkwsWUFBWSxJQUFJMEUsSUFBSTt1QkFBSXNUO2lCQUFnQjtnQkFDL0UxSCxtQkFBbUIvRSxvQkFBb0I3TCxZQUFZLElBQUlnRixPQUFPO1lBQ2xFO1lBQ0FvVyx1QkFBdUIsQ0FBQyxFQUFFcGEsS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ3pDLE1BQU0sRUFBRUEsT0FBT3UyQixVQUFVLEVBQUV4MkIsT0FBT3kyQixVQUFVLEVBQUV6M0IsVUFBVSxFQUFFNFEsa0JBQWtCLEVBQUVDLGtCQUFrQixFQUFFLEdBQUcvRjtnQkFDckcsTUFBTW91QixrQkFBa0JsNEIsUUFBUUEsUUFBUXkyQjtnQkFDeEMsTUFBTTBCLGtCQUFrQmw0QixRQUFRQSxRQUFRdTJCO2dCQUN4QyxNQUFNbm1CLGNBQWM2bkIsZ0JBQWdCdDRCLEdBQUcsQ0FBQyxDQUFDME07b0JBQ3JDLE1BQU13RSxlQUFlOVIsV0FBVzhLLEdBQUcsQ0FBQ3dDLEVBQUUzTyxFQUFFO29CQUN4QyxJQUFJbVQsY0FBYzt3QkFDZDs7O3FCQUdDLEdBQ0RBLGFBQWE3UixRQUFRLEdBQUc7b0JBQzVCO29CQUNBLE9BQU8yTCxzQkFBc0IwQixFQUFFM08sRUFBRSxFQUFFO2dCQUN2QztnQkFDQSxNQUFNeVMsY0FBYytuQixnQkFBZ0J2NEIsR0FBRyxDQUFDLENBQUNQLE9BQVN1TCxzQkFBc0J2TCxLQUFLMUIsRUFBRSxFQUFFO2dCQUNqRmlTLG1CQUFtQlM7Z0JBQ25CUixtQkFBbUJPO1lBQ3ZCO1lBQ0FsUCxZQUFZLENBQUNTO2dCQUNULE1BQU0sRUFBRW9GLE9BQU8sRUFBRW5GLE9BQU8sRUFBRSxHQUFHa0k7Z0JBQzdCL0MsU0FBU3F4QixlQUFlO29CQUFDejJCO29CQUFTQztpQkFBUTtnQkFDMUNnSSxJQUFJO29CQUFFakk7Z0JBQVE7WUFDbEI7WUFDQVIsWUFBWSxDQUFDUztnQkFDVCxNQUFNLEVBQUVtRixPQUFPLEVBQUVwRixPQUFPLEVBQUUsR0FBR21JO2dCQUM3Qi9DLFNBQVNxeEIsZUFBZTtvQkFBQ3oyQjtvQkFBU0M7aUJBQVE7Z0JBQzFDZ0ksSUFBSTtvQkFBRWhJO2dCQUFRO1lBQ2xCO1lBQ0FSLG9CQUFvQixDQUFDSztnQkFDakJxSSxNQUFNL0MsT0FBTyxFQUFFM0YsbUJBQW1CSztnQkFDbENtSSxJQUFJO29CQUFFbkk7Z0JBQWdCO1lBQzFCO1lBQ0FnVyx1QkFBdUI7Z0JBQ25CLE1BQU0sRUFBRXhYLEtBQUssRUFBRUQsS0FBSyxFQUFFNFAsa0JBQWtCLEVBQUVDLGtCQUFrQixFQUFFaE8sa0JBQWtCLEVBQUUsR0FBR2lJO2dCQUNyRixJQUFJLENBQUNqSSxvQkFBb0I7b0JBQ3JCO2dCQUNKO2dCQUNBLE1BQU13TyxjQUFjclEsTUFBTTJFLE1BQU0sQ0FBQyxDQUFDQyxLQUFLN0YsT0FBVUEsS0FBS0UsUUFBUSxHQUFHOzJCQUFJMkY7d0JBQUtnRyxzQkFBc0I3TCxLQUFLcEIsRUFBRSxFQUFFO3FCQUFPLEdBQUdpSCxLQUFNLEVBQUU7Z0JBQzNILE1BQU13TCxjQUFjblEsTUFBTTBFLE1BQU0sQ0FBQyxDQUFDQyxLQUFLdkYsT0FBVUEsS0FBS0osUUFBUSxHQUFHOzJCQUFJMkY7d0JBQUtnRyxzQkFBc0J2TCxLQUFLMUIsRUFBRSxFQUFFO3FCQUFPLEdBQUdpSCxLQUFNLEVBQUU7Z0JBQzNIZ0wsbUJBQW1CUztnQkFDbkJSLG1CQUFtQk87WUFDdkI7WUFDQS9PLGVBQWUsQ0FBQ2czQjtnQkFDWixNQUFNLEVBQUVyNEIsS0FBSyxFQUFFaEIsVUFBVSxFQUFFd21CLFlBQVksRUFBRTlqQixVQUFVLEVBQUVtMUIsb0JBQW9CLEVBQUV2YixVQUFVLEVBQUV5VyxVQUFVLEVBQUUsR0FBR2pvQjtnQkFDdEcsSUFBSXV1QixjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSy9jLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUN6QytjLGNBQWMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLL2MsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQ3pDK2MsY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUsvYyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFDekMrYyxjQUFjLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSy9jLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUMzQztnQkFDSjtnQkFDQTdoQiw4REFBY0EsQ0FBQ3VHLE9BQU9oQixZQUFZd21CLGNBQWM7b0JBQzVDOWpCO29CQUNBNFosWUFBWStjO29CQUNaeEI7b0JBQ0FNLGVBQWU7b0JBQ2ZwRjtnQkFDSjtnQkFDQW5vQixJQUFJO29CQUFFMFIsWUFBWStjO2dCQUFlO1lBQ3JDO1lBQ0FwK0IsT0FBTyxDQUFDcStCO2dCQUNKLE1BQU0sRUFBRTd3QixTQUFTLEVBQUVoTCxLQUFLLEVBQUVDLE1BQU0sRUFBRXFLLE9BQU8sRUFBRXRGLGVBQWUsRUFBRSxHQUFHcUk7Z0JBQy9ELE9BQU83UCxxREFBS0EsQ0FBQztvQkFBRXErQjtvQkFBT3Z4QjtvQkFBU1U7b0JBQVdoRztvQkFBaUJoRjtvQkFBT0M7Z0JBQU87WUFDN0U7WUFDQXNMLFdBQVcsT0FBT3RILEdBQUdDLEdBQUcrQztnQkFDcEIsTUFBTSxFQUFFakgsS0FBSyxFQUFFQyxNQUFNLEVBQUVrRixPQUFPLEVBQUVtRixPQUFPLEVBQUUsR0FBRytDO2dCQUM1QyxJQUFJLENBQUMvQyxTQUFTO29CQUNWLE9BQU9HLFFBQVFDLE9BQU8sQ0FBQztnQkFDM0I7Z0JBQ0EsTUFBTW94QixXQUFXLE9BQU83MEIsU0FBUzlDLFNBQVMsY0FBYzhDLFFBQVE5QyxJQUFJLEdBQUdnQjtnQkFDdkUsTUFBTW1GLFFBQVFXLFdBQVcsQ0FBQztvQkFDdEJoSCxHQUFHakUsUUFBUSxJQUFJaUUsSUFBSTYzQjtvQkFDbkI1M0IsR0FBR2pFLFNBQVMsSUFBSWlFLElBQUk0M0I7b0JBQ3BCMzNCLE1BQU0yM0I7Z0JBQ1YsR0FBRztvQkFBRXR4QixVQUFVdkQsU0FBU3VEO29CQUFVa0IsTUFBTXpFLFNBQVN5RTtvQkFBTUMsYUFBYTFFLFNBQVMwRTtnQkFBWTtnQkFDekYsT0FBT2xCLFFBQVFDLE9BQU8sQ0FBQztZQUMzQjtZQUNBd1gsa0JBQWtCO2dCQUNkL1UsSUFBSTtvQkFDQThKLFlBQVk7d0JBQUUsR0FBR2hhLDZEQUFpQjtvQkFBQztnQkFDdkM7WUFDSjtZQUNBb2xCLGtCQUFrQixDQUFDcEw7Z0JBQ2Y5SixJQUFJO29CQUFFOEo7Z0JBQVc7WUFDckI7WUFDQXBTLE9BQU8sSUFBTXNJLElBQUk7b0JBQUUsR0FBRzJzQixpQkFBaUI7Z0JBQUM7UUFDNUM7SUFDSixHQUFHL1QsT0FBT2dXLEVBQUU7QUFFWjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUNDLEdBQ0QsU0FBU0Msa0JBQWtCLEVBQUVDLGNBQWMxNEIsS0FBSyxFQUFFMjRCLGNBQWMxNEIsS0FBSyxFQUFFZ0MsWUFBWSxFQUFFQyxZQUFZLEVBQUU2ZixjQUFjdGxCLEtBQUssRUFBRXVsQixlQUFldGxCLE1BQU0sRUFBRWs4QixnQkFBZ0JqM0IsT0FBTyxFQUFFazNCLGdCQUFnQmozQixPQUFPLEVBQUVrM0IsdUJBQXVCcjJCLGNBQWMsRUFBRXVQLE9BQU8sRUFBRXRRLFVBQVUsRUFBRTRaLFVBQVUsRUFBRXlXLFVBQVUsRUFBRW4wQixRQUFRLEVBQUc7SUFDNVIsTUFBTSxDQUFDN0IsTUFBTSxHQUFHN0YsK0NBQVFBLENBQUMsSUFBTStnQyxZQUFZO1lBQ3ZDajNCO1lBQ0FDO1lBQ0FnQztZQUNBQztZQUNBekY7WUFDQUM7WUFDQXNWO1lBQ0FyUTtZQUNBQztZQUNBYTtZQUNBZjtZQUNBNFo7WUFDQXlXO1FBQ0o7SUFDQSxPQUFRcDhCLHNEQUFHQSxDQUFDOEYsWUFBWTtRQUFFZ1MsT0FBTzFSO1FBQU82QixVQUFVakksc0RBQUdBLENBQUMrVyxlQUFlO1lBQUU5TyxVQUFVQTtRQUFTO0lBQUc7QUFDakc7QUFFQSxTQUFTbTdCLFFBQVEsRUFBRW43QixRQUFRLEVBQUVvQyxLQUFLLEVBQUVDLEtBQUssRUFBRWdDLFlBQVksRUFBRUMsWUFBWSxFQUFFekYsS0FBSyxFQUFFQyxNQUFNLEVBQUVzVixPQUFPLEVBQUV2UCxjQUFjLEVBQUVkLE9BQU8sRUFBRUMsT0FBTyxFQUFFRixVQUFVLEVBQUU0WixVQUFVLEVBQUV5VyxVQUFVLEVBQUc7SUFDbEssTUFBTWlILFlBQVluakMsaURBQVVBLENBQUMyRjtJQUM3QixJQUFJdzlCLFdBQVc7UUFDWDs7O1NBR0MsR0FDRCxPQUFPcmpDLHNEQUFHQSxDQUFDRCx1REFBUUEsRUFBRTtZQUFFa0ksVUFBVUE7UUFBUztJQUM5QztJQUNBLE9BQVFqSSxzREFBR0EsQ0FBQzhpQyxtQkFBbUI7UUFBRUMsY0FBYzE0QjtRQUFPMjRCLGNBQWMxNEI7UUFBT2dDLGNBQWNBO1FBQWNDLGNBQWNBO1FBQWM2ZixjQUFjdGxCO1FBQU91bEIsZUFBZXRsQjtRQUFRc1YsU0FBU0E7UUFBUzhtQix1QkFBdUJyMkI7UUFBZ0JtMkIsZ0JBQWdCajNCO1FBQVNrM0IsZ0JBQWdCajNCO1FBQVNGLFlBQVlBO1FBQVk0WixZQUFZQTtRQUFZeVcsWUFBWUE7UUFBWW4wQixVQUFVQTtJQUFTO0FBQ3pYO0FBRUEsTUFBTXE3QixlQUFlO0lBQ2pCeDhCLE9BQU87SUFDUEMsUUFBUTtJQUNSSSxVQUFVO0lBQ1ZOLFVBQVU7SUFDVnNxQixRQUFRO0FBQ1o7QUFDQSxTQUFTb1MsVUFBVSxFQUFFbDVCLEtBQUssRUFBRUMsS0FBSyxFQUFFZ0MsWUFBWSxFQUFFQyxZQUFZLEVBQUVsRSxTQUFTLEVBQUVzbkIsU0FBUyxFQUFFK0wsU0FBUyxFQUFFeEosV0FBVyxFQUFFcUssV0FBVyxFQUFFb0IsTUFBTSxFQUFFL2QsTUFBTSxFQUFFRixXQUFXLEVBQUVLLFNBQVMsRUFBRWtJLFNBQVMsRUFBRWdCLGNBQWMsRUFBRUMsWUFBWSxFQUFFTyxtQkFBbUIsRUFBRUMsaUJBQWlCLEVBQUV5SSxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFQyxnQkFBZ0IsRUFBRUMsaUJBQWlCLEVBQUVDLGlCQUFpQixFQUFFaVIsZUFBZSxFQUFFQyxVQUFVLEVBQUVDLGNBQWMsRUFBRTNwQixhQUFhLEVBQUVDLGFBQWEsRUFBRUcsUUFBUSxFQUFFaFEsaUJBQWlCLEVBQUV3NUIsb0JBQW9CLEVBQUVDLGVBQWUsRUFBRUMsbUJBQW1CLEVBQUVwWCxzQkFBc0IsRUFBRXpMLGdCQUFnQixFQUFFQyxjQUFjLEVBQUU3RyxjQUFjLEVBQUUyTSxjQUFjLEVBQUVtWSxxQkFBcUJ0N0IsOERBQWtCQSxDQUFDaTdCLE1BQU0sRUFBRU0sbUJBQW1CLEVBQUVzQix1QkFBdUIsRUFBRUMsNEJBQTRCLEVBQUVoa0IsZ0JBQWdCLFdBQVcsRUFBRTJRLG1CQUFtQixPQUFPLEVBQUVwTyxrQkFBa0IsS0FBSyxFQUFFNkIsZ0JBQWdCL2UseURBQWFBLENBQUNnZixJQUFJLEVBQUV1TSx1QkFBdUIsT0FBTyxFQUFFM1Esd0JBQXdCblksdURBQU9BLEtBQUssU0FBUyxTQUFTLEVBQUVtYSx3QkFBd0JuYSx1REFBT0EsS0FBSyxTQUFTLFNBQVMsRUFBRXFPLFVBQVUsRUFBRUQsUUFBUSxFQUFFcWYsNEJBQTRCLEtBQUssRUFBRXJCLGlCQUFpQixFQUFFcEwsY0FBYyxFQUFFd0wsa0JBQWtCLEVBQUV2QixnQkFBZ0IsRUFBRUMsY0FBYyxFQUFFM2pCLGFBQWFsQixpQkFBaUIsRUFBRTJ3QixjQUFjLEVBQUVDLGtCQUFrQixFQUFFdnZCLHFCQUFxQixJQUFJLEVBQUVwQixpQkFBaUJnNUIsb0JBQW9CaDVCLGVBQWUsRUFBRWtCLFVBQVUsR0FBRyxFQUFFQyxVQUFVLENBQUMsRUFBRUgsa0JBQWtCaEwsMERBQWMsRUFBRThkLG1CQUFtQixJQUFJLEVBQUUrRyxVQUFVLEVBQUUyWCxxQkFBcUIsU0FBUyxFQUFFbmYsZUFBZSxJQUFJLEVBQUVDLGNBQWMsSUFBSSxFQUFFQyxjQUFjLEtBQUssRUFBRUMsbUJBQW1CLEdBQUcsRUFBRUMsa0JBQWtCemMsMkRBQWVBLENBQUMwYyxJQUFJLEVBQUVDLG9CQUFvQixJQUFJLEVBQUVDLFlBQVksSUFBSSxFQUFFd0MsV0FBVyxFQUFFRSxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFQyxnQkFBZ0IsRUFBRUgsWUFBWSxFQUFFakQsaUJBQWlCLEVBQUVjLG9CQUFvQixDQUFDLEVBQUVnRyxvQkFBb0IsQ0FBQyxFQUFFL2MsUUFBUSxFQUFFbXlCLFdBQVcsRUFBRUMsZ0JBQWdCLEVBQUVDLGNBQWMsRUFBRW9DLGlCQUFpQixFQUFFRCxpQkFBaUIsRUFBRUUsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUUxQyxrQkFBa0IsRUFBRSxFQUFFampCLGFBQWEsRUFBRVUsYUFBYSxFQUFFaU4sa0JBQWtCLFFBQVEsRUFBRWhHLG1CQUFtQixTQUFTLEVBQUUxUyxpQkFBaUIsT0FBTyxFQUFFa1EsT0FBTyxFQUFFdlAsY0FBYyxFQUFFNFosY0FBYyxFQUFFcWQsbUJBQW1CLEVBQUVuN0IsVUFBVSxFQUFFbWEsa0JBQWtCLEVBQUVtZSx1QkFBdUIsSUFBSSxFQUFFL0UsdUJBQXVCLEtBQUssRUFBRWgwQixzQkFBc0IsS0FBSyxFQUFFMGdCLGdCQUFnQixFQUFFc1ksaUJBQWlCLEVBQUU3WCxZQUFZLEVBQUVSLGdCQUFnQixFQUFFakIsaUJBQWlCLEVBQUUxSyxPQUFPLEVBQUV6VyxLQUFLLEVBQUVzQixFQUFFLEVBQUU2b0IsaUJBQWlCLEVBQUVySCx1QkFBdUIsRUFBRXhYLFFBQVEsRUFBRThNLGdCQUFnQixFQUFFaFksS0FBSyxFQUFFQyxNQUFNLEVBQUVvRyxZQUFZLE9BQU8sRUFBRWkwQixLQUFLLEVBQUU0QyxRQUFRLEVBQUVuOEIsZUFBZSxFQUFFdTBCLGFBQWEsT0FBTyxFQUFFLEdBQUc5ekIsTUFBTSxFQUFFQyxHQUFHO0lBQy81RSxNQUFNUixPQUFPQyxNQUFNO0lBQ25CLE1BQU1pOEIscUJBQXFCLzJCLGtCQUFrQkM7SUFDN0MsNkZBQTZGO0lBQzdGLE1BQU0rMkIsa0JBQWtCempDLGtEQUFXQSxDQUFDLENBQUM0WTtRQUNqQ0EsRUFBRXVQLGFBQWEsQ0FBQ3ViLFFBQVEsQ0FBQztZQUFFMW1CLEtBQUs7WUFBR0MsTUFBTTtZQUFHMG1CLFVBQVU7UUFBVTtRQUNoRUosV0FBVzNxQjtJQUNmLEdBQUc7UUFBQzJxQjtLQUFTO0lBQ2IsT0FBUWhrQyxzREFBR0EsQ0FBQyxPQUFPO1FBQUUsZUFBZTtRQUFlLEdBQUdzSSxJQUFJO1FBQUUwN0IsVUFBVUU7UUFBaUJ4OUIsT0FBTztZQUFFLEdBQUdBLEtBQUs7WUFBRSxHQUFHNDhCLFlBQVk7UUFBQztRQUFHLzZCLEtBQUtBO1FBQUtGLFdBQVcxSCxvREFBRUEsQ0FBQztZQUFDO1lBQWMwSDtZQUFXNDdCO1NBQW1CO1FBQUdqOEIsSUFBSUE7UUFBSXVwQixNQUFNO1FBQWV0cEIsVUFBVW5JLHVEQUFJQSxDQUFDc2pDLFNBQVM7WUFBRS80QixPQUFPQTtZQUFPQyxPQUFPQTtZQUFPeEQsT0FBT0E7WUFBT0MsUUFBUUE7WUFBUXNWLFNBQVNBO1lBQVN2UCxnQkFBZ0JBO1lBQWdCZCxTQUFTQTtZQUFTQyxTQUFTQTtZQUFTRixZQUFZQTtZQUFZNFosWUFBWUE7WUFBWXlXLFlBQVlBO1lBQVluMEIsVUFBVTtnQkFBQ2pJLHNEQUFHQSxDQUFDMmdDLFdBQVc7b0JBQUVoRCxRQUFRQTtvQkFBUXpMLGFBQWFBO29CQUFhcUssYUFBYUE7b0JBQWFwSyxrQkFBa0JBO29CQUFrQkMsaUJBQWlCQTtvQkFBaUJDLGtCQUFrQkE7b0JBQWtCQyxtQkFBbUJBO29CQUFtQkMsbUJBQW1CQTtvQkFBbUI1QyxXQUFXQTtvQkFBVytMLFdBQVdBO29CQUFXd0Qsb0JBQW9CQTtvQkFBb0JDLHFCQUFxQkE7b0JBQXFCc0IseUJBQXlCQTtvQkFBeUJDLDhCQUE4QkE7b0JBQThCclQsa0JBQWtCQTtvQkFBa0JwTyxpQkFBaUJBO29CQUFpQjZCLGVBQWVBO29CQUFlcEUsZUFBZUE7b0JBQWVDLHVCQUF1QkE7b0JBQXVCMlEsc0JBQXNCQTtvQkFBc0IzTyx1QkFBdUJBO29CQUF1QnNULDJCQUEyQkE7b0JBQTJCbm5CLGlCQUFpQmc1QjtvQkFBbUJoNEIsaUJBQWlCQTtvQkFBaUJFLFNBQVNBO29CQUFTQyxTQUFTQTtvQkFBUzJTLGtCQUFrQkE7b0JBQWtCVCxjQUFjQTtvQkFBY0MsYUFBYUE7b0JBQWFLLG1CQUFtQkE7b0JBQW1CSixhQUFhQTtvQkFBYUMsa0JBQWtCQTtvQkFBa0JDLGlCQUFpQkE7b0JBQWlCRyxXQUFXQTtvQkFBV3dDLGFBQWFBO29CQUFhRSxrQkFBa0JBO29CQUFrQkMsaUJBQWlCQTtvQkFBaUJDLGtCQUFrQkE7b0JBQWtCSCxjQUFjQTtvQkFBY2pELG1CQUFtQkE7b0JBQW1CYyxtQkFBbUJBO29CQUFtQmdHLG1CQUFtQkE7b0JBQW1CeUgsd0JBQXdCQTtvQkFBd0J6TCxrQkFBa0JBO29CQUFrQkMsZ0JBQWdCQTtvQkFBZ0JtWixhQUFhQTtvQkFBYUMsa0JBQWtCQTtvQkFBa0JDLGdCQUFnQkE7b0JBQWdCb0MsbUJBQW1CQTtvQkFBbUJELG1CQUFtQkE7b0JBQW1CRSxrQkFBa0JBO29CQUFrQkMsaUJBQWlCQTtvQkFBaUJDLGtCQUFrQkE7b0JBQWtCMUMsaUJBQWlCQTtvQkFBaUJtRCxvQkFBb0JBO29CQUFvQnpZLGlCQUFpQkE7b0JBQWlCaEcsa0JBQWtCQTtvQkFBa0IxUyxnQkFBZ0JBO29CQUFnQnBFLE1BQU1BO29CQUFNSSxxQkFBcUJBO29CQUFxQndkLFlBQVlBO29CQUFZM1QsVUFBVUE7b0JBQVU4TSxrQkFBa0JBO2dCQUFpQjtnQkFBSTllLHNEQUFHQSxDQUFDb00sY0FBYztvQkFBRS9CLE9BQU9BO29CQUFPQyxPQUFPQTtvQkFBT2dDLGNBQWNBO29CQUFjQyxjQUFjQTtvQkFBYzBiLFdBQVdBO29CQUFXZ0IsZ0JBQWdCQTtvQkFBZ0JDLGNBQWNBO29CQUFjTyxxQkFBcUJBO29CQUFxQkMsbUJBQW1CQTtvQkFBbUJsRSxnQkFBZ0JBO29CQUFnQndMLG9CQUFvQkE7b0JBQW9CdkIsa0JBQWtCQTtvQkFBa0JDLGdCQUFnQkE7b0JBQWdCOEwsZ0JBQWdCQTtvQkFBZ0JDLG9CQUFvQkE7b0JBQW9CdnZCLG9CQUFvQkE7b0JBQW9CZzFCLHNCQUFzQkE7b0JBQXNCL0Usc0JBQXNCQTtvQkFBc0Jud0IsU0FBU0E7b0JBQVNDLFNBQVNBO29CQUFTMFosWUFBWUE7b0JBQVl6TyxlQUFlQTtvQkFBZVUsZUFBZUE7b0JBQWUvRSxZQUFZQTtvQkFBWUQsVUFBVUE7b0JBQVVtVSxnQkFBZ0JBO29CQUFnQmpiLGlCQUFpQkE7b0JBQWlCNGEsZ0JBQWdCQTtvQkFBZ0IzRCxvQkFBb0JBO29CQUFvQjFHLFNBQVNBO29CQUFTdlAsZ0JBQWdCQTtvQkFBZ0JpTixlQUFlQTtvQkFBZUMsZUFBZUE7b0JBQWVHLFVBQVVBO29CQUFVcXBCLGlCQUFpQkE7b0JBQWlCQyxZQUFZQTtvQkFBWUMsZ0JBQWdCQTtvQkFBZ0JFLGlCQUFpQkE7b0JBQWlCRCxzQkFBc0JBO29CQUFzQkUscUJBQXFCQTtvQkFBcUJqa0IsUUFBUUE7b0JBQVFGLGFBQWFBO29CQUFhSyxXQUFXQTtvQkFBVzVULGdCQUFnQkE7b0JBQWdCSixZQUFZQTtvQkFBWWhFLE1BQU1BO29CQUFNOGdCLGtCQUFrQkE7b0JBQWtCc1ksbUJBQW1CQTtvQkFBbUI3WCxjQUFjQTtvQkFBY25NLFNBQVNBO29CQUFTMkwsa0JBQWtCQTtvQkFBa0JqQixtQkFBbUJBO29CQUFtQitJLG1CQUFtQkE7b0JBQW1CQyxtQkFBbUJBO29CQUFtQnJILHlCQUF5QkE7b0JBQXlCcFAsZ0JBQWdCQTtvQkFBZ0JnbkIsT0FBT0E7b0JBQU92NUIsaUJBQWlCQTtvQkFBaUJ1MEIsWUFBWUE7Z0JBQVc7Z0JBQUlwOEIsc0RBQUdBLENBQUMySyxtQkFBbUI7b0JBQUVSLG1CQUFtQkE7Z0JBQWtCO2dCQUFJbEM7Z0JBQVVqSSxzREFBR0EsQ0FBQzJJLGFBQWE7b0JBQUVDLFlBQVlBO29CQUFZL0IsVUFBVWs5QjtnQkFBb0I7Z0JBQUkvakMsc0RBQUdBLENBQUNrSSxrQkFBa0I7b0JBQUVILE1BQU1BO29CQUFNSSxxQkFBcUJBO2dCQUFvQjthQUFHO1FBQUM7SUFBRztBQUN6a0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELElBQUlvTSxRQUFRMEIsZ0JBQWdCc3RCO0FBRTVCLE1BQU1jLGFBQWEsQ0FBQzM4QixJQUFNQSxFQUFFb0wsT0FBTyxFQUFFd3RCLGNBQWM7QUFDbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F3Q0MsR0FDRCxTQUFTZ0Usa0JBQWtCLEVBQUVyOEIsUUFBUSxFQUFFO0lBQ25DLE1BQU1zOEIsb0JBQW9CdCtCLFNBQVNvK0I7SUFDbkMsSUFBSSxDQUFDRSxtQkFBbUI7UUFDcEIsT0FBTztJQUNYO0lBQ0EscUJBQU8zK0IsdURBQVlBLENBQUNxQyxVQUFVczhCO0FBQ2xDO0FBRUEsTUFBTUMsYUFBYSxDQUFDOThCLElBQU1BLEVBQUVvTCxPQUFPLEVBQUV3dEIsY0FBYztBQUNuRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ0QsU0FBU21FLGVBQWUsRUFBRXg4QixRQUFRLEVBQUU7SUFDaEMsTUFBTXk4QixnQkFBZ0J6K0IsU0FBU3UrQjtJQUMvQixJQUFJLENBQUNFLGVBQWU7UUFDaEIsT0FBTztJQUNYO0lBQ0EscUJBQU85K0IsdURBQVlBLENBQUNxQyxVQUFVeThCO0FBQ2xDO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNENDLEdBQ0QsU0FBU0M7SUFDTCxNQUFNditCLFFBQVFFO0lBQ2QsT0FBTzdGLGtEQUFXQSxDQUFDLENBQUN1SDtRQUNoQixNQUFNLEVBQUU4SyxPQUFPLEVBQUU1TyxtQkFBbUIsRUFBRSxHQUFHa0MsTUFBTUcsUUFBUTtRQUN2RCxNQUFNcStCLFlBQVluMkIsTUFBTUMsT0FBTyxDQUFDMUcsTUFBTUEsS0FBSztZQUFDQTtTQUFHO1FBQy9DLE1BQU1rbUIsVUFBVSxJQUFJcmE7UUFDcEIrd0IsVUFBVXA2QixPQUFPLENBQUMsQ0FBQ3E2QjtZQUNmLE1BQU14VyxjQUFjdmIsU0FBU3d0QixjQUFjLENBQUMsMkJBQTJCLEVBQUV1RSxTQUFTLEVBQUUsQ0FBQztZQUNyRixJQUFJeFcsYUFBYTtnQkFDYkgsUUFBUWphLEdBQUcsQ0FBQzR3QixVQUFVO29CQUFFNzhCLElBQUk2OEI7b0JBQVV4VztvQkFBYUMsT0FBTztnQkFBSztZQUNuRTtRQUNKO1FBQ0E5VyxzQkFBc0IsSUFBTXRULG9CQUFvQmdxQixTQUFTO2dCQUFFNFcsZ0JBQWdCO1lBQU07SUFDckYsR0FBRyxFQUFFO0FBQ1Q7QUFFQSxNQUFNQyxnQkFBZ0IsQ0FBQ25lLFFBQVVBLE1BQU12YyxLQUFLO0FBQzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTMjZCO0lBQ0wsTUFBTTM2QixRQUFRcEUsU0FBUzgrQixlQUFlcC9CLG9EQUFPQTtJQUM3QyxPQUFPMEU7QUFDWDtBQUVBLE1BQU00NkIsZ0JBQWdCLENBQUNyZSxRQUFVQSxNQUFNdGMsS0FBSztBQUM1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxTQUFTNDZCO0lBQ0wsTUFBTTU2QixRQUFRckUsU0FBU2cvQixlQUFldC9CLG9EQUFPQTtJQUM3QyxPQUFPMkU7QUFDWDtBQUVBLE1BQU02NkIsbUJBQW1CLENBQUN2ZSxRQUFXO1FBQ2pDN2IsR0FBRzZiLE1BQU05VSxTQUFTLENBQUMsRUFBRTtRQUNyQjlHLEdBQUc0YixNQUFNOVUsU0FBUyxDQUFDLEVBQUU7UUFDckI3RyxNQUFNMmIsTUFBTTlVLFNBQVMsQ0FBQyxFQUFFO0lBQzVCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDRCxTQUFTc3pCO0lBQ0wsTUFBTXB6QixXQUFXL0wsU0FBU2svQixrQkFBa0J4L0Isb0RBQU9BO0lBQ25ELE9BQU9xTTtBQUNYO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNENDLEdBQ0QsU0FBU3F6QixjQUFjdEMsWUFBWTtJQUMvQixNQUFNLENBQUMxNEIsT0FBT2dCLFNBQVMsR0FBRzlLLCtDQUFRQSxDQUFDd2lDO0lBQ25DLE1BQU03ckIsZ0JBQWdCelcsa0RBQVdBLENBQUMsQ0FBQ2dULFVBQVlwSSxTQUFTLENBQUNpNkIsTUFBUXZ3QixpQkFBaUJ0QixTQUFTNnhCLE9BQU8sRUFBRTtJQUNwRyxPQUFPO1FBQUNqN0I7UUFBT2dCO1FBQVU2TDtLQUFjO0FBQzNDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4Q0MsR0FDRCxTQUFTcXVCLGNBQWN2QyxZQUFZO0lBQy9CLE1BQU0sQ0FBQzE0QixPQUFPZ0IsU0FBUyxHQUFHL0ssK0NBQVFBLENBQUN5aUM7SUFDbkMsTUFBTXByQixnQkFBZ0JuWCxrREFBV0EsQ0FBQyxDQUFDZ1QsVUFBWW5JLFNBQVMsQ0FBQ2s2QixNQUFReHdCLGlCQUFpQnZCLFNBQVMreEIsT0FBTyxFQUFFO0lBQ3BHLE9BQU87UUFBQ2w3QjtRQUFPZ0I7UUFBVXNNO0tBQWM7QUFDM0M7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ0QsU0FBUzZ0QixvQkFBb0IsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssRUFBRTtJQUNyRCxNQUFNeC9CLFFBQVFFO0lBQ2RqRyxnREFBU0EsQ0FBQztRQUNOK0YsTUFBTUksUUFBUSxDQUFDO1lBQUVpWix1QkFBdUJpbUI7UUFBUTtJQUNwRCxHQUFHO1FBQUNBO0tBQVE7SUFDWnJsQyxnREFBU0EsQ0FBQztRQUNOK0YsTUFBTUksUUFBUSxDQUFDO1lBQUVzWSxrQkFBa0I2bUI7UUFBUztJQUNoRCxHQUFHO1FBQUNBO0tBQVM7SUFDYnRsQyxnREFBU0EsQ0FBQztRQUNOK0YsTUFBTUksUUFBUSxDQUFDO1lBQUVzWixxQkFBcUI4bEI7UUFBTTtJQUNoRCxHQUFHO1FBQUNBO0tBQU07QUFDZDtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1DQyxHQUNELFNBQVNDLHFCQUFxQixFQUFFRixRQUFRLEVBQUc7SUFDdkMsTUFBTXYvQixRQUFRRTtJQUNkakcsZ0RBQVNBLENBQUM7UUFDTixNQUFNeWxDLGdDQUFnQztlQUFJMS9CLE1BQU1HLFFBQVEsR0FBR2dFLHlCQUF5QjtZQUFFbzdCO1NBQVM7UUFDL0Z2L0IsTUFBTUksUUFBUSxDQUFDO1lBQUUrRCwyQkFBMkJ1N0I7UUFBOEI7UUFDMUUsT0FBTztZQUNILE1BQU1DLGVBQWUzL0IsTUFBTUcsUUFBUSxHQUFHZ0UseUJBQXlCLENBQUNxRSxNQUFNLENBQUMsQ0FBQ25FLEtBQU9BLE9BQU9rN0I7WUFDdEZ2L0IsTUFBTUksUUFBUSxDQUFDO2dCQUFFK0QsMkJBQTJCdzdCO1lBQWE7UUFDN0Q7SUFDSixHQUFHO1FBQUNKO0tBQVM7QUFDakI7QUFFQSxNQUFNSyxhQUFhLENBQUNqNEIsVUFBWSxDQUFDckc7UUFDN0IsSUFBSSxDQUFDcUcsUUFBUWs0QixrQkFBa0IsRUFBRTtZQUM3QixPQUFPditCLEVBQUV1NUIsZ0JBQWdCO1FBQzdCO1FBQ0EsSUFBSXY1QixFQUFFMkIsVUFBVSxDQUFDc0gsSUFBSSxLQUFLLEdBQUc7WUFDekIsT0FBTztRQUNYO1FBQ0EsS0FBSyxNQUFNLEdBQUcsRUFBRW5ILFNBQVMsRUFBRSxDQUFDLElBQUk5QixFQUFFMkIsVUFBVSxDQUFFO1lBQzFDLElBQUlHLFVBQVUyaUIsWUFBWSxLQUFLM1gsYUFBYSxDQUFDMVIsaUVBQWlCQSxDQUFDMEcsVUFBVUMsUUFBUSxHQUFHO2dCQUNoRixPQUFPO1lBQ1g7UUFDSjtRQUNBLE9BQU87SUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDQyxHQUNELFNBQVN5OEIsb0JBQW9CbjRCLFVBQVU7SUFDbkNrNEIsb0JBQW9CO0FBQ3hCLENBQUM7SUFDRyxNQUFNRSxjQUFjbGdDLFNBQVMrL0IsV0FBV2o0QjtJQUN4QyxPQUFPbzRCO0FBQ1g7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxxQkFBcUIsRUFBRXB5QixJQUFJLEVBQUVoTSxFQUFFLEVBQUVnVSxNQUFNLEVBQUVpTSxTQUFTLEVBQUVvZSxZQUFZLEVBQUc7SUFDeEUzRSxRQUFRNEUsSUFBSSxDQUFDO0lBQ2IsTUFBTUMsVUFBVS9mO0lBQ2hCLE1BQU1nZ0IsZ0JBQWdCeHFCLFVBQVV1cUI7SUFDaEMsTUFBTUUsa0JBQWtCbm1DLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU11akIsY0FBYzVkLFNBQVMsQ0FBQzJnQixRQUFVQSxNQUFNMUssZ0JBQWdCLENBQUMvSCxHQUFHLENBQUMsQ0FBQyxFQUFFcXlCLGNBQWMsQ0FBQyxFQUFFeHlCLEtBQUssRUFBRWhNLEtBQUssQ0FBQyxDQUFDLEVBQUVBLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHdkQsa0VBQXNCQTtJQUMzSXBFLGdEQUFTQSxDQUFDO1FBQ04sNkZBQTZGO1FBQzdGLElBQUlvbUMsZ0JBQWdCaDZCLE9BQU8sSUFBSWc2QixnQkFBZ0JoNkIsT0FBTyxLQUFLb1gsYUFBYTtZQUNwRSxNQUFNNmlCLGVBQWU3aUIsZUFBZSxJQUFJaFE7WUFDeENuUCxzRUFBc0JBLENBQUMraEMsZ0JBQWdCaDZCLE9BQU8sRUFBRWk2QixjQUFjTDtZQUM5RDNoQyxzRUFBc0JBLENBQUNnaUMsY0FBY0QsZ0JBQWdCaDZCLE9BQU8sRUFBRXdiO1FBQ2xFO1FBQ0F3ZSxnQkFBZ0JoNkIsT0FBTyxHQUFHb1gsZUFBZSxJQUFJaFE7SUFDakQsR0FBRztRQUFDZ1E7UUFBYW9FO1FBQVdvZTtLQUFhO0lBQ3pDLE9BQU9sbUMsOENBQU9BLENBQUMsSUFBTXNPLE1BQU13TixJQUFJLENBQUM0SCxhQUFhdE0sWUFBWSxFQUFFLEdBQUc7UUFBQ3NNO0tBQVk7QUFDL0U7QUFFQSxNQUFNOGlCLFdBQVcvbEMseURBQWEsQ0FBQyxXQUFXO0FBQzFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDRCxTQUFTZ21DLG1CQUFtQixFQUFFNStCLEVBQUUsRUFBRTZoQixVQUFVLEVBQUV6TixRQUFRLEVBQUU2TCxTQUFTLEVBQUVvZSxZQUFZLEVBQUcsR0FBRyxDQUFDLENBQUM7SUFDbkYsTUFBTXJxQixTQUFTd0s7SUFDZixNQUFNZ2dCLGdCQUFnQngrQixNQUFNZ1U7SUFDNUIsSUFBSSxDQUFDd3FCLGVBQWU7UUFDaEIsTUFBTSxJQUFJbmdDLE1BQU1zZ0M7SUFDcEI7SUFDQSxNQUFNRixrQkFBa0JubUMsNkNBQU1BLENBQUM7SUFDL0IsTUFBTXVqQixjQUFjNWQsU0FBUyxDQUFDMmdCLFFBQVVBLE1BQU0xSyxnQkFBZ0IsQ0FBQy9ILEdBQUcsQ0FBQyxDQUFDLEVBQUVxeUIsY0FBYyxFQUFFM2MsYUFBY3pOLFdBQVcsQ0FBQyxDQUFDLEVBQUV5TixXQUFXLENBQUMsRUFBRXpOLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFeU4sV0FBVyxDQUFDLEdBQUksR0FBRyxDQUFDLEdBQUdwbEIsa0VBQXNCQTtJQUMvTHBFLGdEQUFTQSxDQUFDO1FBQ04sOEZBQThGO1FBQzlGLElBQUlvbUMsZ0JBQWdCaDZCLE9BQU8sSUFBSWc2QixnQkFBZ0JoNkIsT0FBTyxLQUFLb1gsYUFBYTtZQUNwRSxNQUFNNmlCLGVBQWU3aUIsZUFBZSxJQUFJaFE7WUFDeENuUCxzRUFBc0JBLENBQUMraEMsZ0JBQWdCaDZCLE9BQU8sRUFBRWk2QixjQUFjTDtZQUM5RDNoQyxzRUFBc0JBLENBQUNnaUMsY0FBY0QsZ0JBQWdCaDZCLE9BQU8sRUFBRXdiO1FBQ2xFO1FBQ0F3ZSxnQkFBZ0JoNkIsT0FBTyxHQUFHb1gsZUFBZSxJQUFJaFE7SUFDakQsR0FBRztRQUFDZ1E7UUFBYW9FO1FBQVdvZTtLQUFhO0lBQ3pDLE9BQU9sbUMsOENBQU9BLENBQUMsSUFBTXNPLE1BQU13TixJQUFJLENBQUM0SCxhQUFhdE0sWUFBWSxFQUFFLEdBQUc7UUFBQ3NNO0tBQVk7QUFDL0U7QUFFQSw4REFBOEQ7QUFDOUQsU0FBU2dqQixhQUFhOVksT0FBTztJQUN6QixNQUFNK1ksWUFBWTdnQyxTQUFTeEYsa0RBQVdBLENBQUMsQ0FBQ2lIO1FBQ3BDLE1BQU1tVSxPQUFPLEVBQUU7UUFDZixNQUFNa3JCLGVBQWV0NEIsTUFBTUMsT0FBTyxDQUFDcWY7UUFDbkMsTUFBTWlaLFdBQVdELGVBQWVoWixVQUFVO1lBQUNBO1NBQVE7UUFDbkQsS0FBSyxNQUFNL1IsVUFBVWdyQixTQUFVO1lBQzNCLE1BQU01OUIsT0FBTzFCLEVBQUUyQixVQUFVLENBQUM4SyxHQUFHLENBQUM2SDtZQUM5QixJQUFJNVMsTUFBTTtnQkFDTnlTLEtBQUt0UyxJQUFJLENBQUM7b0JBQ052QixJQUFJb0IsS0FBS3BCLEVBQUU7b0JBQ1hnTSxNQUFNNUssS0FBSzRLLElBQUk7b0JBQ2Y2SCxNQUFNelMsS0FBS3lTLElBQUk7Z0JBQ25CO1lBQ0o7UUFDSjtRQUNBLE9BQU9rckIsZUFBZWxyQixPQUFPQSxJQUFJLENBQUMsRUFBRSxJQUFJO0lBQzVDLEdBQUc7UUFBQ2tTO0tBQVEsR0FBR3BwQiwyREFBZUE7SUFDOUIsT0FBT21pQztBQUNYO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ0QsU0FBU0csZ0JBQWdCai9CLEVBQUU7SUFDdkIsTUFBTW9CLE9BQU9uRCxTQUFTeEYsa0RBQVdBLENBQUMsQ0FBQ2lILElBQU1BLEVBQUUyQixVQUFVLENBQUM4SyxHQUFHLENBQUNuTSxLQUFLO1FBQUNBO0tBQUcsR0FBR3JDLG9EQUFPQTtJQUM3RSxPQUFPeUQ7QUFDWDtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBUzg5Qix3Q0FBd0N6OEIsRUFBRTtJQUMvQyxNQUFNckUsUUFBUUU7SUFDZCxNQUFNLENBQUNxdEIsT0FBTyxHQUFHcHpCLCtDQUFRQSxDQUFDLElBQU15ekI7SUFDaEMzekIsZ0RBQVNBLENBQUM7UUFDTixNQUFNLEVBQUU4VywwQkFBMEIsRUFBRSxHQUFHL1EsTUFBTUcsUUFBUTtRQUNyRDRRLDJCQUEyQmxELEdBQUcsQ0FBQzBmLFFBQVFscEI7SUFDM0MsR0FBRztRQUFDQTtLQUFHO0lBQ1BwSyxnREFBU0EsQ0FBQztRQUNOLE1BQU0sRUFBRThXLDBCQUEwQixFQUFFLEdBQUcvUSxNQUFNRyxRQUFRO1FBQ3JELE9BQU87WUFDSDRRLDJCQUEyQjdHLE1BQU0sQ0FBQ3FqQjtRQUN0QztJQUNKLEdBQUcsRUFBRTtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTd1Qsd0NBQXdDMThCLEVBQUU7SUFDL0MsTUFBTXJFLFFBQVFFO0lBQ2QsTUFBTSxDQUFDcXRCLE9BQU8sR0FBR3B6QiwrQ0FBUUEsQ0FBQyxJQUFNeXpCO0lBQ2hDM3pCLGdEQUFTQSxDQUFDO1FBQ04sTUFBTSxFQUFFZ2hDLDBCQUEwQixFQUFFLEdBQUdqN0IsTUFBTUcsUUFBUTtRQUNyRDg2QiwyQkFBMkJwdEIsR0FBRyxDQUFDMGYsUUFBUWxwQjtJQUMzQyxHQUFHO1FBQUNBO0tBQUc7SUFDUHBLLGdEQUFTQSxDQUFDO1FBQ04sTUFBTSxFQUFFZ2hDLDBCQUEwQixFQUFFLEdBQUdqN0IsTUFBTUcsUUFBUTtRQUNyRCxPQUFPO1lBQ0g4NkIsMkJBQTJCL3dCLE1BQU0sQ0FBQ3FqQjtRQUN0QztJQUNKLEdBQUcsRUFBRTtBQUNUO0FBRUEsU0FBU3lULFlBQVksRUFBRXp5QixVQUFVLEVBQUUweUIsU0FBUyxFQUFFQyxPQUFPLEVBQUVqL0IsU0FBUyxFQUFFO0lBQzlELE9BQVFySSxzREFBR0EsQ0FBQyxRQUFRO1FBQUVnekIsYUFBYXFVO1FBQVdqUixHQUFHLENBQUMsQ0FBQyxFQUFFemhCLFVBQVUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUVBLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFQSxVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFQSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7UUFBRXRNLFdBQVcxSCxvREFBRUEsQ0FBQztZQUFDO1lBQWtDMm1DO1lBQVNqL0I7U0FBVTtJQUFFO0FBQ2xOO0FBQ0EsU0FBU2svQixXQUFXLEVBQUUzTixNQUFNLEVBQUV2eEIsU0FBUyxFQUFFO0lBQ3JDLE9BQVFySSxzREFBR0EsQ0FBQyxVQUFVO1FBQUU4NUIsSUFBSUY7UUFBUUcsSUFBSUg7UUFBUUksR0FBR0o7UUFBUXZ4QixXQUFXMUgsb0RBQUVBLENBQUM7WUFBQztZQUFrQztZQUFRMEg7U0FBVTtJQUFFO0FBQ3BJO0FBRUE7Ozs7O0NBS0MsR0FDRCxJQUFJbS9CO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUc7SUFDN0JBLGlCQUFpQixDQUFDLE9BQU8sR0FBRztJQUM1QkEsaUJBQWlCLENBQUMsUUFBUSxHQUFHO0FBQ2pDLEdBQUdBLHFCQUFzQkEsQ0FBQUEsb0JBQW9CLENBQUM7QUFFOUMsTUFBTUMsY0FBYztJQUNoQixDQUFDRCxrQkFBa0JFLElBQUksQ0FBQyxFQUFFO0lBQzFCLENBQUNGLGtCQUFrQkcsS0FBSyxDQUFDLEVBQUU7SUFDM0IsQ0FBQ0gsa0JBQWtCSSxLQUFLLENBQUMsRUFBRTtBQUMvQjtBQUNBLE1BQU1DLGFBQWEsQ0FBQ25nQyxJQUFPO1FBQUVvSyxXQUFXcEssRUFBRW9LLFNBQVM7UUFBRWcyQixXQUFXLENBQUMsUUFBUSxFQUFFcGdDLEVBQUVLLElBQUksQ0FBQyxDQUFDO0lBQUM7QUFDcEYsU0FBU2dnQyxvQkFBb0IsRUFBRS8vQixFQUFFLEVBQUVzL0IsVUFBVUUsa0JBQWtCRSxJQUFJLEVBQ25FLCtCQUErQjtBQUMvQk0sTUFBTSxFQUFFLEVBQ1IsZ0NBQWdDO0FBQ2hDcjNCLElBQUksRUFBRTAyQixZQUFZLENBQUMsRUFBRXBQLFNBQVMsQ0FBQyxFQUFFbEYsS0FBSyxFQUFFa1YsT0FBTyxFQUFFdmhDLEtBQUssRUFBRTJCLFNBQVMsRUFBRTYvQixnQkFBZ0IsRUFBRztJQUNsRixNQUFNMy9CLE1BQU1qSSw2Q0FBTUEsQ0FBQztJQUNuQixNQUFNLEVBQUV3UixTQUFTLEVBQUVnMkIsU0FBUyxFQUFFLEdBQUc3aEMsU0FBUzRoQyxZQUFZbGlDLG9EQUFPQTtJQUM3RCxNQUFNd2lDLGNBQWN4M0IsUUFBUTgyQixXQUFXLENBQUNILFFBQVE7SUFDaEQsTUFBTWMsU0FBU2QsWUFBWUUsa0JBQWtCRSxJQUFJO0lBQ2pELE1BQU1XLFVBQVVmLFlBQVlFLGtCQUFrQkksS0FBSztJQUNuRCxNQUFNVSxRQUFRNzVCLE1BQU1DLE9BQU8sQ0FBQ3M1QixPQUFPQSxNQUFNO1FBQUNBO1FBQUtBO0tBQUk7SUFDbkQsTUFBTU8sWUFBWTtRQUFDRCxLQUFLLENBQUMsRUFBRSxHQUFHeDJCLFNBQVMsQ0FBQyxFQUFFLElBQUk7UUFBR3cyQixLQUFLLENBQUMsRUFBRSxHQUFHeDJCLFNBQVMsQ0FBQyxFQUFFLElBQUk7S0FBRTtJQUM5RSxNQUFNMDJCLGFBQWFMLGNBQWNyMkIsU0FBUyxDQUFDLEVBQUU7SUFDN0MsTUFBTTIyQixXQUFXaDZCLE1BQU1DLE9BQU8sQ0FBQ3VwQixVQUFVQSxTQUFTO1FBQUNBO1FBQVFBO0tBQU87SUFDbEUsTUFBTXlRLG9CQUFvQkwsVUFBVTtRQUFDRztRQUFZQTtLQUFXLEdBQUdEO0lBQy9ELE1BQU1JLGVBQWU7UUFDakJGLFFBQVEsQ0FBQyxFQUFFLEdBQUczMkIsU0FBUyxDQUFDLEVBQUUsSUFBSSxJQUFJNDJCLGlCQUFpQixDQUFDLEVBQUUsR0FBRztRQUN6REQsUUFBUSxDQUFDLEVBQUUsR0FBRzMyQixTQUFTLENBQUMsRUFBRSxJQUFJLElBQUk0MkIsaUJBQWlCLENBQUMsRUFBRSxHQUFHO0tBQzVEO0lBQ0QsTUFBTUUsYUFBYSxDQUFDLEVBQUVkLFVBQVUsRUFBRTkvQixLQUFLQSxLQUFLLEdBQUcsQ0FBQztJQUNoRCxPQUFRbEksdURBQUlBLENBQUMsT0FBTztRQUFFdUksV0FBVzFILG9EQUFFQSxDQUFDO1lBQUM7WUFBMEIwSDtTQUFVO1FBQUczQixPQUFPO1lBQzNFLEdBQUdBLEtBQUs7WUFDUixHQUFHOFcsY0FBYztZQUNqQiwrQkFBK0J5cUI7WUFDL0IsdUNBQXVDbFY7UUFDM0M7UUFBR3hxQixLQUFLQTtRQUFLLGVBQWU7UUFBa0JOLFVBQVU7WUFBQ2pJLHNEQUFHQSxDQUFDLFdBQVc7Z0JBQUVnSSxJQUFJNGdDO2dCQUFZNzlCLEdBQUcrRyxTQUFTLENBQUMsRUFBRSxHQUFHeTJCLFNBQVMsQ0FBQyxFQUFFO2dCQUFFdjlCLEdBQUc4RyxTQUFTLENBQUMsRUFBRSxHQUFHeTJCLFNBQVMsQ0FBQyxFQUFFO2dCQUFFemhDLE9BQU95aEMsU0FBUyxDQUFDLEVBQUU7Z0JBQUV4aEMsUUFBUXdoQyxTQUFTLENBQUMsRUFBRTtnQkFBRU0sY0FBYztnQkFBa0JDLGtCQUFrQixDQUFDLFdBQVcsRUFBRUgsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUFFMWdDLFVBQVVtZ0MsU0FBVXBvQyxzREFBR0EsQ0FBQ3VuQyxZQUFZO29CQUFFM04sUUFBUTRPLGFBQWE7b0JBQUduZ0MsV0FBVzYvQjtnQkFBaUIsS0FBT2xvQyxzREFBR0EsQ0FBQ29uQyxhQUFhO29CQUFFenlCLFlBQVkrekI7b0JBQW1CckIsV0FBV0E7b0JBQVdDLFNBQVNBO29CQUFTai9CLFdBQVc2L0I7Z0JBQWlCO1lBQUk7WUFBSWxvQyxzREFBR0EsQ0FBQyxRQUFRO2dCQUFFK0ssR0FBRztnQkFBS0MsR0FBRztnQkFBS2xFLE9BQU87Z0JBQVFDLFFBQVE7Z0JBQVFvc0IsTUFBTSxDQUFDLEtBQUssRUFBRXlWLFdBQVcsQ0FBQyxDQUFDO1lBQUM7U0FBRztJQUFDO0FBQ2puQjtBQUNBYixvQkFBb0JyL0IsV0FBVyxHQUFHO0FBQ2xDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0RDLEdBQ0QsTUFBTXFnQywyQkFBYXJvQywyQ0FBSUEsQ0FBQ3FuQztBQUV4QixTQUFTaUI7SUFDTCxPQUFRaHBDLHNEQUFHQSxDQUFDLE9BQU87UUFBRWlwQyxPQUFPO1FBQThCOVUsU0FBUztRQUFhbHNCLFVBQVVqSSxzREFBR0EsQ0FBQyxRQUFRO1lBQUVvMkIsR0FBRztRQUF3RTtJQUFHO0FBQzFMO0FBRUEsU0FBUzhTO0lBQ0wsT0FBUWxwQyxzREFBR0EsQ0FBQyxPQUFPO1FBQUVpcEMsT0FBTztRQUE4QjlVLFNBQVM7UUFBWWxzQixVQUFVakksc0RBQUdBLENBQUMsUUFBUTtZQUFFbzJCLEdBQUc7UUFBaUI7SUFBRztBQUNsSTtBQUVBLFNBQVMrUztJQUNMLE9BQVFucEMsc0RBQUdBLENBQUMsT0FBTztRQUFFaXBDLE9BQU87UUFBOEI5VSxTQUFTO1FBQWFsc0IsVUFBVWpJLHNEQUFHQSxDQUFDLFFBQVE7WUFBRW8yQixHQUFHO1FBQThYO0lBQUc7QUFDaGY7QUFFQSxTQUFTZ1Q7SUFDTCxPQUFRcHBDLHNEQUFHQSxDQUFDLE9BQU87UUFBRWlwQyxPQUFPO1FBQThCOVUsU0FBUztRQUFhbHNCLFVBQVVqSSxzREFBR0EsQ0FBQyxRQUFRO1lBQUVvMkIsR0FBRztRQUFpYztJQUFHO0FBQ25qQjtBQUVBLFNBQVNpVDtJQUNMLE9BQVFycEMsc0RBQUdBLENBQUMsT0FBTztRQUFFaXBDLE9BQU87UUFBOEI5VSxTQUFTO1FBQWFsc0IsVUFBVWpJLHNEQUFHQSxDQUFDLFFBQVE7WUFBRW8yQixHQUFHO1FBQXVZO0lBQUc7QUFDemY7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNELFNBQVNrVCxjQUFjLEVBQUVyaEMsUUFBUSxFQUFFSSxTQUFTLEVBQUUsR0FBR0MsTUFBTTtJQUNuRCxPQUFRdEksc0RBQUdBLENBQUMsVUFBVTtRQUFFZ1UsTUFBTTtRQUFVM0wsV0FBVzFILG9EQUFFQSxDQUFDO1lBQUM7WUFBK0IwSDtTQUFVO1FBQUcsR0FBR0MsSUFBSTtRQUFFTCxVQUFVQTtJQUFTO0FBQ25JO0FBRUEsTUFBTXNoQyxhQUFhLENBQUM3aEMsSUFBTztRQUN2QjhoQyxlQUFlOWhDLEVBQUU4ZCxjQUFjLElBQUk5ZCxFQUFFK25CLGdCQUFnQixJQUFJL25CLEVBQUV3RSxrQkFBa0I7UUFDN0V1OUIsZ0JBQWdCL2hDLEVBQUVvSyxTQUFTLENBQUMsRUFBRSxJQUFJcEssRUFBRXNFLE9BQU87UUFDM0MwOUIsZ0JBQWdCaGlDLEVBQUVvSyxTQUFTLENBQUMsRUFBRSxJQUFJcEssRUFBRXVFLE9BQU87UUFDM0NwRSxpQkFBaUJILEVBQUVHLGVBQWU7SUFDdEM7QUFDQSxTQUFTOGhDLGtCQUFrQixFQUFFampDLEtBQUssRUFBRWtqQyxXQUFXLElBQUksRUFBRUMsY0FBYyxJQUFJLEVBQUVDLGtCQUFrQixJQUFJLEVBQUVoOUIsY0FBYyxFQUFFaTlCLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLG1CQUFtQixFQUFFN2hDLFNBQVMsRUFBRUosUUFBUSxFQUFFcEIsV0FBVyxhQUFhLEVBQUVzakMsY0FBYyxVQUFVLEVBQUUsY0FBYzFZLFNBQVMsRUFBRztJQUNyUSxNQUFNcnJCLFFBQVFFO0lBQ2QsTUFBTSxFQUFFa2pDLGFBQWEsRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEVBQUU3aEMsZUFBZSxFQUFFLEdBQUc1QixTQUFTc2pDLFlBQVk1akMsb0RBQU9BO0lBQ3ZHLE1BQU0sRUFBRXdMLE1BQU0sRUFBRU0sT0FBTyxFQUFFNEssT0FBTyxFQUFFLEdBQUduRTtJQUNyQyxNQUFNa3lCLGtCQUFrQjtRQUNwQmo1QjtRQUNBNDRCO0lBQ0o7SUFDQSxNQUFNTSxtQkFBbUI7UUFDckI1NEI7UUFDQXU0QjtJQUNKO0lBQ0EsTUFBTU0sbUJBQW1CO1FBQ3JCanVCLFFBQVF2UDtRQUNSbTlCO0lBQ0o7SUFDQSxNQUFNTSx3QkFBd0I7UUFDMUJua0MsTUFBTUksUUFBUSxDQUFDO1lBQ1hnZixnQkFBZ0IsQ0FBQ2drQjtZQUNqQi9aLGtCQUFrQixDQUFDK1o7WUFDbkJ0OUIsb0JBQW9CLENBQUNzOUI7UUFDekI7UUFDQVUsc0JBQXNCLENBQUNWO0lBQzNCO0lBQ0EsTUFBTWdCLG1CQUFtQkwsZ0JBQWdCLGVBQWUsZUFBZTtJQUN2RSxPQUFRcnFDLHVEQUFJQSxDQUFDc0ksT0FBTztRQUFFQyxXQUFXMUgsb0RBQUVBLENBQUM7WUFBQztZQUF3QjZwQztZQUFrQm5pQztTQUFVO1FBQUd4QixVQUFVQTtRQUFVSCxPQUFPQTtRQUFPLGVBQWU7UUFBZ0IsY0FBYytxQixhQUFhNXBCLGVBQWUsQ0FBQyxxQkFBcUI7UUFBRUksVUFBVTtZQUFDMmhDLFlBQWE5cEMsdURBQUlBLENBQUNDLHVEQUFRQSxFQUFFO2dCQUFFa0ksVUFBVTtvQkFBQ2pJLHNEQUFHQSxDQUFDc3BDLGVBQWU7d0JBQUV6bkIsU0FBU3VvQjt3QkFBaUIvaEMsV0FBVzt3QkFBK0JvaUMsT0FBTzVpQyxlQUFlLENBQUMsNEJBQTRCO3dCQUFFLGNBQWNBLGVBQWUsQ0FBQyw0QkFBNEI7d0JBQUUrYyxVQUFVOGtCO3dCQUFnQnpoQyxVQUFVakksc0RBQUdBLENBQUNncEMsVUFBVSxDQUFDO29CQUFHO29CQUFJaHBDLHNEQUFHQSxDQUFDc3BDLGVBQWU7d0JBQUV6bkIsU0FBU3dvQjt3QkFBa0JoaUMsV0FBVzt3QkFBZ0NvaUMsT0FBTzVpQyxlQUFlLENBQUMsNkJBQTZCO3dCQUFFLGNBQWNBLGVBQWUsQ0FBQyw2QkFBNkI7d0JBQUUrYyxVQUFVNmtCO3dCQUFnQnhoQyxVQUFVakksc0RBQUdBLENBQUNrcEMsV0FBVyxDQUFDO29CQUFHO2lCQUFHO1lBQUM7WUFBS1csZUFBZ0I3cEMsc0RBQUdBLENBQUNzcEMsZUFBZTtnQkFBRWpoQyxXQUFXO2dCQUFnQ3daLFNBQVN5b0I7Z0JBQWtCRyxPQUFPNWlDLGVBQWUsQ0FBQyw2QkFBNkI7Z0JBQUUsY0FBY0EsZUFBZSxDQUFDLDZCQUE2QjtnQkFBRUksVUFBVWpJLHNEQUFHQSxDQUFDbXBDLGFBQWEsQ0FBQztZQUFHO1lBQUtXLG1CQUFvQjlwQyxzREFBR0EsQ0FBQ3NwQyxlQUFlO2dCQUFFamhDLFdBQVc7Z0JBQW9Dd1osU0FBUzBvQjtnQkFBdUJFLE9BQU81aUMsZUFBZSxDQUFDLGlDQUFpQztnQkFBRSxjQUFjQSxlQUFlLENBQUMsaUNBQWlDO2dCQUFFSSxVQUFVdWhDLGdCQUFnQnhwQyxzREFBR0EsQ0FBQ3FwQyxZQUFZLENBQUMsS0FBS3JwQyxzREFBR0EsQ0FBQ29wQyxVQUFVLENBQUM7WUFBRztZQUFLbmhDO1NBQVM7SUFBQztBQUMvMkM7QUFDQTBoQyxrQkFBa0JqaEMsV0FBVyxHQUFHO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNELE1BQU1naUMseUJBQVdocUMsMkNBQUlBLENBQUNpcEM7QUFFdEIsU0FBU2dCLHFCQUFxQixFQUFFM2lDLEVBQUUsRUFBRStDLENBQUMsRUFBRUMsQ0FBQyxFQUFFbEUsS0FBSyxFQUFFQyxNQUFNLEVBQUVMLEtBQUssRUFBRXFzQixLQUFLLEVBQUU2WCxXQUFXLEVBQUU1WCxXQUFXLEVBQUUzcUIsU0FBUyxFQUFFMnZCLFlBQVksRUFBRTZTLGNBQWMsRUFBRXZoQyxRQUFRLEVBQUV1WSxPQUFPLEVBQUc7SUFDMUosTUFBTSxFQUFFaXBCLFVBQVUsRUFBRUMsZUFBZSxFQUFFLEdBQUdya0MsU0FBUyxDQUFDO0lBQ2xELE1BQU15c0IsT0FBUUosU0FBUytYLGNBQWNDO0lBQ3JDLE9BQVEvcUMsc0RBQUdBLENBQUMsUUFBUTtRQUFFcUksV0FBVzFILG9EQUFFQSxDQUFDO1lBQUM7WUFBNEI7Z0JBQUUySTtZQUFTO1lBQUdqQjtTQUFVO1FBQUcwQyxHQUFHQTtRQUFHQyxHQUFHQTtRQUFHMnFCLElBQUlxQztRQUFjcEMsSUFBSW9DO1FBQWNseEIsT0FBT0E7UUFBT0MsUUFBUUE7UUFBUUwsT0FBTztZQUN6S3lzQjtZQUNBRixRQUFRMlg7WUFDUjVYO1FBQ0o7UUFBRzZYLGdCQUFnQkE7UUFBZ0JocEIsU0FBU0EsVUFBVSxDQUFDeFMsUUFBVXdTLFFBQVF4UyxPQUFPckgsTUFBTXdNO0lBQVU7QUFDeEc7QUFDQSxNQUFNdzJCLDRCQUFjdHFDLDJDQUFJQSxDQUFDaXFDO0FBRXpCLE1BQU1NLGtCQUFrQixDQUFDdmpDLElBQU1BLEVBQUUyQyxLQUFLLENBQUNKLEdBQUcsQ0FBQyxDQUFDYixPQUFTQSxLQUFLcEIsRUFBRTtBQUM1RCxNQUFNa2pDLGtCQUFrQixDQUFDQyxPQUFTQSxnQkFBZ0JDLFdBQVdELE9BQU8sSUFBTUE7QUFDMUUsU0FBU0UsYUFBYSxFQUFFQyxlQUFlLEVBQUVDLFNBQVMsRUFBRUMsZ0JBQWdCLEVBQUUsRUFBRUMsbUJBQW1CLENBQUMsRUFBRUMsZUFBZSxFQUM3Rzs7O0NBR0MsR0FDREMsZUFBZTdiLGdCQUFnQmtiLFdBQVcsRUFBRW5wQixPQUFPLEVBQUc7SUFDbEQsTUFBTWtNLFVBQVU5bkIsU0FBU2dsQyxpQkFBaUJ0bEMsb0RBQU9BO0lBQ2pELE1BQU1pbUMsZ0JBQWdCVixnQkFBZ0JLO0lBQ3RDLE1BQU1NLHNCQUFzQlgsZ0JBQWdCSTtJQUM1QyxNQUFNUSxvQkFBb0JaLGdCQUFnQk07SUFDMUMsTUFBTVgsaUJBQWlCLEtBQWdELEdBQUcsZUFBZTtJQUN6RixPQUFRN3FDLHNEQUFHQSxDQUFDRCx1REFBUUEsRUFBRTtRQUFFa0ksVUFBVThsQixRQUFROWpCLEdBQUcsQ0FBQyxDQUFDK1IsU0FDM0M7Ozs7OztTQU1DLEdBQ0RoYyxzREFBR0EsQ0FBQ2dzQyxzQkFBc0I7Z0JBQUVoa0MsSUFBSWdVO2dCQUFRNHZCLGVBQWVBO2dCQUFlQyxxQkFBcUJBO2dCQUFxQkMsbUJBQW1CQTtnQkFBbUJMLGtCQUFrQkE7Z0JBQWtCQyxpQkFBaUJBO2dCQUFpQjViLGVBQWVBO2dCQUFlak8sU0FBU0E7Z0JBQVNncEIsZ0JBQWdCQTtZQUFlLEdBQUc3dUI7SUFBVTtBQUNoVTtBQUNBLFNBQVNpd0IsMEJBQTBCLEVBQUVqa0MsRUFBRSxFQUFFNGpDLGFBQWEsRUFBRUMsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFTCxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFYixjQUFjLEVBQUUvYSxhQUFhLEVBQUVqTyxPQUFPLEVBQUc7SUFDeEssTUFBTSxFQUFFelksSUFBSSxFQUFFMkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVsRSxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHZCxTQUFTLENBQUN5QjtRQUM1QyxNQUFNLEVBQUU4QixTQUFTLEVBQUUsR0FBRzlCLEVBQUUyQixVQUFVLENBQUM4SyxHQUFHLENBQUNuTTtRQUN2QyxNQUFNb0IsT0FBT0ksVUFBVUMsUUFBUTtRQUMvQixNQUFNLEVBQUVzQixDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHeEIsVUFBVTRSLGdCQUFnQjtRQUMzQyxNQUFNLEVBQUV0VSxLQUFLLEVBQUVDLE1BQU0sRUFBRSxHQUFHaEUsaUVBQWlCQSxDQUFDcUc7UUFDNUMsT0FBTztZQUNIQTtZQUNBMkI7WUFDQUM7WUFDQWxFO1lBQ0FDO1FBQ0o7SUFDSixHQUFHcEIsb0RBQU9BO0lBQ1YsSUFBSSxDQUFDeUQsUUFBUUEsS0FBSzRsQixNQUFNLElBQUksQ0FBQ2xzQixpRUFBaUJBLENBQUNzRyxPQUFPO1FBQ2xELE9BQU87SUFDWDtJQUNBLE9BQVFwSixzREFBR0EsQ0FBQzh2QixlQUFlO1FBQUUva0IsR0FBR0E7UUFBR0MsR0FBR0E7UUFBR2xFLE9BQU9BO1FBQU9DLFFBQVFBO1FBQVFMLE9BQU8wQyxLQUFLMUMsS0FBSztRQUFFNEMsVUFBVSxDQUFDLENBQUNGLEtBQUtFLFFBQVE7UUFBRWpCLFdBQVd5akMsa0JBQWtCMWlDO1FBQU8ycEIsT0FBTzZZLGNBQWN4aUM7UUFBTzR1QixjQUFjeVQ7UUFBa0JiLGFBQWFpQixvQkFBb0J6aUM7UUFBTzRwQixhQUFhMFk7UUFBaUJiLGdCQUFnQkE7UUFBZ0JocEIsU0FBU0E7UUFBUzdaLElBQUlvQixLQUFLcEIsRUFBRTtJQUFDO0FBQzdWO0FBQ0EsTUFBTWdrQyxxQ0FBdUJ0ckMsMkNBQUlBLENBQUN1ckM7QUFDbEMsSUFBSUMsK0JBQWlCeHJDLDJDQUFJQSxDQUFDMnFDO0FBRTFCLE1BQU1jLGVBQWU7QUFDckIsTUFBTUMsZ0JBQWdCO0FBQ3RCLE1BQU1DLGVBQWUsQ0FBQ2pqQyxPQUFTLENBQUNBLEtBQUs0bEIsTUFBTTtBQUMzQyxNQUFNc2QsYUFBYSxDQUFDNWtDO0lBQ2hCLE1BQU02a0MsU0FBUztRQUNYeGhDLEdBQUcsQ0FBQ3JELEVBQUVvSyxTQUFTLENBQUMsRUFBRSxHQUFHcEssRUFBRW9LLFNBQVMsQ0FBQyxFQUFFO1FBQ25DOUcsR0FBRyxDQUFDdEQsRUFBRW9LLFNBQVMsQ0FBQyxFQUFFLEdBQUdwSyxFQUFFb0ssU0FBUyxDQUFDLEVBQUU7UUFDbkNoTCxPQUFPWSxFQUFFWixLQUFLLEdBQUdZLEVBQUVvSyxTQUFTLENBQUMsRUFBRTtRQUMvQi9LLFFBQVFXLEVBQUVYLE1BQU0sR0FBR1csRUFBRW9LLFNBQVMsQ0FBQyxFQUFFO0lBQ3JDO0lBQ0EsT0FBTztRQUNIeTZCO1FBQ0FDLGNBQWM5a0MsRUFBRTJCLFVBQVUsQ0FBQ3NILElBQUksR0FBRyxJQUM1QjlMLGdFQUFnQkEsQ0FBQ2pDLHNFQUFzQkEsQ0FBQzhFLEVBQUUyQixVQUFVLEVBQUU7WUFBRXVGLFFBQVF5OUI7UUFBYSxJQUFJRSxVQUNqRkE7UUFDTnhrQyxNQUFNTCxFQUFFSyxJQUFJO1FBQ1pxSixTQUFTMUosRUFBRTBKLE9BQU87UUFDbEJ0RixpQkFBaUJwRSxFQUFFb0UsZUFBZTtRQUNsQzJnQyxXQUFXL2tDLEVBQUVaLEtBQUs7UUFDbEI0bEMsWUFBWWhsQyxFQUFFWCxNQUFNO1FBQ3BCYyxpQkFBaUJILEVBQUVHLGVBQWU7SUFDdEM7QUFDSjtBQUNBLE1BQU04a0MsaUJBQWlCO0FBQ3ZCLFNBQVNDLGlCQUFpQixFQUFFbG1DLEtBQUssRUFBRTJCLFNBQVMsRUFBRWlqQyxlQUFlLEVBQUVDLFNBQVMsRUFBRUMsZ0JBQWdCLEVBQUUsRUFBRUMsbUJBQW1CLENBQUMsRUFBRUMsZUFBZSxFQUNuSTs7O0NBR0MsR0FDREMsYUFBYSxFQUFFMUQsT0FBTyxFQUFFNEUsU0FBUyxFQUFFQyxlQUFlLEVBQUVDLGVBQWUsRUFBRWxtQyxXQUFXLGNBQWMsRUFBRWdiLE9BQU8sRUFBRXFRLFdBQVcsRUFBRThhLFdBQVcsS0FBSyxFQUFFQyxXQUFXLEtBQUssRUFBRXhiLFNBQVMsRUFBRXliLFVBQVUsRUFBRUMsV0FBVyxDQUFDLEVBQUVDLGNBQWMsQ0FBQyxFQUFHO0lBQzdNLE1BQU1obkMsUUFBUUU7SUFDZCxNQUFNK21DLE1BQU0vc0MsNkNBQU1BLENBQUM7SUFDbkIsTUFBTSxFQUFFa3NDLFlBQVksRUFBRUQsTUFBTSxFQUFFeGtDLElBQUksRUFBRXFKLE9BQU8sRUFBRXRGLGVBQWUsRUFBRTJnQyxTQUFTLEVBQUVDLFVBQVUsRUFBRTdrQyxlQUFlLEVBQUUsR0FBRzVCLFNBQVNxbUMsWUFBWTNtQyxvREFBT0E7SUFDckksTUFBTTJuQyxlQUFlNW1DLE9BQU9JLFNBQVNxbEM7SUFDckMsTUFBTW9CLGdCQUFnQjdtQyxPQUFPSyxVQUFVcWxDO0lBQ3ZDLE1BQU1vQixjQUFjaEIsYUFBYTFsQyxLQUFLLEdBQUd3bUM7SUFDekMsTUFBTUcsZUFBZWpCLGFBQWF6bEMsTUFBTSxHQUFHd21DO0lBQzNDLE1BQU1HLFlBQVl0cUIsS0FBSzRlLEdBQUcsQ0FBQ3dMLGFBQWFDO0lBQ3hDLE1BQU1FLFlBQVlELFlBQVlKO0lBQzlCLE1BQU1NLGFBQWFGLFlBQVlIO0lBQy9CLE1BQU10VixTQUFTbVYsY0FBY007SUFDN0IsTUFBTTNpQyxJQUFJeWhDLGFBQWF6aEMsQ0FBQyxHQUFHLENBQUM0aUMsWUFBWW5CLGFBQWExbEMsS0FBSyxJQUFJLElBQUlteEI7SUFDbEUsTUFBTWp0QixJQUFJd2hDLGFBQWF4aEMsQ0FBQyxHQUFHLENBQUM0aUMsYUFBYXBCLGFBQWF6bEMsTUFBTSxJQUFJLElBQUlreEI7SUFDcEUsTUFBTW54QixRQUFRNm1DLFlBQVkxVixTQUFTO0lBQ25DLE1BQU1seEIsU0FBUzZtQyxhQUFhM1YsU0FBUztJQUNyQyxNQUFNNFYsYUFBYSxDQUFDLEVBQUVsQixlQUFlLENBQUMsRUFBRTVrQyxLQUFLLENBQUM7SUFDOUMsTUFBTStsQyxlQUFleHRDLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU15dEMsa0JBQWtCenRDLDZDQUFNQTtJQUM5Qnd0QyxhQUFhcmhDLE9BQU8sR0FBR2loQztJQUN2QnJ0QyxnREFBU0EsQ0FBQztRQUNOLElBQUlndEMsSUFBSTVnQyxPQUFPLElBQUkyRSxTQUFTO1lBQ3hCMjhCLGdCQUFnQnRoQyxPQUFPLEdBQUc3SCx5REFBU0EsQ0FBQztnQkFDaENrTyxTQUFTdTZCLElBQUk1Z0MsT0FBTztnQkFDcEIyRTtnQkFDQWdZLGNBQWMsSUFBTWhqQixNQUFNRyxRQUFRLEdBQUd1TCxTQUFTO2dCQUM5Q2s4QixjQUFjLElBQU1GLGFBQWFyaEMsT0FBTztZQUM1QztZQUNBLE9BQU87Z0JBQ0hzaEMsZ0JBQWdCdGhDLE9BQU8sRUFBRXdUO1lBQzdCO1FBQ0o7SUFDSixHQUFHO1FBQUM3TztLQUFRO0lBQ1ovUSxnREFBU0EsQ0FBQztRQUNOMHRDLGdCQUFnQnRoQyxPQUFPLEVBQUV5VCxPQUFPO1lBQzVCcFU7WUFDQWhGLE9BQU8ybEM7WUFDUDFsQyxRQUFRMmxDO1lBQ1JRO1lBQ0FGO1lBQ0FHO1lBQ0FGO1FBQ0o7SUFDSixHQUFHO1FBQUNEO1FBQVVDO1FBQVVDO1FBQVlDO1FBQVVyaEM7UUFBaUIyZ0M7UUFBV0M7S0FBVztJQUNyRixNQUFNdUIsYUFBYXBzQixVQUNiLENBQUN4UztRQUNDLE1BQU0sQ0FBQ3RFLEdBQUdDLEVBQUUsR0FBRytpQyxnQkFBZ0J0aEMsT0FBTyxFQUFFd3lCLFFBQVE1dkIsVUFBVTtZQUFDO1lBQUc7U0FBRTtRQUNoRXdTLFFBQVF4UyxPQUFPO1lBQUV0RTtZQUFHQztRQUFFO0lBQzFCLElBQ0V3SjtJQUNOLE1BQU0wNUIsaUJBQWlCaGMsY0FDakJ6eEIsa0RBQVdBLENBQUMsQ0FBQzRPLE9BQU8yTTtRQUNsQixNQUFNNVMsT0FBT2hELE1BQU1HLFFBQVEsR0FBRzhDLFVBQVUsQ0FBQzhLLEdBQUcsQ0FBQzZILFFBQVF4UyxTQUFTLENBQUNDLFFBQVE7UUFDdkV5b0IsWUFBWTdpQixPQUFPakc7SUFDdkIsR0FBRyxFQUFFLElBQ0hvTDtJQUNOLE1BQU0yNUIsYUFBYTFjLGFBQWE1cEIsZUFBZSxDQUFDLG9CQUFvQjtJQUNwRSxPQUFRN0gsc0RBQUdBLENBQUNvSSxPQUFPO1FBQUV2QixVQUFVQTtRQUFVSCxPQUFPO1lBQ3hDLEdBQUdBLEtBQUs7WUFDUix1Q0FBdUMsT0FBT3VoQyxZQUFZLFdBQVdBLFVBQVV6ekI7WUFDL0UsNENBQTRDLE9BQU9xNEIsY0FBYyxXQUFXQSxZQUFZcjRCO1lBQ3hGLHdDQUF3QyxPQUFPczRCLG9CQUFvQixXQUFXQSxrQkFBa0J0NEI7WUFDaEcsd0NBQXdDLE9BQU91NEIsb0JBQW9CLFdBQVdBLGtCQUFrQlcsWUFBWWw1QjtZQUM1Ryw0Q0FBNEMsT0FBTysyQixjQUFjLFdBQVdBLFlBQVkvMkI7WUFDeEYsd0NBQXdDLE9BQU84MkIsb0JBQW9CLFdBQVdBLGtCQUFrQjkyQjtZQUNoRyx3Q0FBd0MsT0FBT2szQixvQkFBb0IsV0FBV0Esa0JBQWtCbDNCO1FBQ3BHO1FBQUduTSxXQUFXMUgsb0RBQUVBLENBQUM7WUFBQztZQUF1QjBIO1NBQVU7UUFBRyxlQUFlO1FBQWVKLFVBQVVuSSx1REFBSUEsQ0FBQyxPQUFPO1lBQUVnSCxPQUFPd21DO1lBQWN2bUMsUUFBUXdtQztZQUFlcFosU0FBUyxDQUFDLEVBQUVwcEIsRUFBRSxDQUFDLEVBQUVDLEVBQUUsQ0FBQyxFQUFFbEUsTUFBTSxDQUFDLEVBQUVDLE9BQU8sQ0FBQztZQUFFc0IsV0FBVztZQUEyQmtwQixNQUFNO1lBQU8sbUJBQW1Cc2M7WUFBWXRsQyxLQUFLOGtDO1lBQUt4ckIsU0FBU29zQjtZQUFZaG1DLFVBQVU7Z0JBQUNrbUMsY0FBY251QyxzREFBR0EsQ0FBQyxTQUFTO29CQUFFZ0ksSUFBSTZsQztvQkFBWTVsQyxVQUFVa21DO2dCQUFXO2dCQUFJbnVDLHNEQUFHQSxDQUFDa3NDLGdCQUFnQjtvQkFBRXJxQixTQUFTcXNCO29CQUFnQjNDLFdBQVdBO29CQUFXRCxpQkFBaUJBO29CQUFpQkcsa0JBQWtCQTtvQkFBa0JELGVBQWVBO29CQUFlRSxpQkFBaUJBO29CQUFpQkMsZUFBZUE7Z0JBQWM7Z0JBQUkzckMsc0RBQUdBLENBQUMsUUFBUTtvQkFBRXFJLFdBQVc7b0JBQTRCK3RCLEdBQUcsQ0FBQyxDQUFDLEVBQUVyckIsSUFBSWt0QixPQUFPLENBQUMsRUFBRWp0QixJQUFJaXRCLE9BQU8sQ0FBQyxFQUFFbnhCLFFBQVFteEIsU0FBUyxFQUFFLENBQUMsRUFBRWx4QixTQUFTa3hCLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQ254QixRQUFRbXhCLFNBQVMsRUFBRTtTQUN2d0IsRUFBRXNVLE9BQU94aEMsQ0FBQyxDQUFDLENBQUMsRUFBRXdoQyxPQUFPdmhDLENBQUMsQ0FBQyxDQUFDLEVBQUV1aEMsT0FBT3psQyxLQUFLLENBQUMsQ0FBQyxFQUFFeWxDLE9BQU94bEMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDd2xDLE9BQU96bEMsS0FBSyxDQUFDLENBQUMsQ0FBQztvQkFBRXNuQyxVQUFVO29CQUFXL2MsZUFBZTtnQkFBTzthQUFHO1FBQUM7SUFBRztBQUN4STtBQUNBdWIsaUJBQWlCbGtDLFdBQVcsR0FBRztBQUMvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELE1BQU0ybEMsd0JBQVUzdEMsMkNBQUlBLENBQUNrc0M7QUFFckIsTUFBTTBCLGdCQUFnQixDQUFDQyxpQkFBbUIsQ0FBQ25vQyxRQUFVbW9DLGlCQUFpQixDQUFDLEVBQUVuckIsS0FBSzRlLEdBQUcsQ0FBQyxJQUFJNTdCLE1BQU0wTCxTQUFTLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxHQUFHMEM7QUFDakgsTUFBTWc2QixtQkFBbUI7SUFDckIsQ0FBQzFwQyxnRUFBb0JBLENBQUMycEMsSUFBSSxDQUFDLEVBQUU7SUFDN0IsQ0FBQzNwQyxnRUFBb0JBLENBQUNpbUIsTUFBTSxDQUFDLEVBQUU7QUFDbkM7QUFDQSxTQUFTMmpCLGNBQWMsRUFBRTF5QixNQUFNLEVBQUVuVixRQUFRLEVBQUV5Z0MsVUFBVXhpQyxnRUFBb0JBLENBQUNpbUIsTUFBTSxFQUFFMWlCLFNBQVMsRUFBRTNCLFFBQVE4TixTQUFTLEVBQUV2TSxRQUFRLEVBQUU4cUIsS0FBSyxFQUFFNGIsV0FBVyxFQUFFLEVBQUVDLFlBQVksRUFBRSxFQUFFQyxXQUFXQyxPQUFPQyxTQUFTLEVBQUVDLFlBQVlGLE9BQU9DLFNBQVMsRUFBRUUsa0JBQWtCLEtBQUssRUFBRUMsZUFBZSxFQUFFQyxZQUFZLElBQUksRUFBRUMsWUFBWSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRUMsV0FBVyxFQUFHO0lBQ3hVLE1BQU1DLGdCQUFnQmhwQjtJQUN0QixNQUFNeGUsS0FBSyxPQUFPZ1UsV0FBVyxXQUFXQSxTQUFTd3pCO0lBQ2pELE1BQU1wcEMsUUFBUUU7SUFDZCxNQUFNbXBDLG1CQUFtQm52Qyw2Q0FBTUEsQ0FBQztJQUNoQyxNQUFNb3ZDLGtCQUFrQnBJLFlBQVl4aUMsZ0VBQW9CQSxDQUFDaW1CLE1BQU07SUFDL0QsTUFBTTRrQixRQUFRMXBDLFNBQVN4RixrREFBV0EsQ0FBQzZ0QyxjQUFjb0IsbUJBQW1CUCxZQUFZO1FBQUNPO1FBQWlCUDtLQUFVLEdBQUd4cEMsb0RBQU9BO0lBQ3RILE1BQU1pcUMsVUFBVXR2Qyw2Q0FBTUEsQ0FBQztJQUN2QixNQUFNdXZDLGtCQUFrQmhwQyxZQUFZMm5DLGdCQUFnQixDQUFDbEgsUUFBUTtJQUM3RGpuQyxnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ292QyxpQkFBaUJoakMsT0FBTyxJQUFJLENBQUN6RSxJQUFJO1lBQ2xDO1FBQ0o7UUFDQSxJQUFJLENBQUM0bkMsUUFBUW5qQyxPQUFPLEVBQUU7WUFDbEJtakMsUUFBUW5qQyxPQUFPLEdBQUcxSCx5REFBU0EsQ0FBQztnQkFDeEIrTixTQUFTMjhCLGlCQUFpQmhqQyxPQUFPO2dCQUNqQ3VQLFFBQVFoVTtnQkFDUm1kLGVBQWU7b0JBQ1gsTUFBTSxFQUFFOWIsVUFBVSxFQUFFeUksU0FBUyxFQUFFYyxRQUFRLEVBQUVDLFVBQVUsRUFBRTlHLFVBQVUsRUFBRStHLE9BQU8sRUFBRSxHQUFHMU0sTUFBTUcsUUFBUTtvQkFDM0YsT0FBTzt3QkFDSDhDO3dCQUNBeUk7d0JBQ0FjO3dCQUNBQzt3QkFDQTlHO3dCQUNBK2pDLGFBQWFoOUI7b0JBQ2pCO2dCQUNKO2dCQUNBNnlCLFVBQVUsQ0FBQzV4QixRQUFRZzhCO29CQUNmLE1BQU0sRUFBRTkxQixrQkFBa0IsRUFBRTVRLFVBQVUsRUFBRXdtQixZQUFZLEVBQUU5akIsVUFBVSxFQUFFLEdBQUczRixNQUFNRyxRQUFRO29CQUNuRixNQUFNa04sVUFBVSxFQUFFO29CQUNsQixNQUFNNFMsZUFBZTt3QkFBRXRiLEdBQUdnSixPQUFPaEosQ0FBQzt3QkFBRUMsR0FBRytJLE9BQU8vSSxDQUFDO29CQUFDO29CQUNoRCxNQUFNNUIsT0FBT0MsV0FBVzhLLEdBQUcsQ0FBQ25NO29CQUM1QixJQUFJb0IsUUFBUUEsS0FBSzI0QixZQUFZLElBQUkzNEIsS0FBS3FQLFFBQVEsRUFBRTt3QkFDNUMsTUFBTXUzQixTQUFTNW1DLEtBQUs0bUMsTUFBTSxJQUFJamtDO3dCQUM5QixNQUFNakYsUUFBUWlOLE9BQU9qTixLQUFLLElBQUlzQyxLQUFLd0wsUUFBUSxDQUFDOU4sS0FBSyxJQUFJO3dCQUNyRCxNQUFNQyxTQUFTZ04sT0FBT2hOLE1BQU0sSUFBSXFDLEtBQUt3TCxRQUFRLENBQUM3TixNQUFNLElBQUk7d0JBQ3hELE1BQU1rcEMsUUFBUTs0QkFDVmpvQyxJQUFJb0IsS0FBS3BCLEVBQUU7NEJBQ1h5USxVQUFVclAsS0FBS3FQLFFBQVE7NEJBQ3ZCeXBCLE1BQU07Z0NBQ0ZwN0I7Z0NBQ0FDO2dDQUNBLEdBQUdwRix3RUFBd0JBLENBQUM7b0NBQ3hCb0osR0FBR2dKLE9BQU9oSixDQUFDLElBQUkzQixLQUFLdkMsUUFBUSxDQUFDa0UsQ0FBQztvQ0FDOUJDLEdBQUcrSSxPQUFPL0ksQ0FBQyxJQUFJNUIsS0FBS3ZDLFFBQVEsQ0FBQ21FLENBQUM7Z0NBQ2xDLEdBQUc7b0NBQUVsRTtvQ0FBT0M7Z0NBQU8sR0FBR3FDLEtBQUtxUCxRQUFRLEVBQUVwUCxZQUFZMm1DLE9BQU87NEJBQzVEO3dCQUNKO3dCQUNBLE1BQU03TixzQkFBc0I5OUIsa0VBQWtCQSxDQUFDOzRCQUFDNHJDO3lCQUFNLEVBQUU1bUMsWUFBWXdtQixjQUFjOWpCO3dCQUNsRjBILFFBQVFsSyxJQUFJLElBQUk0NEI7d0JBQ2hCOzs7eUJBR0MsR0FDRDliLGFBQWF0YixDQUFDLEdBQUdnSixPQUFPaEosQ0FBQyxHQUFHcVksS0FBSzRlLEdBQUcsQ0FBQ2dPLE1BQU0sQ0FBQyxFQUFFLEdBQUdscEMsT0FBT2lOLE9BQU9oSixDQUFDLElBQUl5Sjt3QkFDcEU2UixhQUFhcmIsQ0FBQyxHQUFHK0ksT0FBTy9JLENBQUMsR0FBR29ZLEtBQUs0ZSxHQUFHLENBQUNnTyxNQUFNLENBQUMsRUFBRSxHQUFHanBDLFFBQVFnTixPQUFPL0ksQ0FBQyxJQUFJd0o7b0JBQ3pFO29CQUNBLElBQUk2UixhQUFhdGIsQ0FBQyxLQUFLeUosYUFBYTZSLGFBQWFyYixDQUFDLEtBQUt3SixXQUFXO3dCQUM5RCxNQUFNMDdCLGlCQUFpQjs0QkFDbkJsb0M7NEJBQ0FnTSxNQUFNOzRCQUNObk4sVUFBVTtnQ0FBRSxHQUFHd2YsWUFBWTs0QkFBQzt3QkFDaEM7d0JBQ0E1UyxRQUFRbEssSUFBSSxDQUFDMm1DO29CQUNqQjtvQkFDQSxJQUFJbjhCLE9BQU9qTixLQUFLLEtBQUswTixhQUFhVCxPQUFPaE4sTUFBTSxLQUFLeU4sV0FBVzt3QkFDM0QsTUFBTUssZ0JBQWdCLENBQUNxNkIsa0JBQWtCLE9BQU9BLG9CQUFvQixlQUFlLFVBQVU7d0JBQzdGLE1BQU1pQixrQkFBa0I7NEJBQ3BCbm9DOzRCQUNBZ00sTUFBTTs0QkFDTmMsVUFBVTs0QkFDVkQ7NEJBQ0FGLFlBQVk7Z0NBQ1I3TixPQUFPaU4sT0FBT2pOLEtBQUs7Z0NBQ25CQyxRQUFRZ04sT0FBT2hOLE1BQU07NEJBQ3pCO3dCQUNKO3dCQUNBME0sUUFBUWxLLElBQUksQ0FBQzRtQztvQkFDakI7b0JBQ0EsS0FBSyxNQUFNQyxlQUFlTCxhQUFjO3dCQUNwQyxNQUFNRyxpQkFBaUI7NEJBQ25CLEdBQUdFLFdBQVc7NEJBQ2RwOEIsTUFBTTt3QkFDVjt3QkFDQVAsUUFBUWxLLElBQUksQ0FBQzJtQztvQkFDakI7b0JBQ0FqMkIsbUJBQW1CeEc7Z0JBQ3ZCO2dCQUNBbXlCLE9BQU8sQ0FBQyxFQUFFOStCLEtBQUssRUFBRUMsTUFBTSxFQUFFO29CQUNyQixNQUFNb3BDLGtCQUFrQjt3QkFDcEJub0MsSUFBSUE7d0JBQ0pnTSxNQUFNO3dCQUNOYyxVQUFVO3dCQUNWSCxZQUFZOzRCQUNSN047NEJBQ0FDO3dCQUNKO29CQUNKO29CQUNBWCxNQUFNRyxRQUFRLEdBQUcwVCxrQkFBa0IsQ0FBQzt3QkFBQ2syQjtxQkFBZ0I7Z0JBQ3pEO1lBQ0o7UUFDSjtRQUNBUCxRQUFRbmpDLE9BQU8sQ0FBQ3lULE1BQU0sQ0FBQztZQUNuQjJ2QjtZQUNBUSxZQUFZO2dCQUNSMUI7Z0JBQ0FDO2dCQUNBQztnQkFDQUc7WUFDSjtZQUNBQztZQUNBQztZQUNBRztZQUNBQztZQUNBQztZQUNBSDtRQUNKO1FBQ0EsT0FBTztZQUNIUSxRQUFRbmpDLE9BQU8sRUFBRXdUO1FBQ3JCO0lBQ0osR0FBRztRQUNDNHZCO1FBQ0FsQjtRQUNBQztRQUNBQztRQUNBRztRQUNBQztRQUNBSTtRQUNBQztRQUNBQztRQUNBSDtLQUNIO0lBQ0QsTUFBTWtCLHFCQUFxQlQsZ0JBQWdCcG5DLEtBQUssQ0FBQztJQUNqRCxPQUFRekksc0RBQUdBLENBQUMsT0FBTztRQUFFcUksV0FBVzFILG9EQUFFQSxDQUFDO1lBQUM7WUFBOEI7ZUFBYTJ2QztZQUFvQmhKO1lBQVNqL0I7U0FBVTtRQUFHRSxLQUFLa25DO1FBQWtCL29DLE9BQU87WUFDL0ksR0FBR0EsS0FBSztZQUNSaXBDO1lBQ0EsR0FBSTVjLFNBQVM7Z0JBQUUsQ0FBQzJjLGtCQUFrQixvQkFBb0IsY0FBYyxFQUFFM2M7WUFBTSxDQUFDO1FBQ2pGO1FBQUc5cUIsVUFBVUE7SUFBUztBQUM5QjtBQUNBOzs7O0NBSUMsR0FDRCxNQUFNc29DLGtDQUFvQjd2QywyQ0FBSUEsQ0FBQ2d1QztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDRCxTQUFTOEIsWUFBWSxFQUFFeDBCLE1BQU0sRUFBRXkwQixZQUFZLElBQUksRUFBRUMsZUFBZSxFQUFFQyxXQUFXLEVBQUVDLGFBQWEsRUFBRUMsU0FBUyxFQUFFOWQsS0FBSyxFQUFFNGIsV0FBVyxFQUFFLEVBQUVDLFlBQVksRUFBRSxFQUFFQyxXQUFXQyxPQUFPQyxTQUFTLEVBQUVDLFlBQVlGLE9BQU9DLFNBQVMsRUFBRUUsa0JBQWtCLEtBQUssRUFBRUUsWUFBWSxJQUFJLEVBQUVDLFlBQVksRUFBRUMsYUFBYSxFQUFFQyxRQUFRLEVBQUVDLFdBQVcsRUFBRztJQUN0UyxJQUFJLENBQUNrQixXQUFXO1FBQ1osT0FBTztJQUNYO0lBQ0EsT0FBUTN3Qyx1REFBSUEsQ0FBQ0MsdURBQVFBLEVBQUU7UUFBRWtJLFVBQVU7WUFBQ2pELHFFQUF5QkEsQ0FBQ2lGLEdBQUcsQ0FBQyxDQUFDcEQsV0FBYzdHLHNEQUFHQSxDQUFDdXdDLG1CQUFtQjtvQkFBRWxvQyxXQUFXdW9DO29CQUFlbHFDLE9BQU9tcUM7b0JBQVc3MEIsUUFBUUE7b0JBQVFuVixVQUFVQTtvQkFBVXlnQyxTQUFTeGlDLGdFQUFvQkEsQ0FBQzJwQyxJQUFJO29CQUFFMWIsT0FBT0E7b0JBQU80YixVQUFVQTtvQkFBVUMsV0FBV0E7b0JBQVdDLFVBQVVBO29CQUFVRyxXQUFXQTtvQkFBV0ssZUFBZUE7b0JBQWVKLGlCQUFpQkE7b0JBQWlCRSxXQUFXQTtvQkFBV0MsY0FBY0E7b0JBQWNFLFVBQVVBO29CQUFVQyxhQUFhQTtnQkFBWSxHQUFHMW9DO1lBQWE1Qix1RUFBMkJBLENBQUNnRixHQUFHLENBQUMsQ0FBQ3BELFdBQWM3RyxzREFBR0EsQ0FBQ3V3QyxtQkFBbUI7b0JBQUVsb0MsV0FBV3FvQztvQkFBaUJocUMsT0FBT2lxQztvQkFBYTMwQixRQUFRQTtvQkFBUW5WLFVBQVVBO29CQUFVa3NCLE9BQU9BO29CQUFPNGIsVUFBVUE7b0JBQVVDLFdBQVdBO29CQUFXQyxVQUFVQTtvQkFBVUcsV0FBV0E7b0JBQVdLLGVBQWVBO29CQUFlSixpQkFBaUJBO29CQUFpQkUsV0FBV0E7b0JBQVdDLGNBQWNBO29CQUFjRSxVQUFVQTtvQkFBVUMsYUFBYUE7Z0JBQVksR0FBRzFvQztTQUFZO0lBQUM7QUFDaDZCO0FBRUEsTUFBTVgsV0FBVyxDQUFDMGdCLFFBQVVBLE1BQU05VCxPQUFPLEVBQUV3dEIsY0FBYztBQUN6RCxTQUFTd1Esa0JBQWtCLEVBQUU3b0MsUUFBUSxFQUFFO0lBQ25DLE1BQU04b0MsYUFBYTlxQyxTQUFTQztJQUM1QixJQUFJLENBQUM2cUMsWUFBWTtRQUNiLE9BQU87SUFDWDtJQUNBLHFCQUFPbnJDLHVEQUFZQSxDQUFDcUMsVUFBVThvQztBQUNsQztBQUVBLE1BQU1DLGlCQUFpQixDQUFDam5DLEdBQUdDLElBQU1ELEdBQUdQLFVBQVU0UixpQkFBaUJyUSxNQUFNZixHQUFHUixVQUFVNFIsaUJBQWlCclEsS0FDL0ZoQixHQUFHUCxVQUFVNFIsaUJBQWlCcFEsTUFBTWhCLEdBQUdSLFVBQVU0UixpQkFBaUJwUSxLQUNsRWpCLEdBQUc2SyxTQUFTOU4sVUFBVWtELEdBQUc0SyxTQUFTOU4sU0FDbENpRCxHQUFHNkssU0FBUzdOLFdBQVdpRCxHQUFHNEssU0FBUzdOLFVBQ25DZ0QsR0FBR1QsYUFBYVUsR0FBR1YsWUFDbkJTLEdBQUdQLFVBQVU0bkIsTUFBTXBuQixHQUFHUixVQUFVNG5CO0FBQ3BDLE1BQU02ZixrQkFBa0IsQ0FBQ2xuQyxHQUFHQztJQUN4QixJQUFJRCxFQUFFNEcsSUFBSSxLQUFLM0csRUFBRTJHLElBQUksRUFBRTtRQUNuQixPQUFPO0lBQ1g7SUFDQSxLQUFLLE1BQU0sQ0FBQ0osS0FBS25ILEtBQUssSUFBSVcsRUFBRztRQUN6QixJQUFJaW5DLGVBQWU1bkMsTUFBTVksRUFBRW1LLEdBQUcsQ0FBQzVELE9BQU87WUFDbEMsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQSxNQUFNMmdDLGdCQUFnQixDQUFDdHFCLFFBQVc7UUFDOUI3YixHQUFHNmIsTUFBTTlVLFNBQVMsQ0FBQyxFQUFFO1FBQ3JCOUcsR0FBRzRiLE1BQU05VSxTQUFTLENBQUMsRUFBRTtRQUNyQjdHLE1BQU0yYixNQUFNOVUsU0FBUyxDQUFDLEVBQUU7UUFDeEJxL0Isb0JBQW9CdnFCLE1BQU12YyxLQUFLLENBQUN1RSxNQUFNLENBQUMsQ0FBQ3hGLE9BQVNBLEtBQUtFLFFBQVEsRUFBRW9ILE1BQU07SUFDMUU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtDQyxHQUNELFNBQVMwZ0MsWUFBWSxFQUFFcDFCLE1BQU0sRUFBRS9ULFFBQVEsRUFBRUksU0FBUyxFQUFFM0IsS0FBSyxFQUFFK3BDLFNBQVMsRUFBRTVwQyxXQUFXdkUsb0RBQVFBLENBQUNzbEIsR0FBRyxFQUFFcVEsU0FBUyxFQUFFLEVBQUVvWixRQUFRLFFBQVEsRUFBRSxHQUFHL29DLE1BQU07SUFDbkksTUFBTWtuQyxnQkFBZ0JocEI7SUFDdEIsTUFBTXVlLGdCQUFnQnRrQyxrREFBV0EsQ0FBQyxDQUFDbW1CO1FBQy9CLE1BQU1tSCxVQUFVdGYsTUFBTUMsT0FBTyxDQUFDc04sVUFBVUEsU0FBUztZQUFDQSxVQUFVd3pCLGlCQUFpQjtTQUFHO1FBQ2hGLE1BQU04QixnQkFBZ0J2akIsUUFBUS9lLE1BQU0sQ0FBQyxDQUFDQyxLQUFLakg7WUFDdkMsTUFBTW9CLE9BQU93ZCxNQUFNdmQsVUFBVSxDQUFDOEssR0FBRyxDQUFDbk07WUFDbEMsSUFBSW9CLE1BQU07Z0JBQ042RixJQUFJZ0YsR0FBRyxDQUFDN0ssS0FBS3BCLEVBQUUsRUFBRW9CO1lBQ3JCO1lBQ0EsT0FBTzZGO1FBQ1gsR0FBRyxJQUFJNEU7UUFDUCxPQUFPeTlCO0lBQ1gsR0FBRztRQUFDdDFCO1FBQVF3ekI7S0FBYztJQUMxQixNQUFNbmxDLFFBQVFwRSxTQUFTOCtCLGVBQWVrTTtJQUN0QyxNQUFNLEVBQUVsbUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLElBQUksRUFBRWttQyxrQkFBa0IsRUFBRSxHQUFHbHJDLFNBQVNpckMsZUFBZXZyQyxvREFBT0E7SUFDMUUsMEdBQTBHO0lBQzFHLE1BQU0yYSxXQUFXLE9BQU9td0IsY0FBYyxZQUNoQ0EsWUFDQXBtQyxNQUFNc0csSUFBSSxLQUFLLEtBQUt0RyxNQUFNa04sTUFBTSxHQUFHSCxJQUFJLEdBQUdVLEtBQUssRUFBRXhPLFlBQVk2bkMsdUJBQXVCO0lBQzFGLElBQUksQ0FBQzd3QixZQUFZLENBQUNqVyxNQUFNc0csSUFBSSxFQUFFO1FBQzFCLE9BQU87SUFDWDtJQUNBLE1BQU1zSyxXQUFXclksc0VBQXNCQSxDQUFDeUg7SUFDeEMsTUFBTWtuQyxhQUFhOWlDLE1BQU13TixJQUFJLENBQUM1UixNQUFNa04sTUFBTTtJQUMxQyxNQUFNNFosU0FBUy9OLEtBQUs0ZSxHQUFHLElBQUl1UCxXQUFXdG5DLEdBQUcsQ0FBQyxDQUFDYixPQUFTQSxLQUFLSSxTQUFTLENBQUM0bkIsQ0FBQyxHQUFHO0lBQ3ZFLE1BQU1rUyxlQUFlO1FBQ2pCejhCLFVBQVU7UUFDVmlMLFdBQVc1TSx1RUFBdUJBLENBQUMrVixVQUFVO1lBQUVsUTtZQUFHQztZQUFHQztRQUFLLEdBQUdwRSxVQUFVb3hCLFFBQVFvWjtRQUMvRWxnQjtRQUNBLEdBQUd6cUIsS0FBSztJQUNaO0lBQ0EsT0FBUTFHLHNEQUFHQSxDQUFDOHdDLG1CQUFtQjtRQUFFN29DLFVBQVVqSSxzREFBR0EsQ0FBQyxPQUFPO1lBQUUwRyxPQUFPNDhCO1lBQWNqN0IsV0FBVzFILG9EQUFFQSxDQUFDO2dCQUFDO2dCQUE0QjBIO2FBQVU7WUFBRyxHQUFHQyxJQUFJO1lBQUUsV0FBV2lwQyxXQUFXdmlDLE1BQU0sQ0FBQyxDQUFDd2lDLEtBQUtwb0MsT0FBUyxDQUFDLEVBQUVvb0MsSUFBSSxFQUFFcG9DLEtBQUtwQixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSXlwQyxJQUFJO1lBQUl4cEMsVUFBVUE7UUFBUztJQUFHO0FBQ3JQO0FBRUEsTUFBTXlwQyxlQUFlLENBQUM5cUIsUUFBVUEsTUFBTTlVLFNBQVMsQ0FBQyxFQUFFO0FBQ2xEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBUzYvQixZQUFZLEVBQUU3dEIsTUFBTSxFQUFFL1ksQ0FBQyxFQUFFQyxDQUFDLEVBQUUvQyxRQUFRLEVBQUVJLFNBQVMsRUFBRTNCLEtBQUssRUFBRStwQyxTQUFTLEVBQUVtQixTQUFTLFFBQVEsRUFBRUMsU0FBUyxRQUFRLEVBQUUsR0FBR3ZwQyxNQUFNO0lBQ3ZILE1BQU13cEMsZUFBZXJ4QyxrREFBV0EsQ0FBQyxDQUFDbW1CLFFBQVVBLE1BQU1qZCxVQUFVLENBQUN3SyxHQUFHLENBQUMyUCxTQUFTO1FBQUNBO0tBQU87SUFDbEYsTUFBTXBhLE9BQU96RCxTQUFTNnJDLGNBQWNuc0Msb0RBQU9BO0lBQzNDLE1BQU0yYSxXQUFXLE9BQU9td0IsY0FBYyxZQUFZQSxZQUFZL21DLE1BQU1KO0lBQ3BFLE1BQU0yQixPQUFPaEYsU0FBU3lyQztJQUN0QixJQUFJLENBQUNweEIsVUFBVTtRQUNYLE9BQU87SUFDWDtJQUNBLE1BQU02USxTQUFTLENBQUN6bkIsTUFBTXluQixVQUFVLEtBQUs7SUFDckMsTUFBTXJmLFlBQVkzTSx1RUFBdUJBLENBQUM0RixHQUFHQyxHQUFHQyxNQUFNMm1DLFFBQVFDO0lBQzlELE9BQVE3eEMsc0RBQUdBLENBQUNza0MsbUJBQW1CO1FBQUVyOEIsVUFBVWpJLHNEQUFHQSxDQUFDLE9BQU87WUFBRTBHLE9BQU87Z0JBQ25ERyxVQUFVO2dCQUNWaUw7Z0JBQ0FxZjtnQkFDQUUsZUFBZTtnQkFDZjBnQixpQkFBaUI7Z0JBQ2pCLEdBQUdyckMsS0FBSztZQUNaO1lBQUcyQixXQUFXMUgsb0RBQUVBLENBQUM7Z0JBQUM7Z0JBQTRCMEg7YUFBVTtZQUFHLFdBQVdxQixNQUFNMUIsTUFBTTtZQUFJLEdBQUdNLElBQUk7WUFBRUwsVUFBVUE7UUFBUztJQUFHO0FBQ2pJO0FBRTR3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludmVuZS1vcmNoZXN0cmF0b3IvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcz9mYTNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5pbXBvcnQgeyBqc3hzLCBGcmFnbWVudCwganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbywgZm9yd2FyZFJlZiwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUNhbGxiYWNrLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IGVycm9yTWVzc2FnZXMsIG1lcmdlQXJpYUxhYmVsQ29uZmlnLCBpbmZpbml0ZUV4dGVudCwgaXNJbnB1dERPTU5vZGUsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCBwb2ludFRvUmVuZGVyZXJQb2ludCwgcmVuZGVyZXJQb2ludFRvUG9pbnQsIGlzTm9kZUJhc2UsIGlzRWRnZUJhc2UsIGdldEVsZW1lbnRzVG9SZW1vdmUsIGlzUmVjdE9iamVjdCwgbm9kZVRvUmVjdCwgZ2V0T3ZlcmxhcHBpbmdBcmVhLCBnZXROb2Rlc0JvdW5kcywgd2l0aFJlc29sdmVycywgZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uLCBnZXREaW1lbnNpb25zLCBYWVBhblpvb20sIFBhbk9uU2Nyb2xsTW9kZSwgU2VsZWN0aW9uTW9kZSwgZ2V0RXZlbnRQb3NpdGlvbiwgZ2V0Tm9kZXNJbnNpZGUsIGFyZVNldHNFcXVhbCwgWFlEcmFnLCBzbmFwUG9zaXRpb24sIGNhbGN1bGF0ZU5vZGVQb3NpdGlvbiwgUG9zaXRpb24sIENvbm5lY3Rpb25Nb2RlLCBpc01vdXNlRXZlbnQsIFhZSGFuZGxlLCBnZXRIb3N0Rm9yRWxlbWVudCwgYWRkRWRnZSwgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgaXNOdW1lcmljLCBub2RlSGFzRGltZW5zaW9ucywgZ2V0Tm9kZURpbWVuc2lvbnMsIGVsZW1lbnRTZWxlY3Rpb25LZXlzLCBpc0VkZ2VWaXNpYmxlLCBNYXJrZXJUeXBlLCBjcmVhdGVNYXJrZXJJZHMsIGdldEJlemllckVkZ2VDZW50ZXIsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldEJlemllclBhdGgsIGdldEVkZ2VQb3NpdGlvbiwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRNYXJrZXJJZCwgZ2V0Q29ubmVjdGlvblN0YXR1cywgQ29ubmVjdGlvbkxpbmVUeXBlLCB1cGRhdGVDb25uZWN0aW9uTG9va3VwLCBhZG9wdFVzZXJOb2RlcywgaW5pdGlhbENvbm5lY3Rpb24sIGRldldhcm4sIGRlZmF1bHRBcmlhTGFiZWxDb25maWcsIHVwZGF0ZU5vZGVJbnRlcm5hbHMsIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zLCBnZXRIYW5kbGVQb3NpdGlvbiwgaGFuZGxlRXhwYW5kUGFyZW50LCBwYW5CeSwgZml0Vmlld3BvcnQsIGlzTWFjT3MsIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwsIGhhbmRsZUNvbm5lY3Rpb25DaGFuZ2UsIHNoYWxsb3dOb2RlRGF0YSwgWFlNaW5pbWFwLCBnZXRCb3VuZHNPZlJlY3RzLCBSZXNpemVDb250cm9sVmFyaWFudCwgWFlSZXNpemVyLCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMsIGdldE5vZGVUb29sYmFyVHJhbnNmb3JtLCBnZXRFZGdlVG9vbGJhclRyYW5zZm9ybSB9IGZyb20gJ0B4eWZsb3cvc3lzdGVtJztcbmV4cG9ydCB7IENvbm5lY3Rpb25MaW5lVHlwZSwgQ29ubmVjdGlvbk1vZGUsIE1hcmtlclR5cGUsIFBhbk9uU2Nyb2xsTW9kZSwgUG9zaXRpb24sIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBTZWxlY3Rpb25Nb2RlLCBhZGRFZGdlLCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0RWRnZUNlbnRlciwgZ2V0SW5jb21lcnMsIGdldE5vZGVzQm91bmRzLCBnZXRPdXRnb2VycywgZ2V0U21vb3RoU3RlcFBhdGgsIGdldFN0cmFpZ2h0UGF0aCwgZ2V0Vmlld3BvcnRGb3JCb3VuZHMsIHJlY29ubmVjdEVkZ2UgfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5pbXBvcnQgeyB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuLCBjcmVhdGVXaXRoRXF1YWxpdHlGbiB9IGZyb20gJ3p1c3RhbmQvdHJhZGl0aW9uYWwnO1xuaW1wb3J0IHsgc2hhbGxvdyB9IGZyb20gJ3p1c3RhbmQvc2hhbGxvdyc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgUHJvdmlkZXIkMSA9IFN0b3JlQ29udGV4dC5Qcm92aWRlcjtcblxuY29uc3QgenVzdGFuZEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAxJ10oKTtcbi8qKlxuICogVGhpcyBob29rIGNhbiBiZSB1c2VkIHRvIHN1YnNjcmliZSB0byBpbnRlcm5hbCBzdGF0ZSBjaGFuZ2VzIG9mIHRoZSBSZWFjdCBGbG93XG4gKiBjb21wb25lbnQuIFRoZSBgdXNlU3RvcmVgIGhvb2sgaXMgcmUtZXhwb3J0ZWQgZnJvbSB0aGUgW1p1c3RhbmRdKGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvenVzdGFuZClcbiAqIHN0YXRlIG1hbmFnZW1lbnQgbGlicmFyeSwgc28geW91IHNob3VsZCBjaGVjayBvdXQgdGhlaXIgZG9jcyBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBzZWxlY3RvciAtIEEgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2xpY2Ugb2YgdGhlIGZsb3cncyBpbnRlcm5hbCBzdGF0ZS5cbiAqIEV4dHJhY3Rpbmcgb3IgdHJhbnNmb3JtaW5nIGp1c3QgdGhlIHN0YXRlIHlvdSBuZWVkIGlzIGEgZ29vZCBwcmFjdGljZSB0byBhdm9pZCB1bm5lY2Vzc2FyeVxuICogcmUtcmVuZGVycy5cbiAqIEBwYXJhbSBlcXVhbGl0eUZuIC0gQSBmdW5jdGlvbiB0byBjb21wYXJlIHRoZSBwcmV2aW91cyBhbmQgbmV4dCB2YWx1ZS4gVGhpcyBpcyBpbmNyZWRpYmx5IHVzZWZ1bFxuICogZm9yIHByZXZlbnRpbmcgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy4gR29vZCBzZW5zaWJsZSBkZWZhdWx0cyBhcmUgdXNpbmcgYE9iamVjdC5pc2Agb3IgaW1wb3J0aW5nXG4gKiBgenVzdGFuZC9zaGFsbG93YCwgYnV0IHlvdSBjYW4gYmUgYXMgZ3JhbnVsYXIgYXMgeW91IGxpa2UuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgc3RhdGUgc2xpY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBub2RlcyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUubm9kZXMpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmUoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU3RvcmVXaXRoRXF1YWxpdHlGbihzdG9yZSwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuLyoqXG4gKiBJbiBzb21lIGNhc2VzLCB5b3UgbWlnaHQgbmVlZCB0byBhY2Nlc3MgdGhlIHN0b3JlIGRpcmVjdGx5LiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgc3RvcmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIG9uIGRlbWFuZCB0byBhY2Nlc3MgdGhlIHN0YXRlIG9yIGRpc3BhdGNoIGFjdGlvbnMuXG4gKlxuICogQHJldHVybnMgVGhlIHN0b3JlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICogYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgaWYgdGhlcmUgaXMgbm8gb3RoZXIgd2F5IHRvIGFjY2VzcyB0aGUgaW50ZXJuYWxcbiAqIHN0YXRlLiBGb3IgbWFueSBvZiB0aGUgY29tbW9uIHVzZSBjYXNlcywgdGhlcmUgYXJlIGRlZGljYXRlZCBob29rcyBhdmFpbGFibGVcbiAqIHN1Y2ggYXMge0BsaW5rIHVzZVJlYWN0Rmxvd30sIHtAbGluayB1c2VWaWV3cG9ydH0sIGV0Yy5cbiAqL1xuZnVuY3Rpb24gdXNlU3RvcmVBcGkoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VDb250ZXh0KFN0b3JlQ29udGV4dCk7XG4gICAgaWYgKHN0b3JlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih6dXN0YW5kRXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBzZXRTdGF0ZTogc3RvcmUuc2V0U3RhdGUsXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLFxuICAgIH0pLCBbc3RvcmVdKTtcbn1cblxuY29uc3Qgc3R5bGUgPSB7IGRpc3BsYXk6ICdub25lJyB9O1xuY29uc3QgYXJpYUxpdmVTdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMHB4LCAwcHgsIDBweCwgMHB4KScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG59O1xuY29uc3QgQVJJQV9OT0RFX0RFU0NfS0VZID0gJ3JlYWN0LWZsb3dfX25vZGUtZGVzYyc7XG5jb25zdCBBUklBX0VER0VfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fZWRnZS1kZXNjJztcbmNvbnN0IEFSSUFfTElWRV9NRVNTQUdFID0gJ3JlYWN0LWZsb3dfX2FyaWEtbGl2ZSc7XG5jb25zdCBhcmlhTGl2ZVNlbGVjdG9yID0gKHMpID0+IHMuYXJpYUxpdmVNZXNzYWdlO1xuY29uc3QgYXJpYUxhYmVsQ29uZmlnU2VsZWN0b3IgPSAocykgPT4gcy5hcmlhTGFiZWxDb25maWc7XG5mdW5jdGlvbiBBcmlhTGl2ZU1lc3NhZ2UoeyByZklkIH0pIHtcbiAgICBjb25zdCBhcmlhTGl2ZU1lc3NhZ2UgPSB1c2VTdG9yZShhcmlhTGl2ZVNlbGVjdG9yKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0xJVkVfTUVTU0FHRX0tJHtyZklkfWAsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIsIHN0eWxlOiBhcmlhTGl2ZVN0eWxlLCBjaGlsZHJlbjogYXJpYUxpdmVNZXNzYWdlIH0pKTtcbn1cbmZ1bmN0aW9uIEExMXlEZXNjcmlwdGlvbnMoeyByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICBjb25zdCBhcmlhTGFiZWxDb25maWcgPSB1c2VTdG9yZShhcmlhTGFiZWxDb25maWdTZWxlY3Rvcik7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGRpc2FibGVLZXlib2FyZEExMXlcbiAgICAgICAgICAgICAgICAgICAgPyBhcmlhTGFiZWxDb25maWdbJ25vZGUuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnXVxuICAgICAgICAgICAgICAgICAgICA6IGFyaWFMYWJlbENvbmZpZ1snbm9kZS5hMTF5RGVzY3JpcHRpb24ua2V5Ym9hcmREaXNhYmxlZCddIH0pLCBqc3goXCJkaXZcIiwgeyBpZDogYCR7QVJJQV9FREdFX0RFU0NfS0VZfS0ke3JmSWR9YCwgc3R5bGU6IHN0eWxlLCBjaGlsZHJlbjogYXJpYUxhYmVsQ29uZmlnWydlZGdlLmExMXlEZXNjcmlwdGlvbi5kZWZhdWx0J10gfSksICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGpzeChBcmlhTGl2ZU1lc3NhZ2UsIHsgcmZJZDogcmZJZCB9KV0gfSkpO1xufVxuXG4vKipcbiAqIFRoZSBgPFBhbmVsIC8+YCBjb21wb25lbnQgaGVscHMgeW91IHBvc2l0aW9uIGNvbnRlbnQgYWJvdmUgdGhlIHZpZXdwb3J0LlxuICogSXQgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbYDxNaW5pTWFwIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9taW5pbWFwKVxuICogYW5kIFtgPENvbnRyb2xzIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9jb250cm9scykgY29tcG9uZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIEJhY2tncm91bmQsIFBhbmVsIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbXX0gZml0Vmlldz5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLWxlZnRcIj50b3AtbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1jZW50ZXJcIj50b3AtY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwidG9wLXJpZ2h0XCI+dG9wLXJpZ2h0PC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLWxlZnRcIj5ib3R0b20tbGVmdDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1jZW50ZXJcIj5ib3R0b20tY2VudGVyPC9QYW5lbD5cbiAqICAgICAgPFBhbmVsIHBvc2l0aW9uPVwiYm90dG9tLXJpZ2h0XCI+Ym90dG9tLXJpZ2h0PC9QYW5lbD5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IFBhbmVsID0gZm9yd2FyZFJlZigoeyBwb3NpdGlvbiA9ICd0b3AtbGVmdCcsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCAuLi5yZXN0IH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NlcyA9IGAke3Bvc2l0aW9ufWAuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19wYW5lbCcsIGNsYXNzTmFtZSwgLi4ucG9zaXRpb25DbGFzc2VzXSksIHN0eWxlOiBzdHlsZSwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59KTtcblBhbmVsLmRpc3BsYXlOYW1lID0gJ1BhbmVsJztcblxuZnVuY3Rpb24gQXR0cmlidXRpb24oeyBwcm9PcHRpb25zLCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnIH0pIHtcbiAgICBpZiAocHJvT3B0aW9ucz8uaGlkZUF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hdHRyaWJ1dGlvblwiLCBcImRhdGEtbWVzc2FnZVwiOiBcIlBsZWFzZSBvbmx5IGhpZGUgdGhpcyBhdHRyaWJ1dGlvbiB3aGVuIHlvdSBhcmUgc3Vic2NyaWJlZCB0byBSZWFjdCBGbG93IFBybzogaHR0cHM6Ly9wcm8ucmVhY3RmbG93LmRldlwiLCBjaGlsZHJlbjoganN4KFwiYVwiLCB7IGhyZWY6IFwiaHR0cHM6Ly9yZWFjdGZsb3cuZGV2XCIsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiwgXCJhcmlhLWxhYmVsXCI6IFwiUmVhY3QgRmxvdyBhdHRyaWJ1dGlvblwiLCBjaGlsZHJlbjogXCJSZWFjdCBGbG93XCIgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRtID0gKHMpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gW107XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLnB1c2gobm9kZS5pbnRlcm5hbHMudXNlck5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgZWRnZV0gb2Ygcy5lZGdlTG9va3VwKSB7XG4gICAgICAgIGlmIChlZGdlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9O1xufTtcbmNvbnN0IHNlbGVjdElkID0gKG9iaikgPT4gb2JqLmlkO1xuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoc2hhbGxvdyhhLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCkpICYmXG4gICAgICAgIHNoYWxsb3coYS5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpKSk7XG59XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcklubmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRtLCBhcmVFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U/LihwYXJhbXMpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZm9yRWFjaCgoZm4pID0+IGZuKHBhcmFtcykpO1xuICAgIH0sIFtzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzLCBvblNlbGVjdGlvbkNoYW5nZV0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgY2hhbmdlU2VsZWN0b3IgPSAocykgPT4gISFzLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM7XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IHVzZVN0b3JlKGNoYW5nZVNlbGVjdG9yKTtcbiAgICBpZiAob25TZWxlY3Rpb25DaGFuZ2UgfHwgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycykge1xuICAgICAgICByZXR1cm4ganN4KFNlbGVjdGlvbkxpc3RlbmVySW5uZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZGVmYXVsdE5vZGVPcmlnaW4gPSBbMCwgMF07XG5jb25zdCBkZWZhdWx0Vmlld3BvcnQgPSB7IHg6IDAsIHk6IDAsIHpvb206IDEgfTtcblxuLypcbiAqIFRoaXMgY29tcG9uZW50IGhlbHBzIHVzIHRvIHVwZGF0ZSB0aGUgc3RvcmUgd2l0aCB0aGUgdmFsdWVzIGNvbWluZyBmcm9tIHRoZSB1c2VyLlxuICogV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiB2YWx1ZXMgd2UgY2FuIHVwZGF0ZSBkaXJlY3RseSB3aXRoIGB1c2VEaXJlY3RTdG9yZVVwZGF0ZXJgIChsaWtlIGBzbmFwR3JpZGApXG4gKiBhbmQgdmFsdWVzIHRoYXQgaGF2ZSBhIGRlZGljYXRlZCBzZXR0ZXIgZnVuY3Rpb24gaW4gdGhlIHN0b3JlIChsaWtlIGBzZXROb2Rlc2ApLlxuICovXG4vLyBUaGVzZSBmaWVsZHMgZXhpc3QgaW4gdGhlIGdsb2JhbCBzdG9yZSwgYW5kIHdlIG5lZWQgdG8ga2VlcCB0aGVtIHVwIHRvIGRhdGVcbmNvbnN0IHJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2sgPSBbXG4gICAgJ25vZGVzJyxcbiAgICAnZWRnZXMnLFxuICAgICdkZWZhdWx0Tm9kZXMnLFxuICAgICdkZWZhdWx0RWRnZXMnLFxuICAgICdvbkNvbm5lY3QnLFxuICAgICdvbkNvbm5lY3RTdGFydCcsXG4gICAgJ29uQ29ubmVjdEVuZCcsXG4gICAgJ29uQ2xpY2tDb25uZWN0U3RhcnQnLFxuICAgICdvbkNsaWNrQ29ubmVjdEVuZCcsXG4gICAgJ25vZGVzRHJhZ2dhYmxlJyxcbiAgICAnYXV0b1Bhbk9uTm9kZUZvY3VzJyxcbiAgICAnbm9kZXNDb25uZWN0YWJsZScsXG4gICAgJ25vZGVzRm9jdXNhYmxlJyxcbiAgICAnZWRnZXNGb2N1c2FibGUnLFxuICAgICdlZGdlc1JlY29ubmVjdGFibGUnLFxuICAgICdlbGV2YXRlTm9kZXNPblNlbGVjdCcsXG4gICAgJ2VsZXZhdGVFZGdlc09uU2VsZWN0JyxcbiAgICAnbWluWm9vbScsXG4gICAgJ21heFpvb20nLFxuICAgICdub2RlRXh0ZW50JyxcbiAgICAnb25Ob2Rlc0NoYW5nZScsXG4gICAgJ29uRWRnZXNDaGFuZ2UnLFxuICAgICdlbGVtZW50c1NlbGVjdGFibGUnLFxuICAgICdjb25uZWN0aW9uTW9kZScsXG4gICAgJ3NuYXBHcmlkJyxcbiAgICAnc25hcFRvR3JpZCcsXG4gICAgJ3RyYW5zbGF0ZUV4dGVudCcsXG4gICAgJ2Nvbm5lY3RPbkNsaWNrJyxcbiAgICAnZGVmYXVsdEVkZ2VPcHRpb25zJyxcbiAgICAnZml0VmlldycsXG4gICAgJ2ZpdFZpZXdPcHRpb25zJyxcbiAgICAnb25Ob2Rlc0RlbGV0ZScsXG4gICAgJ29uRWRnZXNEZWxldGUnLFxuICAgICdvbkRlbGV0ZScsXG4gICAgJ29uTm9kZURyYWcnLFxuICAgICdvbk5vZGVEcmFnU3RhcnQnLFxuICAgICdvbk5vZGVEcmFnU3RvcCcsXG4gICAgJ29uU2VsZWN0aW9uRHJhZycsXG4gICAgJ29uU2VsZWN0aW9uRHJhZ1N0YXJ0JyxcbiAgICAnb25TZWxlY3Rpb25EcmFnU3RvcCcsXG4gICAgJ29uTW92ZVN0YXJ0JyxcbiAgICAnb25Nb3ZlJyxcbiAgICAnb25Nb3ZlRW5kJyxcbiAgICAnbm9QYW5DbGFzc05hbWUnLFxuICAgICdub2RlT3JpZ2luJyxcbiAgICAnYXV0b1Bhbk9uQ29ubmVjdCcsXG4gICAgJ2F1dG9QYW5Pbk5vZGVEcmFnJyxcbiAgICAnb25FcnJvcicsXG4gICAgJ2Nvbm5lY3Rpb25SYWRpdXMnLFxuICAgICdpc1ZhbGlkQ29ubmVjdGlvbicsXG4gICAgJ3NlbGVjdE5vZGVzT25EcmFnJyxcbiAgICAnbm9kZURyYWdUaHJlc2hvbGQnLFxuICAgICdjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCcsXG4gICAgJ29uQmVmb3JlRGVsZXRlJyxcbiAgICAnZGVidWcnLFxuICAgICdhdXRvUGFuU3BlZWQnLFxuICAgICdhcmlhTGFiZWxDb25maWcnLFxuICAgICd6SW5kZXhNb2RlJyxcbl07XG4vLyByZklkIGRvZXNuJ3QgZXhpc3QgaW4gUmVhY3RGbG93UHJvcHMsIGJ1dCBpdCdzIG9uZSBvZiB0aGUgZmllbGRzIHdlIHdhbnQgdG8gdXBkYXRlXG5jb25zdCBmaWVsZHNUb1RyYWNrID0gWy4uLnJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2ssICdyZklkJ107XG5jb25zdCBzZWxlY3RvciRsID0gKHMpID0+ICh7XG4gICAgc2V0Tm9kZXM6IHMuc2V0Tm9kZXMsXG4gICAgc2V0RWRnZXM6IHMuc2V0RWRnZXMsXG4gICAgc2V0TWluWm9vbTogcy5zZXRNaW5ab29tLFxuICAgIHNldE1heFpvb206IHMuc2V0TWF4Wm9vbSxcbiAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6IHMuc2V0VHJhbnNsYXRlRXh0ZW50LFxuICAgIHNldE5vZGVFeHRlbnQ6IHMuc2V0Tm9kZUV4dGVudCxcbiAgICByZXNldDogcy5yZXNldCxcbiAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlczogcy5zZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyxcbn0pO1xuY29uc3QgaW5pdFByZXZWYWx1ZXMgPSB7XG4gICAgLypcbiAgICAgKiB0aGVzZSBhcmUgdmFsdWVzIHRoYXQgYXJlIGFsc28gcGFzc2VkIGRpcmVjdGx5IHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICAgKiB0aGFuIHRoZSBTdG9yZVVwZGF0ZXIuIFdlIGNhbiByZWR1Y2UgdGhlIG51bWJlciBvZiBzZXRTdG9yZSBjYWxsc1xuICAgICAqIGJ5IHNldHRpbmcgdGhlIHNhbWUgdmFsdWVzIGhlcmUgYXMgcHJldiBmaWVsZHMuXG4gICAgICovXG4gICAgdHJhbnNsYXRlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBub2RlT3JpZ2luOiBkZWZhdWx0Tm9kZU9yaWdpbixcbiAgICBtaW5ab29tOiAwLjUsXG4gICAgbWF4Wm9vbTogMixcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgbm9QYW5DbGFzc05hbWU6ICdub3BhbicsXG4gICAgcmZJZDogJzEnLFxufTtcbmZ1bmN0aW9uIFN0b3JlVXBkYXRlcihwcm9wcykge1xuICAgIGNvbnN0IHsgc2V0Tm9kZXMsIHNldEVkZ2VzLCBzZXRNaW5ab29tLCBzZXRNYXhab29tLCBzZXRUcmFuc2xhdGVFeHRlbnQsIHNldE5vZGVFeHRlbnQsIHJlc2V0LCBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcywgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGwsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlcyhwcm9wcy5kZWZhdWx0Tm9kZXMsIHByb3BzLmRlZmF1bHRFZGdlcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIHJlc2V0IHRoZSBzdG9yZSB3ZSBhbHNvIG5lZWQgdG8gcmVzZXQgdGhlIHByZXZpb3VzIGZpZWxkc1xuICAgICAgICAgICAgcHJldmlvdXNGaWVsZHMuY3VycmVudCA9IGluaXRQcmV2VmFsdWVzO1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgcHJldmlvdXNGaWVsZHMgPSB1c2VSZWYoaW5pdFByZXZWYWx1ZXMpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIGZpZWxkc1RvVHJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBwcm9wc1tmaWVsZE5hbWVdO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGaWVsZFZhbHVlID0gcHJldmlvdXNGaWVsZHMuY3VycmVudFtmaWVsZE5hbWVdO1xuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09IHByZXZpb3VzRmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcHNbZmllbGROYW1lXSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBDdXN0b20gaGFuZGxpbmcgd2l0aCBkZWRpY2F0ZWQgc2V0dGVycyBmb3Igc29tZSBmaWVsZHNcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09ICdub2RlcycpXG4gICAgICAgICAgICAgICAgc2V0Tm9kZXMoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdlZGdlcycpXG4gICAgICAgICAgICAgICAgc2V0RWRnZXMoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtaW5ab29tJylcbiAgICAgICAgICAgICAgICBzZXRNaW5ab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbWF4Wm9vbScpXG4gICAgICAgICAgICAgICAgc2V0TWF4Wm9vbShmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ3RyYW5zbGF0ZUV4dGVudCcpXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNsYXRlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAnbm9kZUV4dGVudCcpXG4gICAgICAgICAgICAgICAgc2V0Tm9kZUV4dGVudChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2FyaWFMYWJlbENvbmZpZycpXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBhcmlhTGFiZWxDb25maWc6IG1lcmdlQXJpYUxhYmVsQ29uZmlnKGZpZWxkVmFsdWUpIH0pO1xuICAgICAgICAgICAgLy8gUmVuYW1lZCBmaWVsZHNcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXcnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXdPcHRpb25zJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGZpdFZpZXdPcHRpb25zOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgLy8gR2VuZXJhbCBjYXNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgfSwgXG4gICAgLy8gT25seSByZS1ydW4gdGhlIGVmZmVjdCBpZiBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB0cmFjayBjaGFuZ2VzXG4gICAgZmllbGRzVG9UcmFjay5tYXAoKGZpZWxkTmFtZSkgPT4gcHJvcHNbZmllbGROYW1lXSkpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNZWRpYVF1ZXJ5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xufVxuLyoqXG4gKiBIb29rIGZvciByZWNlaXZpbmcgdGhlIGN1cnJlbnQgY29sb3IgbW9kZSBjbGFzcyAnZGFyaycgb3IgJ2xpZ2h0Jy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBjb2xvck1vZGUgLSBUaGUgY29sb3IgbW9kZSB0byB1c2UgKCdkYXJrJywgJ2xpZ2h0JyBvciAnc3lzdGVtJylcbiAqL1xuZnVuY3Rpb24gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKSB7XG4gICAgY29uc3QgW2NvbG9yTW9kZUNsYXNzLCBzZXRDb2xvck1vZGVDbGFzc10gPSB1c2VTdGF0ZShjb2xvck1vZGUgPT09ICdzeXN0ZW0nID8gbnVsbCA6IGNvbG9yTW9kZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbG9yTW9kZSAhPT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIHNldENvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFRdWVyeSA9IGdldE1lZGlhUXVlcnkoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlQ29sb3JNb2RlQ2xhc3MgPSAoKSA9PiBzZXRDb2xvck1vZGVDbGFzcyhtZWRpYVF1ZXJ5Py5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XG4gICAgICAgIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKCk7XG4gICAgICAgIG1lZGlhUXVlcnk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhUXVlcnk/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29sb3JNb2RlXSk7XG4gICAgcmV0dXJuIGNvbG9yTW9kZUNsYXNzICE9PSBudWxsID8gY29sb3JNb2RlQ2xhc3MgOiBnZXRNZWRpYVF1ZXJ5KCk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnO1xufVxuXG5jb25zdCBkZWZhdWx0RG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbi8qKlxuICogVGhpcyBob29rIGxldHMgeW91IGxpc3RlbiBmb3Igc3BlY2lmaWMga2V5IGNvZGVzIGFuZCB0ZWxscyB5b3Ugd2hldGhlciB0aGV5IGFyZVxuICogY3VycmVudGx5IHByZXNzZWQgb3Igbm90LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgdXNlS2V5UHJlc3MgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBzcGFjZVByZXNzZWQgPSB1c2VLZXlQcmVzcygnU3BhY2UnKTtcbiAqICBjb25zdCBjbWRBbmRTUHJlc3NlZCA9IHVzZUtleVByZXNzKFsnTWV0YStzJywgJ1N0cmcrcyddKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAge3NwYWNlUHJlc3NlZCAmJiA8cD5TcGFjZSBwcmVzc2VkITwvcD59XG4gKiAgICAge2NtZEFuZFNQcmVzc2VkICYmIDxwPkNtZCArIFMgcHJlc3NlZCE8L3A+fVxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlS2V5UHJlc3MoXG4vKipcbiAqIFRoZSBrZXkgY29kZSAoc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MpIHNwZWNpZmllcyB3aGljaCBrZXkocykgc2hvdWxkIHRyaWdnZXJcbiAqIGFuIGFjdGlvbi5cbiAqXG4gKiBBICoqc3RyaW5nKiogY2FuIHJlcHJlc2VudDpcbiAqIC0gQSAqKnNpbmdsZSBrZXkqKiwgZS5nLiBgJ2EnYFxuICogLSBBICoqa2V5IGNvbWJpbmF0aW9uKiosIHVzaW5nIGAnKydgIHRvIHNlcGFyYXRlIGtleXMsIGUuZy4gYCdhK2QnYFxuICpcbiAqIEFuICAqKmFycmF5IG9mIHN0cmluZ3MqKiByZXByZXNlbnRzICoqbXVsdGlwbGUgcG9zc2libGUga2V5IGlucHV0cyoqLiBGb3IgZXhhbXBsZSwgYFsnYScsICdkK3MnXWBcbiAqIG1lYW5zIHRoZSB1c2VyIGNhbiBwcmVzcyBlaXRoZXIgdGhlIHNpbmdsZSBrZXkgYCdhJ2Agb3IgdGhlIGNvbWJpbmF0aW9uIG9mIGAnZCdgIGFuZCBgJ3MnYC5cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xua2V5Q29kZSA9IG51bGwsIG9wdGlvbnMgPSB7IHRhcmdldDogZGVmYXVsdERvYywgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IHRydWUgfSkge1xuICAgIGNvbnN0IFtrZXlQcmVzc2VkLCBzZXRLZXlQcmVzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIGlmIGEgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgaW4gb3JkZXIgdG8gdHJhY2sgaXRcbiAgICBjb25zdCBtb2RpZmllclByZXNzZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHByZXNzZWQga2V5cyBpbiBvcmRlciB0byBzdXBwb3J0IGNvbWJpbmF0aW9uc1xuICAgIGNvbnN0IHByZXNzZWRLZXlzID0gdXNlUmVmKG5ldyBTZXQoW10pKTtcbiAgICAvKlxuICAgICAqIGtleUNvZGVzID0gYXJyYXkgd2l0aCBzaW5nbGUga2V5cyBbWydhJ11dIG9yIGtleSBjb21iaW5hdGlvbnMgW1snYScsICdzJ11dXG4gICAgICoga2V5c1RvV2F0Y2ggPSBhcnJheSB3aXRoIGFsbCBrZXlzIGZsYXR0ZW5lZCBbJ2EnLCAnZCcsICdTaGlmdExlZnQnXVxuICAgICAqIHVzZWQgdG8gY2hlY2sgaWYgd2Ugc3RvcmUgZXZlbnQuY29kZSBvciBldmVudC5rZXkuIFdoZW4gdGhlIGNvZGUgaXMgaW4gdGhlIGxpc3Qgb2Yga2V5c1RvV2F0Y2hcbiAgICAgKiB3ZSB1c2UgdGhlIGNvZGUgb3RoZXJ3aXNlIHRoZSBrZXkuIEV4cGxhaW5lcjogV2hlbiB5b3UgcHJlc3MgdGhlIGxlZnQgXCJjb21tYW5kXCIga2V5LCB0aGUgY29kZSBpcyBcIk1ldGFMZWZ0XCJcbiAgICAgKiBhbmQgdGhlIGtleSBpcyBcIk1ldGFcIi4gV2Ugd2FudCB1c2VycyB0byBiZSBhYmxlIHRvIHBhc3Mga2V5cyBhbmQgY29kZXMgc28gd2UgYXNzdW1lIHRoYXQgdGhlIGtleSBpcyBtZWFudCB3aGVuXG4gICAgICogd2UgY2FuJ3QgZmluZCBpdCBpbiB0aGUgbGlzdCBvZiBrZXlzVG9XYXRjaC5cbiAgICAgKi9cbiAgICBjb25zdCBba2V5Q29kZXMsIGtleXNUb1dhdGNoXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qga2V5Q29kZUFyciA9IEFycmF5LmlzQXJyYXkoa2V5Q29kZSkgPyBrZXlDb2RlIDogW2tleUNvZGVdO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IGtleUNvZGVBcnJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChrYykgPT4gdHlwZW9mIGtjID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHdlIGZpcnN0IHJlcGxhY2UgYWxsICcrJyB3aXRoICdcXG4nICB3aGljaCB3ZSB3aWxsIHVzZSB0byBzcGxpdCB0aGUga2V5cyBvblxuICAgICAgICAgICAgICAgICAqIHRoZW4gd2UgcmVwbGFjZSAnXFxuXFxuJyB3aXRoICdcXG4rJywgdGhpcyB3YXkgd2UgY2FuIGFsc28gc3VwcG9ydCB0aGUgY29tYmluYXRpb24gJ2tleSsrJ1xuICAgICAgICAgICAgICAgICAqIGluIHRoZSBlbmQgd2Ugc2ltcGx5IHNwbGl0IG9uICdcXG4nIHRvIGdldCB0aGUga2V5IGFycmF5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLm1hcCgoa2MpID0+IGtjLnJlcGxhY2UoJysnLCAnXFxuJykucmVwbGFjZSgnXFxuXFxuJywgJ1xcbisnKS5zcGxpdCgnXFxuJykpO1xuICAgICAgICAgICAgY29uc3Qga2V5c0ZsYXQgPSBrZXlzLnJlZHVjZSgocmVzLCBpdGVtKSA9PiByZXMuY29uY2F0KC4uLml0ZW0pLCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gW2tleXMsIGtleXNGbGF0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgfSwgW2tleUNvZGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zPy50YXJnZXQgPz8gZGVmYXVsdERvYztcbiAgICAgICAgY29uc3QgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIgPSBvcHRpb25zPy5hY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciA/PyB0cnVlO1xuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZG93bkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmVudEFjdGlvbiA9ICghbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgfHwgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ICYmICFhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcikpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5wdXRET01Ob2RlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleU9yQ29kZSA9IHVzZUtleU9yQ29kZShldmVudC5jb2RlLCBrZXlzVG9XYXRjaCk7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5hZGQoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLmN1cnJlbnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZXZlbnQuY29tcG9zZWRQYXRoPy4oKT8uWzBdIHx8IGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Py5ub2RlTmFtZSA9PT0gJ0JVVFRPTicgfHwgdGFyZ2V0Py5ub2RlTmFtZSA9PT0gJ0EnO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50RGVmYXVsdCAhPT0gZmFsc2UgJiYgKG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50IHx8ICFpc0ludGVyYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXBIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5T3JDb2RlID0gdXNlS2V5T3JDb2RlKGV2ZW50LmNvZGUsIGtleXNUb1dhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMuY3VycmVudCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuZGVsZXRlKGV2ZW50W2tleU9yQ29kZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXggZm9yIE1hYzogd2hlbiBjbWQga2V5IGlzIHByZXNzZWQsIGtleXVwIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIGFueSBvdGhlciBrZXksIHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjczODAwMTgvd2hlbi1jbWQta2V5LWlzLWtlcHQtcHJlc3NlZC1rZXl1cC1pcy1ub3QtdHJpZ2dlcmVkLWZvci1hbnktb3RoZXIta2V5XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ01ldGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNzZWRLZXlzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNldEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHNldEtleVByZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRhcmdldD8uYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHRhcmdldD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgcmVzZXRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtrZXlDb2RlLCBzZXRLZXlQcmVzc2VkXSk7XG4gICAgcmV0dXJuIGtleVByZXNzZWQ7XG59XG4vLyB1dGlsc1xuZnVuY3Rpb24gaXNNYXRjaGluZ0tleShrZXlDb2RlcywgcHJlc3NlZEtleXMsIGlzVXApIHtcbiAgICByZXR1cm4gKGtleUNvZGVzXG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIG9ubHkgd2FudCB0byBjb21wYXJlIHNhbWUgc2l6ZXMgb2Yga2V5Q29kZSBkZWZpbml0aW9uc1xuICAgICAgICAgKiBhbmQgcHJlc3NlZCBrZXlzLiBXaGVuIHRoZSB1c2VyIHNwZWNpZmllZCAnTWV0YScgYXMgYSBrZXkgc29tZXdoZXJlXG4gICAgICAgICAqIHRoaXMgd291bGQgYWxzbyBiZSB0cnV0aHkgd2l0aG91dCB0aGlzIGZpbHRlciB3aGVuIHVzZXIgcHJlc3NlcyAnTWV0YScgKyAncidcbiAgICAgICAgICovXG4gICAgICAgIC5maWx0ZXIoKGtleXMpID0+IGlzVXAgfHwga2V5cy5sZW5ndGggPT09IHByZXNzZWRLZXlzLnNpemUpXG4gICAgICAgIC8qXG4gICAgICAgICAqIHNpbmNlIHdlIHdhbnQgdG8gc3VwcG9ydCBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzIG9ubHkgb25lIG9mIHRoZVxuICAgICAgICAgKiBjb21iaW5hdGlvbnMgbmVlZCB0byBiZSBwYXJ0IG9mIHRoZSBwcmVzc2VkIGtleXNcbiAgICAgICAgICovXG4gICAgICAgIC5zb21lKChrZXlzKSA9PiBrZXlzLmV2ZXJ5KChrKSA9PiBwcmVzc2VkS2V5cy5oYXMoaykpKSk7XG59XG5mdW5jdGlvbiB1c2VLZXlPckNvZGUoZXZlbnRDb2RlLCBrZXlzVG9XYXRjaCkge1xuICAgIHJldHVybiBrZXlzVG9XYXRjaC5pbmNsdWRlcyhldmVudENvZGUpID8gJ2NvZGUnIDogJ2tleSc7XG59XG5cbi8qKlxuICogSG9vayBmb3IgZ2V0dGluZyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgdmlld3BvcnQgaGVscGVyIGZ1bmN0aW9uc1xuICovXG5jb25zdCB1c2VWaWV3cG9ydEhlbHBlciA9ICgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgem9vbUluOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tT3V0OiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuWm9vbSA/IHBhblpvb20uc2NhbGVCeSgxIC8gMS4yLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgem9vbVRvOiAoem9vbUxldmVsLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZVRvKHpvb21MZXZlbCwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFpvb206ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtWzJdLFxuICAgICAgICAgICAgc2V0Vmlld3BvcnQ6IGFzeW5jICh2aWV3cG9ydCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtOiBbdFgsIHRZLCB0Wm9vbV0sIHBhblpvb20sIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IHZpZXdwb3J0LnggPz8gdFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHZpZXdwb3J0LnkgPz8gdFksXG4gICAgICAgICAgICAgICAgICAgIHpvb206IHZpZXdwb3J0Lnpvb20gPz8gdFpvb20sXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRWaWV3cG9ydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFt4LCB5LCB6b29tXSA9IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHksIHpvb20gfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDZW50ZXI6IGFzeW5jICh4LCB5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCkuc2V0Q2VudGVyKHgsIHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEJvdW5kczogYXN5bmMgKGJvdW5kcywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh2aWV3cG9ydCwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6IG9wdGlvbnM/LmVhc2UsXG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlOiBvcHRpb25zPy5pbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcmVlblRvRmxvd1Bvc2l0aW9uOiAoY2xpZW50UG9zaXRpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGRvbVgsIHk6IGRvbVkgfSA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ycmVjdGVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGNsaWVudFBvc2l0aW9uLnggLSBkb21YLFxuICAgICAgICAgICAgICAgICAgICB5OiBjbGllbnRQb3NpdGlvbi55IC0gZG9tWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IF9zbmFwR3JpZCA9IG9wdGlvbnMuc25hcEdyaWQgPz8gc25hcEdyaWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgX3NuYXBUb0dyaWQgPSBvcHRpb25zLnNuYXBUb0dyaWQgPz8gc25hcFRvR3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRUb1JlbmRlcmVyUG9pbnQoY29ycmVjdGVkUG9zaXRpb24sIHRyYW5zZm9ybSwgX3NuYXBUb0dyaWQsIF9zbmFwR3JpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmxvd1RvU2NyZWVuUG9zaXRpb246IChmbG93UG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb3dQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyUG9zaXRpb24gPSByZW5kZXJlclBvaW50VG9Qb2ludChmbG93UG9zaXRpb24sIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogcmVuZGVyZXJQb3NpdGlvbi54ICsgZG9tWCxcbiAgICAgICAgICAgICAgICAgICAgeTogcmVuZGVyZXJQb3NpdGlvbi55ICsgZG9tWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59O1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGNoYW5nZXMgdG8gbm9kZXMgb3IgZWRnZXMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IFJlYWN0IEZsb3cgaW50ZXJuYWxseS5cbiAqIFdoZW4geW91IGRyYWcgYSBub2RlIGZvciBleGFtcGxlLCBSZWFjdCBGbG93IHdpbGwgc2VuZCBhIHBvc2l0aW9uIGNoYW5nZSB1cGRhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIHRoZW4gYXBwbGllcyB0aGUgY2hhbmdlcyBhbmQgcmV0dXJucyB0aGUgdXBkYXRlZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIGVsZW1lbnRzKSB7XG4gICAgY29uc3QgdXBkYXRlZEVsZW1lbnRzID0gW107XG4gICAgLypcbiAgICAgKiBCeSBzdG9yaW5nIGEgbWFwIG9mIGNoYW5nZXMgZm9yIGVhY2ggZWxlbWVudCwgd2UgY2FuIGEgcXVpY2sgbG9va3VwIGFzIHdlXG4gICAgICogaXRlcmF0ZSBvdmVyIHRoZSBlbGVtZW50cyBhcnJheSFcbiAgICAgKi9cbiAgICBjb25zdCBjaGFuZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFkZEl0ZW1DaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBhZGRJdGVtQ2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gJ3JlbW92ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEZvciBhICdyZW1vdmUnIGNoYW5nZSB3ZSBjYW4gc2FmZWx5IGlnbm9yZSBhbnkgb3RoZXIgY2hhbmdlcyBxdWV1ZWQgZm9yXG4gICAgICAgICAgICAgKiB0aGUgc2FtZSBlbGVtZW50LCBpdCdzIGdvaW5nIHRvIGJlIHJlbW92ZWQgYW55d2F5IVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGFuZ2VzTWFwLnNldChjaGFuZ2UuaWQsIFtjaGFuZ2VdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRDaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoY2hhbmdlLmlkKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBzb21lIGNoYW5nZXMgcXVldWVkIGFscmVhZHksIHdlIGNhbiBkbyBhIG11dGFibGUgdXBkYXRlIG9mXG4gICAgICAgICAgICAgICAgICogdGhhdCBhcnJheSBhbmQgc2F2ZSBvdXJzZWx2ZXMgc29tZSBjb3B5aW5nLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGVsZW1lbnRDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYW5nZXNNYXAuc2V0KGNoYW5nZS5pZCwgW2NoYW5nZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlc01hcC5nZXQoZWxlbWVudC5pZCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdoZW4gdGhlcmUgYXJlIG5vIGNoYW5nZXMgZm9yIGFuIGVsZW1lbnQgd2UgY2FuIGp1c3QgcHVzaCBpdCB1bm1vZGlmaWVkLFxuICAgICAgICAgKiBubyBuZWVkIHRvIGNvcHkgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWNoYW5nZXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhICdyZW1vdmUnIGNoYW5nZSBxdWV1ZWQsIGl0J2xsIGJlIHRoZSBvbmx5IGNoYW5nZSBpbiB0aGUgYXJyYXlcbiAgICAgICAgaWYgKGNoYW5nZXNbMF0udHlwZSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWzBdLnR5cGUgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2goeyAuLi5jaGFuZ2VzWzBdLml0ZW0gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIG90aGVyIHR5cGVzIG9mIGNoYW5nZXMsIHdlIHdhbnQgdG8gc3RhcnQgd2l0aCBhIHNoYWxsb3cgY29weSBvZiB0aGVcbiAgICAgICAgICogb2JqZWN0IHNvIFJlYWN0IGtub3dzIHRoaXMgZWxlbWVudCBoYXMgY2hhbmdlZC4gU2VxdWVudGlhbCBjaGFuZ2VzIHdpbGxcbiAgICAgICAgICogZWFjaCBfbXV0YXRlXyB0aGlzIG9iamVjdCwgc28gdGhlcmUncyBvbmx5IGV2ZXIgb25lIGNvcHkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB1cGRhdGVkRWxlbWVudCA9IHsgLi4uZWxlbWVudCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBhcHBseUNoYW5nZShjaGFuZ2UsIHVwZGF0ZWRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh1cGRhdGVkRWxlbWVudCk7XG4gICAgfVxuICAgIC8qXG4gICAgICogd2UgbmVlZCB0byB3YWl0IGZvciBhbGwgY2hhbmdlcyB0byBiZSBhcHBsaWVkIGJlZm9yZSBhZGRpbmcgbmV3IGl0ZW1zXG4gICAgICogdG8gYmUgYWJsZSB0byBhZGQgdGhlbSBhdCB0aGUgY29ycmVjdCBpbmRleFxuICAgICAqL1xuICAgIGlmIChhZGRJdGVtQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgYWRkSXRlbUNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlLmluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMuc3BsaWNlKGNoYW5nZS5pbmRleCwgMCwgeyAuLi5jaGFuZ2UuaXRlbSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHsgLi4uY2hhbmdlLml0ZW0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZEVsZW1lbnRzO1xufVxuLy8gQXBwbGllcyBhIHNpbmdsZSBjaGFuZ2UgdG8gYW4gZWxlbWVudC4gVGhpcyBpcyBhICptdXRhYmxlKiB1cGRhdGUuXG5mdW5jdGlvbiBhcHBseUNoYW5nZShjaGFuZ2UsIGVsZW1lbnQpIHtcbiAgICBzd2l0Y2ggKGNoYW5nZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6IHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWQgPSBjaGFuZ2Uuc2VsZWN0ZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwb3NpdGlvbic6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLnBvc2l0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24gPSBjaGFuZ2UucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5kcmFnZ2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRyYWdnaW5nID0gY2hhbmdlLmRyYWdnaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGltZW5zaW9ucyc6IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlLmRpbWVuc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5tZWFzdXJlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2hhbmdlLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zZXRBdHRyaWJ1dGVzID09PSB0cnVlIHx8IGNoYW5nZS5zZXRBdHRyaWJ1dGVzID09PSAnd2lkdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LndpZHRoID0gY2hhbmdlLmRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5zZXRBdHRyaWJ1dGVzID09PSB0cnVlIHx8IGNoYW5nZS5zZXRBdHRyaWJ1dGVzID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5oZWlnaHQgPSBjaGFuZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5yZXNpemluZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemluZyA9IGNoYW5nZS5yZXNpemluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEcm9wIGluIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBub2RlIGNoYW5nZXMgdG8gYW4gYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHkuXG4gKiBAcGFyYW0gbm9kZXMgLSBBcnJheSBvZiBub2RlcyB0byBhcHBseSB0aGUgY2hhbmdlcyB0by5cbiAqIEByZXR1cm5zIEFycmF5IG9mIHVwZGF0ZWQgbm9kZXMuXG4gKiBAZXhhbXBsZVxuICpgYGB0c3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIGFwcGx5Tm9kZUNoYW5nZXMsIHR5cGUgTm9kZSwgdHlwZSBFZGdlLCB0eXBlIE9uTm9kZXNDaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZTxOb2RlW10+KFtdKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzXSA9IHVzZVN0YXRlPEVkZ2VbXT4oW10pO1xuICogIGNvbnN0IG9uTm9kZXNDaGFuZ2U6IE9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAqICAgIChjaGFuZ2VzKSA9PiB7XG4gKiAgICAgIHNldE5vZGVzKChvbGROb2RlcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBvbGROb2RlcykpO1xuICogICAgfSxcbiAqICAgIFtzZXROb2Rlc10sXG4gKiAgKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e25vZGVzfSBlZGdlcz17ZWRnZXN9IG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9IC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqIEByZW1hcmtzIFZhcmlvdXMgZXZlbnRzIG9uIHRoZSA8UmVhY3RGbG93IC8+IGNvbXBvbmVudCBjYW4gcHJvZHVjZSBhbiB7QGxpbmsgTm9kZUNoYW5nZX1cbiAqIHRoYXQgZGVzY3JpYmVzIGhvdyB0byB1cGRhdGUgdGhlIGVkZ2VzIG9mIHlvdXIgZmxvdyBpbiBzb21lIHdheS5cbiAqIElmIHlvdSBkb24ndCBuZWVkIGFueSBjdXN0b20gYmVoYXZpb3VyLCB0aGlzIHV0aWwgY2FuIGJlIHVzZWQgdG8gdGFrZSBhbiBhcnJheVxuICogb2YgdGhlc2UgY2hhbmdlcyBhbmQgYXBwbHkgdGhlbSB0byB5b3VyIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKSB7XG4gICAgcmV0dXJuIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBub2Rlcyk7XG59XG4vKipcbiAqIERyb3AgaW4gZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGVkZ2UgY2hhbmdlcyB0byBhbiBhcnJheSBvZiBlZGdlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjaGFuZ2VzIC0gQXJyYXkgb2YgY2hhbmdlcyB0byBhcHBseS5cbiAqIEBwYXJhbSBlZGdlcyAtIEFycmF5IG9mIGVkZ2UgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIGVkZ2VzLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgYXBwbHlFZGdlQ2hhbmdlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAqICBjb25zdCBvbkVkZ2VzQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gKiAgICAoY2hhbmdlcykgPT4ge1xuICogICAgICBzZXRFZGdlcygob2xkRWRnZXMpID0+IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgb2xkRWRnZXMpKTtcbiAqICAgIH0sXG4gKiAgICBbc2V0RWRnZXNdLFxuICogICk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtub2Rlc30gZWRnZXM9e2VkZ2VzfSBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfSAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBWYXJpb3VzIGV2ZW50cyBvbiB0aGUgPFJlYWN0RmxvdyAvPiBjb21wb25lbnQgY2FuIHByb2R1Y2UgYW4ge0BsaW5rIEVkZ2VDaGFuZ2V9XG4gKiB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXBkYXRlIHRoZSBlZGdlcyBvZiB5b3VyIGZsb3cgaW4gc29tZSB3YXkuXG4gKiBJZiB5b3UgZG9uJ3QgbmVlZCBhbnkgY3VzdG9tIGJlaGF2aW91ciwgdGhpcyB1dGlsIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gYXJyYXlcbiAqIG9mIHRoZXNlIGNoYW5nZXMgYW5kIGFwcGx5IHRoZW0gdG8geW91ciBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZGdlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGlkLCBzZWxlY3RlZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkNoYW5nZXMoaXRlbXMsIHNlbGVjdGVkSWRzID0gbmV3IFNldCgpLCBtdXRhdGVJdGVtID0gZmFsc2UpIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIGl0ZW1dIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHdpbGxCZVNlbGVjdGVkID0gc2VsZWN0ZWRJZHMuaGFzKGlkKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBzZXQgYWxsIGl0ZW1zIHRvIHNlbGVjdGVkPWZhbHNlIG9uIHRoZSBmaXJzdCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKCEoaXRlbS5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkICYmICF3aWxsQmVTZWxlY3RlZCkgJiYgaXRlbS5zZWxlY3RlZCAhPT0gd2lsbEJlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0aGlzIGhhY2sgaXMgbmVlZGVkIGZvciBub2Rlcy4gV2hlbiB0aGUgdXNlciBkcmFnZ2VkIGEgbm9kZSwgaXQncyBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICAgKiBXaGVuIGFub3RoZXIgbm9kZSBnZXRzIGRyYWdnZWQsIHdlIG5lZWQgdG8gZGVzZWxlY3QgdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgICAgICAgICAgKiBpbiBvcmRlciB0byBoYXZlIG9ubHkgb25lIHNlbGVjdGVkIG5vZGUgYXQgYSB0aW1lIC0gdGhlIG9uTm9kZXNDaGFuZ2UgY2FsbGJhY2sgY29tZXMgdG9vIGxhdGUgaGVyZSA6L1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB3aWxsQmVTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgd2lsbEJlU2VsZWN0ZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoeyBpdGVtcyA9IFtdLCBsb29rdXAsIH0pIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3QgaXRlbXNMb29rdXAgPSBuZXcgTWFwKGl0ZW1zLm1hcCgoaXRlbSkgPT4gW2l0ZW0uaWQsIGl0ZW1dKSk7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGl0ZW1dIG9mIGl0ZW1zLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBsb29rdXBJdGVtID0gbG9va3VwLmdldChpdGVtLmlkKTtcbiAgICAgICAgY29uc3Qgc3RvcmVJdGVtID0gbG9va3VwSXRlbT8uaW50ZXJuYWxzPy51c2VyTm9kZSA/PyBsb29rdXBJdGVtO1xuICAgICAgICBpZiAoc3RvcmVJdGVtICE9PSB1bmRlZmluZWQgJiYgc3RvcmVJdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpZDogaXRlbS5pZCwgaXRlbTogaXRlbSwgdHlwZTogJ3JlcGxhY2UnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yZUl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaXRlbTogaXRlbSwgdHlwZTogJ2FkZCcsIGluZGV4IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkXSBvZiBsb29rdXApIHtcbiAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBpdGVtc0xvb2t1cC5nZXQoaWQpO1xuICAgICAgICBpZiAobmV4dE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQsIHR5cGU6ICdyZW1vdmUnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKGl0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzYWJsZSBhcyBhbiBbYE5vZGVgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9ub2RlKS5cbiAqIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0b1xuICogW2BOb2RlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvbm9kZSkgaWYgaXQgcmV0dXJucyBgdHJ1ZWAuXG4gKlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIE5vZGUgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJucyBUZXN0cyB3aGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBjYW4gYmUgdXNlZCBhcyBhIGBOb2RlYC4gSWYgeW91J3JlIHVzaW5nIFR5cGVTY3JpcHQsXG4gKiB0aGlzIGZ1bmN0aW9uIGFjdHMgYXMgYSB0eXBlIGd1YXJkIGFuZCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYE5vZGVgIGlmIGl0IHJldHVybnNcbiAqIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICppZiAoaXNOb2RlKG5vZGUpKSB7XG4gKiAvLyAuLi5cbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgaXNOb2RlID0gKGVsZW1lbnQpID0+IGlzTm9kZUJhc2UoZWxlbWVudCk7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGFuIFtgRWRnZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UpLlxuICogSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvXG4gKiBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKSBpZiBpdCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gRWRnZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdFxuICogQHJldHVybnMgVGVzdHMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgY2FuIGJlIHVzZWQgYXMgYW4gYEVkZ2VgLiBJZiB5b3UncmUgdXNpbmcgVHlwZVNjcmlwdCxcbiAqIHRoaXMgZnVuY3Rpb24gYWN0cyBhcyBhIHR5cGUgZ3VhcmQgYW5kIHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBgRWRnZWAgaWYgaXQgcmV0dXJuc1xuICogYHRydWVgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICppbXBvcnQgeyBpc0VkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmlmIChpc0VkZ2UoZWRnZSkpIHtcbiAqIC8vIC4uLlxuICp9XG4gKmBgYFxuICovXG5jb25zdCBpc0VkZ2UgPSAoZWxlbWVudCkgPT4gaXNFZGdlQmFzZShlbGVtZW50KTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktb2JqZWN0LXR5cGVcbmZ1bmN0aW9uIGZpeGVkRm9yd2FyZFJlZihyZW5kZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBmb3J3YXJkUmVmKHJlbmRlcik7XG59XG5cbi8vIHdlIG5lZWQgdGhpcyBob29rIHRvIHByZXZlbnQgYSB3YXJuaW5nIHdoZW4gdXNpbmcgcmVhY3QtZmxvdyBpbiBTU1JcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhIHF1ZXVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYmF0Y2ggdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0gcnVuUXVldWUgLSBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgcXVldWUgaXMgZmx1c2hlZFxuICogQGludGVybmFsXG4gKlxuICogQHJldHVybnMgYSBRdWV1ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gdXNlUXVldWUocnVuUXVldWUpIHtcbiAgICAvKlxuICAgICAqIEJlY2F1c2Ugd2UncmUgdXNpbmcgYSByZWYgYWJvdmUsIHdlIG5lZWQgc29tZSB3YXkgdG8gbGV0IFJlYWN0IGtub3cgd2hlbiB0b1xuICAgICAqIGFjdHVhbGx5IHByb2Nlc3MgdGhlIHF1ZXVlLiBXZSBpbmNyZW1lbnQgdGhpcyBudW1iZXIgYW55IHRpbWUgd2UgbXV0YXRlIHRoZVxuICAgICAqIHF1ZXVlLCBjcmVhdGluZyBhIG5ldyBzdGF0ZSB0byB0cmlnZ2VyIHRoZSBsYXlvdXQgZWZmZWN0IGJlbG93LlxuICAgICAqIFVzaW5nIGEgYm9vbGVhbiBkaXJ0eSBmbGFnIGhlcmUgaW5zdGVhZCB3b3VsZCBsZWFkIHRvIGlzc3VlcyByZWxhdGVkIHRvXG4gICAgICogYXV0b21hdGljIGJhdGNoaW5nLiAoaHR0cHM6Ly9naXRodWIuY29tL3h5Zmxvdy94eWZsb3cvaXNzdWVzLzQ3NzkpXG4gICAgICovXG4gICAgY29uc3QgW3NlcmlhbCwgc2V0U2VyaWFsXSA9IHVzZVN0YXRlKEJpZ0ludCgwKSk7XG4gICAgLypcbiAgICAgKiBBIHJlZmVyZW5jZSBvZiBhbGwgdGhlIGJhdGNoZWQgdXBkYXRlcyB0byBwcm9jZXNzIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIuIFdlXG4gICAgICogd2FudCBhIHJlZmVyZW5jZSBoZXJlIHNvIG11bHRpcGxlIHN5bmNocm9ub3VzIGNhbGxzIHRvIGBzZXROb2Rlc2AgZXRjIGNhbiBiZVxuICAgICAqIGJhdGNoZWQgdG9nZXRoZXIuXG4gICAgICovXG4gICAgY29uc3QgW3F1ZXVlXSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZVF1ZXVlKCgpID0+IHNldFNlcmlhbChuID0+IG4gKyBCaWdJbnQoMSkpKSk7XG4gICAgLypcbiAgICAgKiBMYXlvdXQgZWZmZWN0cyBhcmUgZ3VhcmFudGVlZCB0byBydW4gYmVmb3JlIHRoZSBuZXh0IHJlbmRlciB3aGljaCBtZWFucyB3ZVxuICAgICAqIHNob3VsZG4ndCBydW4gaW50byBhbnkgaXNzdWVzIHdpdGggc3RhbGUgc3RhdGUgb3Igd2VpcmQgaXNzdWVzIHRoYXQgY29tZSBmcm9tXG4gICAgICogcmVuZGVyaW5nIHRoaW5ncyBvbmUgZnJhbWUgbGF0ZXIgdGhhbiBleHBlY3RlZCAod2UgdXNlZCB0byB1c2UgYHNldFRpbWVvdXRgKS5cbiAgICAgKi9cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcXVldWVJdGVtcyA9IHF1ZXVlLmdldCgpO1xuICAgICAgICBpZiAocXVldWVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJ1blF1ZXVlKHF1ZXVlSXRlbXMpO1xuICAgICAgICAgICAgcXVldWUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH0sIFtzZXJpYWxdKTtcbiAgICByZXR1cm4gcXVldWU7XG59XG5mdW5jdGlvbiBjcmVhdGVRdWV1ZShjYikge1xuICAgIGxldCBxdWV1ZSA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldDogKCkgPT4gcXVldWUsXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBwdXNoOiAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuY29uc3QgQmF0Y2hDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogVGhpcyBpcyBhIGNvbnRleHQgcHJvdmlkZXIgdGhhdCBob2xkcyBhbmQgcHJvY2Vzc2VzIHRoZSBub2RlIGFuZCBlZGdlIHVwZGF0ZSBxdWV1ZXNcbiAqIHRoYXQgYXJlIG5lZWRlZCB0byBoYW5kbGUgc2V0Tm9kZXMsIGFkZE5vZGVzLCBzZXRFZGdlcyBhbmQgYWRkRWRnZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIEJhdGNoUHJvdmlkZXIoeyBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBub2RlUXVldWVIYW5kbGVyID0gdXNlQ2FsbGJhY2soKHF1ZXVlSXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2RlcyA9IFtdLCBzZXROb2RlcywgaGFzRGVmYXVsdE5vZGVzLCBvbk5vZGVzQ2hhbmdlLCBub2RlTG9va3VwLCBmaXRWaWV3UXVldWVkLCBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcCwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYW4gYEFycmF5LnJlZHVjZWAgaW4gaW1wZXJhdGl2ZSBjbG90aGluZy4gUHJvY2Vzc2luZ1xuICAgICAgICAgKiB0aGlzIHF1ZXVlIGlzIGEgcmVsYXRpdmVseSBob3QgcGF0aCBzbyB3ZSdkIGxpa2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mXG4gICAgICAgICAqIGFycmF5IG1ldGhvZHMgd2hlcmUgd2UgY2FuLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG5leHQgPSBub2RlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VzID0gZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICBpdGVtczogbmV4dCxcbiAgICAgICAgICAgIGxvb2t1cDogbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY2hhbmdlcyA9IG1pZGRsZXdhcmUoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0Tm9kZXMobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIGZpcmUgb25Ob2Rlc0NoYW5nZSBpZiB0aGVyZSBhcmUgY2hhbmdlcyB0byB0aGUgbm9kZXNcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZT8uKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjaGFuZ2VzIHRvIHRoZSBub2Rlcywgd2Ugc3RpbGwgbmVlZCB0byBjYWxsIHNldE5vZGVzXG4gICAgICAgICAgICAvLyB0byB0cmlnZ2VyIGEgcmUtcmVuZGVyIGFuZCBmaXRWaWV3LlxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmaXRWaWV3UXVldWVkLCBub2Rlcywgc2V0Tm9kZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Tm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IG5vZGVRdWV1ZSA9IHVzZVF1ZXVlKG5vZGVRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZUhhbmRsZXIgPSB1c2VDYWxsYmFjaygocXVldWVJdGVtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGVkZ2VzID0gW10sIHNldEVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIG9uRWRnZXNDaGFuZ2UsIGVkZ2VMb29rdXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGxldCBuZXh0ID0gZWRnZXM7XG4gICAgICAgIGZvciAoY29uc3QgcGF5bG9hZCBvZiBxdWV1ZUl0ZW1zKSB7XG4gICAgICAgICAgICBuZXh0ID0gdHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicgPyBwYXlsb2FkKG5leHQpIDogcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBzZXRFZGdlcyhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbkVkZ2VzQ2hhbmdlKSB7XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlKGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoe1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBuZXh0LFxuICAgICAgICAgICAgICAgIGxvb2t1cDogZWRnZUxvb2t1cCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCBlZGdlUXVldWUgPSB1c2VRdWV1ZShlZGdlUXVldWVIYW5kbGVyKTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHsgbm9kZVF1ZXVlLCBlZGdlUXVldWUgfSksIFtdKTtcbiAgICByZXR1cm4ganN4KEJhdGNoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZUJhdGNoQ29udGV4dCgpIHtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VDb250ZXh0KEJhdGNoQ29udGV4dCk7XG4gICAgaWYgKCFiYXRjaENvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VCYXRjaENvbnRleHQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJhdGNoUHJvdmlkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhdGNoQ29udGV4dDtcbn1cblxuY29uc3Qgc2VsZWN0b3IkayA9IChzKSA9PiAhIXMucGFuWm9vbTtcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBSZWFjdEZsb3dJbnN0YW5jZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSBub2RlcyBhbmQgZWRnZXMsIG1hbmlwdWxhdGUgdGhlIHZpZXdwb3J0LCBvciBxdWVyeSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlUmVhY3RGbG93IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gTm9kZUNvdW50ZXIoKSB7XG4gKiAgY29uc3QgcmVhY3RGbG93ID0gdXNlUmVhY3RGbG93KCk7XG4gKiAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAqICBjb25zdCBjb3VudE5vZGVzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICogICAgc2V0Q291bnQocmVhY3RGbG93LmdldE5vZGVzKCkubGVuZ3RoKTtcbiAqICAgIC8vIHlvdSBuZWVkIHRvIHBhc3MgaXQgYXMgYSBkZXBlbmRlbmN5IGlmIHlvdSBhcmUgdXNpbmcgaXQgd2l0aCB1c2VFZmZlY3Qgb3IgdXNlQ2FsbGJhY2tcbiAqICAgIC8vIGJlY2F1c2UgYXQgdGhlIGZpcnN0IHJlbmRlciwgaXQncyBub3QgaW5pdGlhbGl6ZWQgeWV0IGFuZCBzb21lIGZ1bmN0aW9ucyBtaWdodCBub3Qgd29yay5cbiAqICB9LCBbcmVhY3RGbG93XSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8YnV0dG9uIG9uQ2xpY2s9e2NvdW50Tm9kZXN9PlVwZGF0ZSBjb3VudDwvYnV0dG9uPlxuICogICAgICA8cD5UaGVyZSBhcmUge2NvdW50fSBub2RlcyBpbiB0aGUgZmxvdy48L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VSZWFjdEZsb3coKSB7XG4gICAgY29uc3Qgdmlld3BvcnRIZWxwZXIgPSB1c2VWaWV3cG9ydEhlbHBlcigpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBiYXRjaENvbnRleHQgPSB1c2VCYXRjaENvbnRleHQoKTtcbiAgICBjb25zdCB2aWV3cG9ydEluaXRpYWxpemVkID0gdXNlU3RvcmUoc2VsZWN0b3Ikayk7XG4gICAgY29uc3QgZ2VuZXJhbEhlbHBlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBnZXRJbnRlcm5hbE5vZGUgPSAoaWQpID0+IHN0b3JlLmdldFN0YXRlKCkubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBzZXROb2RlcyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2gocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldEVkZ2VzID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGJhdGNoQ29udGV4dC5lZGdlUXVldWUucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2V0Tm9kZVJlY3QgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVRvVXNlID0gaXNOb2RlKG5vZGUpID8gbm9kZSA6IG5vZGVMb29rdXAuZ2V0KG5vZGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBub2RlVG9Vc2UucGFyZW50SWRcbiAgICAgICAgICAgICAgICA/IGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihub2RlVG9Vc2UucG9zaXRpb24sIG5vZGVUb1VzZS5tZWFzdXJlZCwgbm9kZVRvVXNlLnBhcmVudElkLCBub2RlTG9va3VwLCBub2RlT3JpZ2luKVxuICAgICAgICAgICAgICAgIDogbm9kZVRvVXNlLnBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVdpdGhQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlVG9Vc2UsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGVUb1VzZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZVRvVXNlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZVRvVXNlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZVRvVXNlLmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZVRvUmVjdChub2RlV2l0aFBvc2l0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlTm9kZSA9IChpZCwgbm9kZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0Tm9kZXMoKHByZXZOb2RlcykgPT4gcHJldk5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHR5cGVvZiBub2RlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gbm9kZVVwZGF0ZShub2RlKSA6IG5vZGVVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNOb2RlKG5leHROb2RlKSA/IG5leHROb2RlIDogeyAuLi5ub2RlLCAuLi5uZXh0Tm9kZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlRWRnZSA9IChpZCwgZWRnZVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgc2V0RWRnZXMoKHByZXZFZGdlcykgPT4gcHJldkVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RWRnZSA9IHR5cGVvZiBlZGdlVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZWRnZVVwZGF0ZShlZGdlKSA6IGVkZ2VVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgJiYgaXNFZGdlKG5leHRFZGdlKSA/IG5leHRFZGdlIDogeyAuLi5lZGdlLCAuLi5uZXh0RWRnZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5vZGVzOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICBnZXROb2RlOiAoaWQpID0+IGdldEludGVybmFsTm9kZShpZCk/LmludGVybmFscy51c2VyTm9kZSxcbiAgICAgICAgICAgIGdldEludGVybmFsTm9kZSxcbiAgICAgICAgICAgIGdldEVkZ2VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlZGdlcyA9IFtdIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVkZ2U6IChpZCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5lZGdlTG9va3VwLmdldChpZCksXG4gICAgICAgICAgICBzZXROb2RlcyxcbiAgICAgICAgICAgIHNldEVkZ2VzLFxuICAgICAgICAgICAgYWRkTm9kZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXMsIC4uLm5ld05vZGVzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkRWRnZXM6IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RWRnZXMgPSBBcnJheS5pc0FycmF5KHBheWxvYWQpID8gcGF5bG9hZCA6IFtwYXlsb2FkXTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQuZWRnZVF1ZXVlLnB1c2goKGVkZ2VzKSA9PiBbLi4uZWRnZXMsIC4uLm5ld0VkZ2VzXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9PYmplY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzID0gW10sIGVkZ2VzID0gW10sIHRyYW5zZm9ybSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbeCwgeSwgem9vbV0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IG5vZGVzLm1hcCgobikgPT4gKHsgLi4ubiB9KSksXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoKGUpID0+ICh7IC4uLmUgfSkpLFxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICB6b29tLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHM6IGFzeW5jICh7IG5vZGVzOiBub2Rlc1RvUmVtb3ZlID0gW10sIGVkZ2VzOiBlZGdlc1RvUmVtb3ZlID0gW10gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZXMsIGVkZ2VzLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgb25EZWxldGUsIG9uQmVmb3JlRGVsZXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzOiBtYXRjaGluZ05vZGVzLCBlZGdlczogbWF0Y2hpbmdFZGdlcyB9ID0gYXdhaXQgZ2V0RWxlbWVudHNUb1JlbW92ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzVG9SZW1vdmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgb25CZWZvcmVEZWxldGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTWF0Y2hpbmdFZGdlcyA9IG1hdGNoaW5nRWRnZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNNYXRjaGluZ05vZGVzID0gbWF0Y2hpbmdOb2Rlcy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ0VkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gbWF0Y2hpbmdFZGdlcy5tYXAoZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgb25FZGdlc0RlbGV0ZT8uKG1hdGNoaW5nRWRnZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG1hdGNoaW5nTm9kZXMubWFwKGVsZW1lbnRUb1JlbW92ZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZXNEZWxldGU/LihtYXRjaGluZ05vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKG5vZGVDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nTm9kZXMgfHwgaGFzTWF0Y2hpbmdFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT8uKHsgbm9kZXM6IG1hdGNoaW5nTm9kZXMsIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWxldGVkTm9kZXM6IG1hdGNoaW5nTm9kZXMsIGRlbGV0ZWRFZGdlczogbWF0Y2hpbmdFZGdlcyB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFydGlhbCBpcyBkZWZpbmVkIGFzIFwidGhlIDIgbm9kZXMvYXJlYXMgYXJlIGludGVyc2VjdGluZyBwYXJ0aWFsbHlcIi5cbiAgICAgICAgICAgICAqIElmIGEgaXMgY29udGFpbmVkIGluIGIgb3IgYiBpcyBjb250YWluZWQgaW4gYSwgdGhleSBhcmUgYm90aFxuICAgICAgICAgICAgICogY29uc2lkZXJlZCBmdWxseSBpbnRlcnNlY3RpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldEludGVyc2VjdGluZ05vZGVzOiAobm9kZU9yUmVjdCwgcGFydGlhbGx5ID0gdHJ1ZSwgbm9kZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTm9kZXNPcHRpb24gPSBub2RlcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZVJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGVzIHx8IHN0b3JlLmdldFN0YXRlKCkubm9kZXMpLmZpbHRlcigobikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlICYmICFpc1JlY3QgJiYgKG4uaWQgPT09IG5vZGVPclJlY3QuaWQgfHwgIWludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyTm9kZVJlY3QgPSBub2RlVG9SZWN0KGhhc05vZGVzT3B0aW9uID8gbiA6IGludGVybmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShjdXJyTm9kZVJlY3QsIG5vZGVSZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnRpYWxseVZpc2libGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBjdXJyTm9kZVJlY3Qud2lkdGggKiBjdXJyTm9kZVJlY3QuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FyZWEgPj0gbm9kZVJlY3Qud2lkdGggKiBub2RlUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTm9kZUludGVyc2VjdGluZzogKG5vZGVPclJlY3QsIGFyZWEsIHBhcnRpYWxseSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShub2RlUmVjdCwgYXJlYSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAocGFydGlhbGx5VmlzaWJsZSB8fFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYS53aWR0aCAqIGFyZWEuaGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlTm9kZSxcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2RlKGlkLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShub2RlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLm5vZGUsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLm5vZGUsIGRhdGE6IHsgLi4ubm9kZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlRWRnZSxcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VEYXRhOiAoaWQsIGRhdGFVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGdlKGlkLCAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF0YSA9IHR5cGVvZiBkYXRhVXBkYXRlID09PSAnZnVuY3Rpb24nID8gZGF0YVVwZGF0ZShlZGdlKSA6IGRhdGFVcGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlcGxhY2UgPyB7IC4uLmVkZ2UsIGRhdGE6IG5leHREYXRhIH0gOiB7IC4uLmVkZ2UsIGRhdGE6IHsgLi4uZWRnZS5kYXRhLCAuLi5uZXh0RGF0YSB9IH07XG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Tm9kZXNCb3VuZHM6IChub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Tm9kZXNCb3VuZHMobm9kZXMsIHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRIYW5kbGVDb25uZWN0aW9uczogKHsgdHlwZSwgaWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgICAgIGdldE5vZGVDb25uZWN0aW9uczogKHsgdHlwZSwgaGFuZGxlSWQsIG5vZGVJZCB9KSA9PiBBcnJheS5mcm9tKHN0b3JlXG4gICAgICAgICAgICAgICAgLmdldFN0YXRlKClcbiAgICAgICAgICAgICAgICAuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7bm9kZUlkfSR7dHlwZSA/IChoYW5kbGVJZCA/IGAtJHt0eXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7dHlwZX1gKSA6ICcnfWApXG4gICAgICAgICAgICAgICAgPy52YWx1ZXMoKSA/PyBbXSksXG4gICAgICAgICAgICBmaXRWaWV3OiBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIGVpdGhlciBjcmVhdGUgYSBuZXcgUHJvbWlzZSBvciByZXVzZSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgICAgICAgICAgLy8gRXZlbiBpZiBmaXRWaWV3IGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvdywgd2Ugb25seSBlbmQgdXAgd2l0aCBhIHNpbmdsZSBQcm9taXNlXG4gICAgICAgICAgICAgICAgY29uc3QgZml0Vmlld1Jlc29sdmVyID0gc3RvcmUuZ2V0U3RhdGUoKS5maXRWaWV3UmVzb2x2ZXIgPz8gd2l0aFJlc29sdmVycygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHNjaGVkdWxlIGEgZml0VmlldyBieSBzZXR0aW5nIGZpdFZpZXdRdWV1ZWQgYW5kIHRyaWdnZXJpbmcgYSBzZXROb2Rlc1xuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld1F1ZXVlZDogdHJ1ZSwgZml0Vmlld09wdGlvbnM6IG9wdGlvbnMsIGZpdFZpZXdSZXNvbHZlciB9KTtcbiAgICAgICAgICAgICAgICBiYXRjaENvbnRleHQubm9kZVF1ZXVlLnB1c2goKG5vZGVzKSA9PiBbLi4ubm9kZXNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0Vmlld1Jlc29sdmVyLnByb21pc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5nZW5lcmFsSGVscGVyLFxuICAgICAgICAgICAgLi4udmlld3BvcnRIZWxwZXIsXG4gICAgICAgICAgICB2aWV3cG9ydEluaXRpYWxpemVkLFxuICAgICAgICB9O1xuICAgIH0sIFt2aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdGVkID0gKGl0ZW0pID0+IGl0ZW0uc2VsZWN0ZWQ7XG5jb25zdCB3aW4kMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyBnbG9iYWwga2V5IGV2ZW50cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGRlbGV0ZUVsZW1lbnRzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBkZWxldGVLZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MoZGVsZXRlS2V5Q29kZSwgeyBhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcjogZmFsc2UgfSk7XG4gICAgY29uc3QgbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MobXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luJDEgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRlbGV0ZUtleVByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHMoeyBub2Rlczogbm9kZXMuZmlsdGVyKHNlbGVjdGVkKSwgZWRnZXM6IGVkZ2VzLmZpbHRlcihzZWxlY3RlZCkgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWxldGVLZXlQcmVzc2VkXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkIH0pO1xuICAgIH0sIFttdWx0aVNlbGVjdGlvbktleVByZXNzZWRdKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyByZXNpemUgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VSZXNpemVIYW5kbGVyKGRvbU5vZGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZG9tTm9kZS5jdXJyZW50IHx8ICEoZG9tTm9kZS5jdXJyZW50LmNoZWNrVmlzaWJpbGl0eT8uKCkgPz8gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZ2V0RGltZW5zaW9ucyhkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKHNpemUuaGVpZ2h0ID09PSAwIHx8IHNpemUud2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA0JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDQnXSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgd2lkdGg6IHNpemUud2lkdGggfHwgNTAwLCBoZWlnaHQ6IHNpemUuaGVpZ2h0IHx8IDUwMCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvbU5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdXBkYXRlRGltZW5zaW9ucygpKTtcbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNpemVPYnNlcnZlciAmJiBkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbn1cblxuY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbn07XG5cbmNvbnN0IHNlbGVjdG9yJGogPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgbGliOiBzLmxpYixcbiAgICBjb25uZWN0aW9uSW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG59KTtcbmZ1bmN0aW9uIFpvb21QYW5lKHsgb25QYW5lQ29udGV4dE1lbnUsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIGNoaWxkcmVuLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlLCBzZWxlY3Rpb25PbkRyYWcsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgem9vbVBhbmUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBsaWIsIGNvbm5lY3Rpb25JblByb2dyZXNzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRqLCBzaGFsbG93KTtcbiAgICBjb25zdCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyh6b29tQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhblpvb20gPSB1c2VSZWYoKTtcbiAgICB1c2VSZXNpemVIYW5kbGVyKHpvb21QYW5lKTtcbiAgICBjb25zdCBvblRyYW5zZm9ybUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKHsgeDogdHJhbnNmb3JtWzBdLCB5OiB0cmFuc2Zvcm1bMV0sIHpvb206IHRyYW5zZm9ybVsyXSB9KTtcbiAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoem9vbVBhbmUuY3VycmVudCkge1xuICAgICAgICAgICAgcGFuWm9vbS5jdXJyZW50ID0gWFlQYW5ab29tKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiB6b29tUGFuZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlOiAocGFuZURyYWdnaW5nKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IHBhbmVEcmFnZ2luZyB9KSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydDogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2VTdGFydCwgb25Nb3ZlU3RhcnQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZVN0YXJ0Py4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZSwgb25Nb3ZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCwgb25Nb3ZlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmVFbmQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlRW5kPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gcGFuWm9vbS5jdXJyZW50LmdldFZpZXdwb3J0KCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuWm9vbTogcGFuWm9vbS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3gsIHksIHpvb21dLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcGFuWm9vbS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JblByb2dyZXNzLFxuICAgICAgICAgICAgc2VsZWN0aW9uT25EcmFnLFxuICAgICAgICAgICAgcGFuZUNsaWNrRGlzdGFuY2UsXG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICBwYW5PblNjcm9sbE1vZGUsXG4gICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgIGxpYixcbiAgICAgICAgb25UcmFuc2Zvcm1DaGFuZ2UsXG4gICAgICAgIGNvbm5lY3Rpb25JblByb2dyZXNzLFxuICAgICAgICBzZWxlY3Rpb25PbkRyYWcsXG4gICAgICAgIHBhbmVDbGlja0Rpc3RhbmNlLFxuICAgIF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3JlbmRlcmVyXCIsIHJlZjogem9vbVBhbmUsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkaSA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICB1c2VyU2VsZWN0aW9uUmVjdDogcy51c2VyU2VsZWN0aW9uUmVjdCxcbn0pO1xuZnVuY3Rpb24gVXNlclNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25SZWN0IH0gPSB1c2VTdG9yZShzZWxlY3RvciRpLCBzaGFsbG93KTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgdXNlclNlbGVjdGlvblJlY3Q7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fc2VsZWN0aW9uIHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHVzZXJTZWxlY3Rpb25SZWN0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB1c2VyU2VsZWN0aW9uUmVjdC5oZWlnaHQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt1c2VyU2VsZWN0aW9uUmVjdC54fXB4LCAke3VzZXJTZWxlY3Rpb25SZWN0Lnl9cHgpYCxcbiAgICAgICAgfSB9KSk7XG59XG5cbmNvbnN0IHdyYXBIYW5kbGVyID0gKGhhbmRsZXIsIGNvbnRhaW5lclJlZikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyPy4oZXZlbnQpO1xuICAgIH07XG59O1xuY29uc3Qgc2VsZWN0b3IkaCA9IChzKSA9PiAoe1xuICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25JblByb2dyZXNzOiBzLmNvbm5lY3Rpb24uaW5Qcm9ncmVzcyxcbiAgICBkcmFnZ2luZzogcy5wYW5lRHJhZ2dpbmcsXG59KTtcbmZ1bmN0aW9uIFBhbmUoeyBpc1NlbGVjdGluZywgc2VsZWN0aW9uS2V5UHJlc3NlZCwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuT25EcmFnLCBwYW5lQ2xpY2tEaXN0YW5jZSwgc2VsZWN0aW9uT25EcmFnLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgb25QYW5lQ2xpY2ssIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCBlbGVtZW50c1NlbGVjdGFibGUsIGRyYWdnaW5nLCBjb25uZWN0aW9uSW5Qcm9ncmVzcyB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaCwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNTZWxlY3Rpb25FbmFibGVkID0gZWxlbWVudHNTZWxlY3RhYmxlICYmIChpc1NlbGVjdGluZyB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gdXNlUmVmKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlSWRzID0gdXNlUmVmKG5ldyBTZXQoKSk7XG4gICAgLy8gVXNlZCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldHMgZ28gb2YgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgYSBzZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb25JblByb2dyZXNzID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIFdlIHByZXZlbnQgY2xpY2sgZXZlbnRzIHdoZW4gdGhlIHVzZXIgbGV0IGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgICAgIC8vIFdlIGFsc28gcHJldmVudCBjbGljayBldmVudHMgd2hlbiBhIGNvbm5lY3Rpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCB8fCBjb25uZWN0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ2xpY2s/LihldmVudCk7XG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkucmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZz8uaW5jbHVkZXMoMikpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25QYW5lQ29udGV4dE1lbnU/LihldmVudCk7XG4gICAgfTtcbiAgICBjb25zdCBvbldoZWVsID0gb25QYW5lU2Nyb2xsID8gKGV2ZW50KSA9PiBvblBhbmVTY3JvbGwoZXZlbnQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uQ2xpY2tDYXB0dXJlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFdlIGFyZSB1c2luZyBjYXB0dXJlIGhlcmUgaW4gb3JkZXIgdG8gcHJldmVudCBvdGhlciBwb2ludGVyIGV2ZW50c1xuICAgIC8vIHRvIGJlIGFibGUgdG8gY3JlYXRlIGEgc2VsZWN0aW9uIGFib3ZlIGEgbm9kZSBvciBhbiBlZGdlXG4gICAgY29uc3Qgb25Qb2ludGVyRG93bkNhcHR1cmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb250YWluZXJCb3VuZHMuY3VycmVudCA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lckJvdW5kcy5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBldmVudFRhcmdldElzQ29udGFpbmVyID0gZXZlbnQudGFyZ2V0ID09PSBjb250YWluZXIuY3VycmVudDtcbiAgICAgICAgLy8gaWYgYSBjaGlsZCBlbGVtZW50IGhhcyB0aGUgJ25va2V5JyBjbGFzcywgd2UgZG9uJ3Qgd2FudCB0byBzd2FsbG93IHRoZSBldmVudCBhbmQgZG9uJ3Qgc3RhcnQgYSBzZWxlY3Rpb25cbiAgICAgICAgY29uc3QgaXNOb0tleUV2ZW50ID0gIWV2ZW50VGFyZ2V0SXNDb250YWluZXIgJiYgISFldmVudC50YXJnZXQuY2xvc2VzdCgnLm5va2V5Jyk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0aW9uQWN0aXZlID0gKHNlbGVjdGlvbk9uRHJhZyAmJiBldmVudFRhcmdldElzQ29udGFpbmVyKSB8fCBzZWxlY3Rpb25LZXlQcmVzc2VkO1xuICAgICAgICBpZiAoaXNOb0tleUV2ZW50IHx8ICFpc1NlbGVjdGluZyB8fCAhaXNTZWxlY3Rpb25BY3RpdmUgfHwgZXZlbnQuYnV0dG9uICE9PSAwIHx8ICFldmVudC5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQ/LnNldFBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICBzdGFydFg6IHgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiB5LFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWV2ZW50VGFyZ2V0SXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25SZWN0LCB0cmFuc2Zvcm0sIG5vZGVMb29rdXAsIGVkZ2VMb29rdXAsIGNvbm5lY3Rpb25Mb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzLCBkZWZhdWx0RWRnZU9wdGlvbnMsIHJlc2V0U2VsZWN0ZWRFbGVtZW50cywgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghY29udGFpbmVyQm91bmRzLmN1cnJlbnQgfHwgIXVzZXJTZWxlY3Rpb25SZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB4OiBtb3VzZVgsIHk6IG1vdXNlWSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICBjb25zdCB7IHN0YXJ0WCwgc3RhcnRZIH0gPSB1c2VyU2VsZWN0aW9uUmVjdDtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkRGlzdGFuY2UgPSBzZWxlY3Rpb25LZXlQcmVzc2VkID8gMCA6IHBhbmVDbGlja0Rpc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KG1vdXNlWCAtIHN0YXJ0WCwgbW91c2VZIC0gc3RhcnRZKTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSByZXF1aXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICBvblNlbGVjdGlvblN0YXJ0Py4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG5leHRVc2VyU2VsZWN0UmVjdCA9IHtcbiAgICAgICAgICAgIHN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WSxcbiAgICAgICAgICAgIHg6IG1vdXNlWCA8IHN0YXJ0WCA/IG1vdXNlWCA6IHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IG1vdXNlWSA8IHN0YXJ0WSA/IG1vdXNlWSA6IHN0YXJ0WSxcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLmFicyhtb3VzZVggLSBzdGFydFgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhtb3VzZVkgLSBzdGFydFkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0ZWROb2RlSWRzID0gc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3RlZEVkZ2VJZHMgPSBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudDtcbiAgICAgICAgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQgPSBuZXcgU2V0KGdldE5vZGVzSW5zaWRlKG5vZGVMb29rdXAsIG5leHRVc2VyU2VsZWN0UmVjdCwgdHJhbnNmb3JtLCBzZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLlBhcnRpYWwsIHRydWUpLm1hcCgobm9kZSkgPT4gbm9kZS5pZCkpO1xuICAgICAgICBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudCA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgZWRnZXNTZWxlY3RhYmxlID0gZGVmYXVsdEVkZ2VPcHRpb25zPy5zZWxlY3RhYmxlID8/IHRydWU7XG4gICAgICAgIC8vIFdlIGxvb2sgZm9yIGFsbCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNlbGVjdGVkIG5vZGVzXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZUlkIG9mIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb25zKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVkZ2VJZCB9IG9mIGNvbm5lY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IGVkZ2VMb29rdXAuZ2V0KGVkZ2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UgJiYgKGVkZ2Uuc2VsZWN0YWJsZSA/PyBlZGdlc1NlbGVjdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50LmFkZChlZGdlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZVNldHNFcXVhbChwcmV2U2VsZWN0ZWROb2RlSWRzLCBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50LCB0cnVlKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFyZVNldHNFcXVhbChwcmV2U2VsZWN0ZWRFZGdlSWRzLCBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXAsIHNlbGVjdGVkRWRnZUlkcy5jdXJyZW50KTtcbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbmV4dFVzZXJTZWxlY3RSZWN0LFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJVcCA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5yZWxlYXNlUG9pbnRlckNhcHR1cmU/LihldmVudC5wb2ludGVySWQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBvbmx5IHdhbnQgdG8gdHJpZ2dlciBjbGljayBmdW5jdGlvbnMgd2hlbiBpbiBzZWxlY3Rpb24gbW9kZSBpZlxuICAgICAgICAgKiB0aGUgdXNlciBkaWQgbm90IG1vdmUgdGhlIG1vdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF1c2VyU2VsZWN0aW9uQWN0aXZlICYmIGV2ZW50LnRhcmdldCA9PT0gY29udGFpbmVyLmN1cnJlbnQgJiYgc3RvcmUuZ2V0U3RhdGUoKS51c2VyU2VsZWN0aW9uUmVjdCkge1xuICAgICAgICAgICAgb25DbGljaz8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbkluUHJvZ3Jlc3MuY3VycmVudCkge1xuICAgICAgICAgICAgb25TZWxlY3Rpb25FbmQ/LihldmVudCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50LnNpemUgPiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9IHBhbk9uRHJhZyA9PT0gdHJ1ZSB8fCAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygwKSk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmUnLCB7IGRyYWdnYWJsZSwgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBpc1NlbGVjdGlvbkVuYWJsZWQgPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvblBvaW50ZXJFbnRlcjogaXNTZWxlY3Rpb25FbmFibGVkID8gdW5kZWZpbmVkIDogb25QYW5lTW91c2VFbnRlciwgb25Qb2ludGVyTW92ZTogaXNTZWxlY3Rpb25FbmFibGVkID8gb25Qb2ludGVyTW92ZSA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyVXA6IGlzU2VsZWN0aW9uRW5hYmxlZCA/IG9uUG9pbnRlclVwIDogdW5kZWZpbmVkLCBvblBvaW50ZXJEb3duQ2FwdHVyZTogaXNTZWxlY3Rpb25FbmFibGVkID8gb25Qb2ludGVyRG93bkNhcHR1cmUgOiB1bmRlZmluZWQsIG9uQ2xpY2tDYXB0dXJlOiBpc1NlbGVjdGlvbkVuYWJsZWQgPyBvbkNsaWNrQ2FwdHVyZSA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIHJlZjogY29udGFpbmVyLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBbY2hpbGRyZW4sIGpzeChVc2VyU2VsZWN0aW9uLCB7fSldIH0pKTtcbn1cblxuLypcbiAqIHRoaXMgaGFuZGxlciBpcyBjYWxsZWQgYnlcbiAqIDEuIHRoZSBjbGljayBoYW5kbGVyIHdoZW4gbm9kZSBpcyBub3QgZHJhZ2dhYmxlIG9yIHNlbGVjdE5vZGVzT25EcmFnID0gZmFsc2VcbiAqIG9yXG4gKiAyLiB0aGUgb24gZHJhZyBzdGFydCBoYW5kbGVyIHdoZW4gbm9kZSBpcyBkcmFnZ2FibGUgYW5kIHNlbGVjdE5vZGVzT25EcmFnID0gdHJ1ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVOb2RlQ2xpY2soeyBpZCwgc3RvcmUsIHVuc2VsZWN0ID0gZmFsc2UsIG5vZGVSZWYsIH0pIHtcbiAgICBjb25zdCB7IGFkZFNlbGVjdGVkTm9kZXMsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVMb29rdXAsIG9uRXJyb3IgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTInLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxMiddKGlkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgaWYgKCFub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgIGFkZFNlbGVjdGVkTm9kZXMoW2lkXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVuc2VsZWN0IHx8IChub2RlLnNlbGVjdGVkICYmIG11bHRpU2VsZWN0aW9uQWN0aXZlKSkge1xuICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoeyBub2RlczogW25vZGVdLCBlZGdlczogW10gfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBub2RlUmVmPy5jdXJyZW50Py5ibHVyKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIb29rIGZvciBjYWxsaW5nIFhZRHJhZyBoZWxwZXIgZnJvbSBAeHlmbG93L3N5c3RlbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZyh7IG5vZGVSZWYsIGRpc2FibGVkID0gZmFsc2UsIG5vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIG5vZGVJZCwgaXNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB4eURyYWcgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB4eURyYWcuY3VycmVudCA9IFhZRHJhZyh7XG4gICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duOiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBoYW5kbGVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBub2RlUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtub0RyYWdDbGFzc05hbWUsIGhhbmRsZVNlbGVjdG9yLCBkaXNhYmxlZCwgaXNTZWxlY3RhYmxlLCBub2RlUmVmLCBub2RlSWRdKTtcbiAgICByZXR1cm4gZHJhZ2dpbmc7XG59XG5cbmNvbnN0IHNlbGVjdGVkQW5kRHJhZ2dhYmxlID0gKG5vZGVzRHJhZ2dhYmxlKSA9PiAobikgPT4gbi5zZWxlY3RlZCAmJiAobi5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBuLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbi8qKlxuICogSG9vayBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnMgYnkgcGFzc2luZyBhIGRpcmVjdGlvbiBhbmQgZmFjdG9yXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyBmdW5jdGlvbiBmb3IgdXBkYXRpbmcgbm9kZSBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlQ2FsbGJhY2soKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnQsIHNuYXBUb0dyaWQsIHNuYXBHcmlkLCBub2Rlc0RyYWdnYWJsZSwgb25FcnJvciwgdXBkYXRlTm9kZVBvc2l0aW9ucywgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3Qgbm9kZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZEFuZERyYWdnYWJsZShub2Rlc0RyYWdnYWJsZSk7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGJ5IGRlZmF1bHQgYSBub2RlIG1vdmVzIDVweCBvbiBlYWNoIGtleSBwcmVzc1xuICAgICAgICAgKiBpZiBzbmFwIGdyaWQgaXMgZW5hYmxlZCwgd2UgdXNlIHRoYXQgZm9yIHRoZSB2ZWxvY2l0eVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeFZlbG8gPSBzbmFwVG9HcmlkID8gc25hcEdyaWRbMF0gOiA1O1xuICAgICAgICBjb25zdCB5VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFsxXSA6IDU7XG4gICAgICAgIGNvbnN0IHhEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi54ICogeFZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBjb25zdCB5RGlmZiA9IHBhcmFtcy5kaXJlY3Rpb24ueSAqIHlWZWxvICogcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54ICsgeERpZmYsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICsgeURpZmYsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNuYXBUb0dyaWQpIHtcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBzbmFwUG9zaXRpb24obmV4dFBvc2l0aW9uLCBzbmFwR3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIG5vZGVJZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZSA9IHBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBub2RlVXBkYXRlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhub2RlVXBkYXRlcyk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBtb3ZlU2VsZWN0ZWROb2Rlcztcbn1cblxuY29uc3QgTm9kZUlkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBQcm92aWRlciA9IE5vZGVJZENvbnRleHQuUHJvdmlkZXI7XG5Ob2RlSWRDb250ZXh0LkNvbnN1bWVyO1xuLyoqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZ2V0IHRoZSBpZCBvZiB0aGUgbm9kZSBpdCBpcyB1c2VkIGluc2lkZS4gSXQgaXMgdXNlZnVsXG4gKiBpZiB5b3UgbmVlZCB0aGUgbm9kZSdzIGlkIGRlZXBlciBpbiB0aGUgcmVuZGVyIHRyZWUgYnV0IGRvbid0IHdhbnQgdG8gbWFudWFsbHlcbiAqIGRyaWxsIGRvd24gdGhlIGlkIGFzIGEgcHJvcC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBUaGUgaWQgZm9yIGEgbm9kZSBpbiB0aGUgZmxvdy5cbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUlkIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDdXN0b21Ob2RlKCkge1xuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8c3Bhbj5UaGlzIG5vZGUgaGFzIGFuIGlkIG9mIDwvc3Bhbj5cbiAqICAgICAgPE5vZGVJZERpc3BsYXkgLz5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqXG4gKmZ1bmN0aW9uIE5vZGVJZERpc3BsYXkoKSB7XG4gKiAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gKlxuICogIHJldHVybiA8c3Bhbj57bm9kZUlkfTwvc3Bhbj47XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IHVzZU5vZGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBub2RlSWQgPSB1c2VDb250ZXh0KE5vZGVJZENvbnRleHQpO1xuICAgIHJldHVybiBub2RlSWQ7XG59O1xuXG5jb25zdCBzZWxlY3RvciRnID0gKHMpID0+ICh7XG4gICAgY29ubmVjdE9uQ2xpY2s6IHMuY29ubmVjdE9uQ2xpY2ssXG4gICAgbm9QYW5DbGFzc05hbWU6IHMubm9QYW5DbGFzc05hbWUsXG4gICAgcmZJZDogcy5yZklkLFxufSk7XG5jb25zdCBjb25uZWN0aW5nU2VsZWN0b3IgPSAobm9kZUlkLCBoYW5kbGVJZCwgdHlwZSkgPT4gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogY2xpY2tIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBjb25uZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGZyb21IYW5kbGUsIHRvSGFuZGxlLCBpc1ZhbGlkIH0gPSBjb25uZWN0aW9uO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdUbyA9IHRvSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiB0b0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIHRvSGFuZGxlPy50eXBlID09PSB0eXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3RpbmdGcm9tOiBmcm9tSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBmcm9tSGFuZGxlPy5pZCA9PT0gaGFuZGxlSWQgJiYgZnJvbUhhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgY29ubmVjdGluZ1RvLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpbmc6IGNsaWNrSGFuZGxlPy5ub2RlSWQgPT09IG5vZGVJZCAmJiBjbGlja0hhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGNsaWNrSGFuZGxlPy50eXBlID09PSB0eXBlLFxuICAgICAgICBpc1Bvc3NpYmxlRW5kSGFuZGxlOiBjb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgICAgICA/IGZyb21IYW5kbGU/LnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIDogbm9kZUlkICE9PSBmcm9tSGFuZGxlPy5ub2RlSWQgfHwgaGFuZGxlSWQgIT09IGZyb21IYW5kbGU/LmlkLFxuICAgICAgICBjb25uZWN0aW9uSW5Qcm9jZXNzOiAhIWZyb21IYW5kbGUsXG4gICAgICAgIGNsaWNrQ29ubmVjdGlvbkluUHJvY2VzczogISFjbGlja0hhbmRsZSxcbiAgICAgICAgdmFsaWQ6IGNvbm5lY3RpbmdUbyAmJiBpc1ZhbGlkLFxuICAgIH07XG59O1xuZnVuY3Rpb24gSGFuZGxlQ29tcG9uZW50KHsgdHlwZSA9ICdzb3VyY2UnLCBwb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgaXNWYWxpZENvbm5lY3Rpb24sIGlzQ29ubmVjdGFibGUgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlU3RhcnQgPSB0cnVlLCBpc0Nvbm5lY3RhYmxlRW5kID0gdHJ1ZSwgaWQsIG9uQ29ubmVjdCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgb25Nb3VzZURvd24sIG9uVG91Y2hTdGFydCwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCBoYW5kbGVJZCA9IGlkIHx8IG51bGw7XG4gICAgY29uc3QgaXNUYXJnZXQgPSB0eXBlID09PSAndGFyZ2V0JztcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgeyBjb25uZWN0T25DbGljaywgbm9QYW5DbGFzc05hbWUsIHJmSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgY29ubmVjdGluZ0Zyb20sIGNvbm5lY3RpbmdUbywgY2xpY2tDb25uZWN0aW5nLCBpc1Bvc3NpYmxlRW5kSGFuZGxlLCBjb25uZWN0aW9uSW5Qcm9jZXNzLCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MsIHZhbGlkLCB9ID0gdXNlU3RvcmUoY29ubmVjdGluZ1NlbGVjdG9yKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpLCBzaGFsbG93KTtcbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEwJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTAnXSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb25Db25uZWN0RXh0ZW5kZWQgPSAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEVkZ2VPcHRpb25zLCBvbkNvbm5lY3Q6IG9uQ29ubmVjdEFjdGlvbiwgaGFzRGVmYXVsdEVkZ2VzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBlZGdlUGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzLCBzZXRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGFkZEVkZ2UoZWRnZVBhcmFtcywgZWRnZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBvbkNvbm5lY3RBY3Rpb24/LihlZGdlUGFyYW1zKTtcbiAgICAgICAgb25Db25uZWN0Py4oZWRnZVBhcmFtcyk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNNb3VzZVRyaWdnZXJlZCA9IGlzTW91c2VFdmVudChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RhYmxlU3RhcnQgJiZcbiAgICAgICAgICAgICgoaXNNb3VzZVRyaWdnZXJlZCAmJiBldmVudC5idXR0b24gPT09IDApIHx8ICFpc01vdXNlVHJpZ2dlcmVkKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0b3JlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIFhZSGFuZGxlLm9uUG9pbnRlckRvd24oZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVEb21Ob2RlOiBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgICAgIGF1dG9QYW5PbkNvbm5lY3Q6IGN1cnJlbnRTdG9yZS5hdXRvUGFuT25Db25uZWN0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblJhZGl1czogY3VycmVudFN0b3JlLmNvbm5lY3Rpb25SYWRpdXMsXG4gICAgICAgICAgICAgICAgZG9tTm9kZTogY3VycmVudFN0b3JlLmRvbU5vZGUsXG4gICAgICAgICAgICAgICAgbm9kZUxvb2t1cDogY3VycmVudFN0b3JlLm5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgbGliOiBjdXJyZW50U3RvcmUubGliLFxuICAgICAgICAgICAgICAgIGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGhhbmRsZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBmbG93SWQ6IGN1cnJlbnRTdG9yZS5yZklkLFxuICAgICAgICAgICAgICAgIHBhbkJ5OiBjdXJyZW50U3RvcmUucGFuQnksXG4gICAgICAgICAgICAgICAgY2FuY2VsQ29ubmVjdGlvbjogY3VycmVudFN0b3JlLmNhbmNlbENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgb25Db25uZWN0U3RhcnQ6IGN1cnJlbnRTdG9yZS5vbkNvbm5lY3RTdGFydCxcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RFbmQ6IGN1cnJlbnRTdG9yZS5vbkNvbm5lY3RFbmQsXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbjogY3VycmVudFN0b3JlLnVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgb25Db25uZWN0OiBvbkNvbm5lY3RFeHRlbmRlZCxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb24gfHwgY3VycmVudFN0b3JlLmlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgICAgICAgICAgYXV0b1BhblNwZWVkOiBjdXJyZW50U3RvcmUuYXV0b1BhblNwZWVkLFxuICAgICAgICAgICAgICAgIGRyYWdUaHJlc2hvbGQ6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uRHJhZ1RocmVzaG9sZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01vdXNlVHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bj8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydD8uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kLCBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSwgY29ubmVjdGlvbk1vZGUsIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlLCBsaWIsIHJmSWQ6IGZsb3dJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbjogY29ubmVjdGlvblN0YXRlLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFub2RlSWQgfHwgKCFjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZSAmJiAhaXNDb25uZWN0YWJsZVN0YXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUpIHtcbiAgICAgICAgICAgIG9uQ2xpY2tDb25uZWN0U3RhcnQ/LihldmVudC5uYXRpdmVFdmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlOiB0eXBlIH0pO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogeyBub2RlSWQsIHR5cGUsIGlkOiBoYW5kbGVJZCB9IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlciA9IGlzVmFsaWRDb25uZWN0aW9uIHx8IGlzVmFsaWRDb25uZWN0aW9uU3RvcmU7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgaXNWYWxpZCB9ID0gWFlIYW5kbGUuaXNWYWxpZChldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgaGFuZGxlOiB7XG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGlkOiBoYW5kbGVJZCxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgZnJvbU5vZGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUubm9kZUlkLFxuICAgICAgICAgICAgZnJvbUhhbmRsZUlkOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS5pZCB8fCBudWxsLFxuICAgICAgICAgICAgZnJvbVR5cGU6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLnR5cGUsXG4gICAgICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIG9uQ29ubmVjdEV4dGVuZGVkKGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25DbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBkZWxldGUgY29ubmVjdGlvbkNsb25lLmluUHJvZ3Jlc3M7XG4gICAgICAgIGNvbm5lY3Rpb25DbG9uZS50b1Bvc2l0aW9uID0gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlID8gY29ubmVjdGlvbkNsb25lLnRvSGFuZGxlLnBvc2l0aW9uIDogbnVsbDtcbiAgICAgICAgb25DbGlja0Nvbm5lY3RFbmQ/LihldmVudCwgY29ubmVjdGlvbkNsb25lKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLWhhbmRsZWlkXCI6IGhhbmRsZUlkLCBcImRhdGEtbm9kZWlkXCI6IG5vZGVJZCwgXCJkYXRhLWhhbmRsZXBvc1wiOiBwb3NpdGlvbiwgXCJkYXRhLWlkXCI6IGAke3JmSWR9LSR7bm9kZUlkfS0ke2hhbmRsZUlkfS0ke3R5cGV9YCwgY2xhc3NOYW1lOiBjYyhbXG4gICAgICAgICAgICAncmVhY3QtZmxvd19faGFuZGxlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19oYW5kbGUtJHtwb3NpdGlvbn1gLFxuICAgICAgICAgICAgJ25vZHJhZycsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICFpc1RhcmdldCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RhYmxlc3RhcnQ6IGlzQ29ubmVjdGFibGVTdGFydCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZWVuZDogaXNDb25uZWN0YWJsZUVuZCxcbiAgICAgICAgICAgICAgICBjbGlja2Nvbm5lY3Rpbmc6IGNsaWNrQ29ubmVjdGluZyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nZnJvbTogY29ubmVjdGluZ0Zyb20sXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ3RvOiBjb25uZWN0aW5nVG8sXG4gICAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBzaG93cyB3aGVyZSB5b3UgY2FuIHN0YXJ0IGEgY29ubmVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgICAgICogYW5kIHdoZXJlIHlvdSBjYW4gZW5kIGl0IHdoaWxlIGNvbm5lY3RpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uaW5kaWNhdG9yOiBpc0Nvbm5lY3RhYmxlICYmXG4gICAgICAgICAgICAgICAgICAgICghY29ubmVjdGlvbkluUHJvY2VzcyB8fCBpc1Bvc3NpYmxlRW5kSGFuZGxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoY29ubmVjdGlvbkluUHJvY2VzcyB8fCBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3MgPyBpc0Nvbm5lY3RhYmxlRW5kIDogaXNDb25uZWN0YWJsZVN0YXJ0KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCBvbk1vdXNlRG93bjogb25Qb2ludGVyRG93biwgb25Ub3VjaFN0YXJ0OiBvblBvaW50ZXJEb3duLCBvbkNsaWNrOiBjb25uZWN0T25DbGljayA/IG9uQ2xpY2sgOiB1bmRlZmluZWQsIHJlZjogcmVmLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxIYW5kbGUgLz5gIGNvbXBvbmVudCBpcyB1c2VkIGluIHlvdXIgW2N1c3RvbSBub2Rlc10oL2xlYXJuL2N1c3RvbWl6YXRpb24vY3VzdG9tLW5vZGVzKVxuICogdG8gZGVmaW5lIGNvbm5lY3Rpb24gcG9pbnRzLlxuICpcbiAqQHB1YmxpY1xuICpcbiAqQGV4YW1wbGVcbiAqXG4gKmBgYGpzeFxuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcxMHB4IDIwcHgnIH19PlxuICogICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpgYGBcbiAqL1xuY29uc3QgSGFuZGxlID0gbWVtbyhmaXhlZEZvcndhcmRSZWYoSGFuZGxlQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIElucHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtkYXRhPy5sYWJlbCwganN4KEhhbmRsZSwgeyB0eXBlOiBcInNvdXJjZVwiLCBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWwsIGpzeChIYW5kbGUsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pXSB9KSk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwTm9kZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gT3V0cHV0Tm9kZSh7IGRhdGEsIGlzQ29ubmVjdGFibGUsIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goSGFuZGxlLCB7IHR5cGU6IFwidGFyZ2V0XCIsIHBvc2l0aW9uOiB0YXJnZXRQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KSwgZGF0YT8ubGFiZWxdIH0pKTtcbn1cblxuY29uc3QgYXJyb3dLZXlEaWZmcyA9IHtcbiAgICBBcnJvd1VwOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgQXJyb3dEb3duOiB7IHg6IDAsIHk6IDEgfSxcbiAgICBBcnJvd0xlZnQ6IHsgeDogLTEsIHk6IDAgfSxcbiAgICBBcnJvd1JpZ2h0OiB7IHg6IDEsIHk6IDAgfSxcbn07XG5jb25zdCBidWlsdGluTm9kZVR5cGVzID0ge1xuICAgIGlucHV0OiBJbnB1dE5vZGUsXG4gICAgZGVmYXVsdDogRGVmYXVsdE5vZGUsXG4gICAgb3V0cHV0OiBPdXRwdXROb2RlLFxuICAgIGdyb3VwOiBHcm91cE5vZGUsXG59O1xuZnVuY3Rpb24gZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgaWYgKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyBub2RlLnN0eWxlPy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IG5vZGUuc3R5bGU/LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gbm9kZS5zdHlsZT8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgPz8gbm9kZS5zdHlsZT8uaGVpZ2h0LFxuICAgIH07XG59XG5cbmNvbnN0IHNlbGVjdG9yJGYgPSAocykgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHtcbiAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISFub2RlLnNlbGVjdGVkLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBpc051bWVyaWMod2lkdGgpID8gd2lkdGggOiBudWxsLFxuICAgICAgICBoZWlnaHQ6IGlzTnVtZXJpYyhoZWlnaHQpID8gaGVpZ2h0IDogbnVsbCxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICB0cmFuc2Zvcm1TdHJpbmc6IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSkgdHJhbnNsYXRlKCR7eH1weCwke3l9cHgpYCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIE5vZGVzU2VsZWN0aW9uKHsgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB0cmFuc2Zvcm1TdHJpbmcsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGYsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZUtleWJvYXJkQTExeSkge1xuICAgICAgICAgICAgbm9kZVJlZi5jdXJyZW50Py5mb2N1cyh7XG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2Rpc2FibGVLZXlib2FyZEExMXldKTtcbiAgICB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICB9KTtcbiAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb25Db250ZXh0TWVudSA9IG9uU2VsZWN0aW9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzLmZpbHRlcigobikgPT4gbi5zZWxlY3RlZCk7XG4gICAgICAgICAgICBvblNlbGVjdGlvbkNvbnRleHRNZW51KGV2ZW50LCBzZWxlY3RlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbicsICdyZWFjdC1mbG93X19jb250YWluZXInLCBub1BhbkNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1TdHJpbmcsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyByZWY6IG5vZGVSZWYsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19ub2Rlc3NlbGVjdGlvbi1yZWN0XCIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnUsIHRhYkluZGV4OiBkaXNhYmxlS2V5Ym9hcmRBMTF5ID8gdW5kZWZpbmVkIDogLTEsIG9uS2V5RG93bjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IG9uS2V5RG93biwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB9IH0pIH0pKTtcbn1cblxuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG5jb25zdCBzZWxlY3RvciRlID0gKHMpID0+IHtcbiAgICByZXR1cm4geyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogcy5ub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlIH07XG59O1xuZnVuY3Rpb24gRmxvd1JlbmRlcmVyQ29tcG9uZW50KHsgY2hpbGRyZW4sIG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGwsIHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IF9wYW5PblNjcm9sbCwgcGFuT25TY3JvbGxTcGVlZCwgcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljaywgcGFuT25EcmFnOiBfcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbSwgbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZywgb25TZWxlY3Rpb25Db250ZXh0TWVudSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0LCB9KSB7XG4gICAgY29uc3QgeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZSwgdXNlclNlbGVjdGlvbkFjdGl2ZSB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkZSwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IHVzZUtleVByZXNzKHNlbGVjdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhwYW5BY3RpdmF0aW9uS2V5Q29kZSwgeyB0YXJnZXQ6IHdpbiB9KTtcbiAgICBjb25zdCBwYW5PbkRyYWcgPSBwYW5BY3RpdmF0aW9uS2V5UHJlc3NlZCB8fCBfcGFuT25EcmFnO1xuICAgIGNvbnN0IHBhbk9uU2Nyb2xsID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uU2Nyb2xsO1xuICAgIGNvbnN0IF9zZWxlY3Rpb25PbkRyYWcgPSBzZWxlY3Rpb25PbkRyYWcgJiYgcGFuT25EcmFnICE9PSB0cnVlO1xuICAgIGNvbnN0IGlzU2VsZWN0aW5nID0gc2VsZWN0aW9uS2V5UHJlc3NlZCB8fCB1c2VyU2VsZWN0aW9uQWN0aXZlIHx8IF9zZWxlY3Rpb25PbkRyYWc7XG4gICAgdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSB9KTtcbiAgICByZXR1cm4gKGpzeChab29tUGFuZSwgeyBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCB6b29tT25TY3JvbGw6IHpvb21PblNjcm9sbCwgem9vbU9uUGluY2g6IHpvb21PblBpbmNoLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCB6b29tT25Eb3VibGVDbGljazogem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogIXNlbGVjdGlvbktleVByZXNzZWQgJiYgcGFuT25EcmFnLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBwcmV2ZW50U2Nyb2xsaW5nOiBwcmV2ZW50U2Nyb2xsaW5nLCBub1doZWVsQ2xhc3NOYW1lOiBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UsIGlzQ29udHJvbGxlZFZpZXdwb3J0OiBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBzZWxlY3Rpb25PbkRyYWc6IF9zZWxlY3Rpb25PbkRyYWcsIGNoaWxkcmVuOiBqc3hzKFBhbmUsIHsgb25TZWxlY3Rpb25TdGFydDogb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQ6IG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljazogb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXI6IG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZTogb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlOiBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgaXNTZWxlY3Rpbmc6ICEhaXNTZWxlY3RpbmcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIHNlbGVjdGlvbktleVByZXNzZWQ6IHNlbGVjdGlvbktleVByZXNzZWQsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgc2VsZWN0aW9uT25EcmFnOiBfc2VsZWN0aW9uT25EcmFnLCBjaGlsZHJlbjogW2NoaWxkcmVuLCBub2Rlc1NlbGVjdGlvbkFjdGl2ZSAmJiAoanN4KE5vZGVzU2VsZWN0aW9uLCB7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KSldIH0pIH0pKTtcbn1cbkZsb3dSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdGbG93UmVuZGVyZXInO1xuY29uc3QgRmxvd1JlbmRlcmVyID0gbWVtbyhGbG93UmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciRkID0gKG9ubHlSZW5kZXJWaXNpYmxlKSA9PiAocykgPT4ge1xuICAgIHJldHVybiBvbmx5UmVuZGVyVmlzaWJsZVxuICAgICAgICA/IGdldE5vZGVzSW5zaWRlKHMubm9kZUxvb2t1cCwgeyB4OiAwLCB5OiAwLCB3aWR0aDogcy53aWR0aCwgaGVpZ2h0OiBzLmhlaWdodCB9LCBzLnRyYW5zZm9ybSwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKVxuICAgICAgICA6IEFycmF5LmZyb20ocy5ub2RlTG9va3VwLmtleXMoKSk7XG59O1xuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSB2aXNpYmxlIG5vZGUgaWRzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG9ubHlSZW5kZXJWaXNpYmxlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgbm9kZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlVmlzaWJsZU5vZGVJZHMob25seVJlbmRlclZpc2libGUpIHtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soc2VsZWN0b3IkZChvbmx5UmVuZGVyVmlzaWJsZSksIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZUlkcztcbn1cblxuY29uc3Qgc2VsZWN0b3IkYyA9IChzKSA9PiBzLnVwZGF0ZU5vZGVJbnRlcm5hbHM7XG5mdW5jdGlvbiB1c2VSZXNpemVPYnNlcnZlcigpIHtcbiAgICBjb25zdCB1cGRhdGVOb2RlSW50ZXJuYWxzID0gdXNlU3RvcmUoc2VsZWN0b3IkYyk7XG4gICAgY29uc3QgW3Jlc2l6ZU9ic2VydmVyXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBlbnRyeS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFbGVtZW50OiBlbnRyeS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbcmVzaXplT2JzZXJ2ZXJdKTtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59XG5cbi8qKlxuICogSG9vayB0byBoYW5kbGUgdGhlIHJlc2l6ZSBvYnNlcnZhdGlvbiArIGludGVybmFsIHVwZGF0ZXMgZm9yIHRoZSBwYXNzZWQgbm9kZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIG5vZGVSZWYgLSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBvYnNlcnZlZE5vZGUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcHJldlNvdXJjZVBvc2l0aW9uID0gdXNlUmVmKG5vZGUuc291cmNlUG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUYXJnZXRQb3NpdGlvbiA9IHVzZVJlZihub2RlLnRhcmdldFBvc2l0aW9uKTtcbiAgICBjb25zdCBwcmV2VHlwZSA9IHVzZVJlZihub2RlVHlwZSk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IGhhc0RpbWVuc2lvbnMgJiYgISFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCAmJiAhbm9kZS5oaWRkZW4gJiYgKCFpc0luaXRpYWxpemVkIHx8IG9ic2VydmVkTm9kZS5jdXJyZW50ICE9PSBub2RlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKG5vZGVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG5vZGVSZWYuY3VycmVudDtcbiAgICAgICAgfVxuICAgIH0sIFtpc0luaXRpYWxpemVkLCBub2RlLmhpZGRlbl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB3aGVuIHRoZSB1c2VyIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyB0aGUgc291cmNlIG9yIGhhbmRsZSBwb3NpdGlvbiwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGludGVybmFsc1xuICAgICAgICAgICAgICogdG8gbWFrZSBzdXJlIHRoZSBlZGdlcyBhcmUgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdHlwZUNoYW5nZWQgPSBwcmV2VHlwZS5jdXJyZW50ICE9PSBub2RlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvc0NoYW5nZWQgPSBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS5zb3VyY2VQb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvc0NoYW5nZWQgPSBwcmV2VGFyZ2V0UG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlQ2hhbmdlZCB8fCBzb3VyY2VQb3NDaGFuZ2VkIHx8IHRhcmdldFBvc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcmV2VHlwZS5jdXJyZW50ID0gbm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ID0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlTm9kZUludGVybmFscyhuZXcgTWFwKFtbbm9kZS5pZCwgeyBpZDogbm9kZS5pZCwgbm9kZUVsZW1lbnQ6IG5vZGVSZWYuY3VycmVudCwgZm9yY2U6IHRydWUgfV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbm9kZS5pZCwgbm9kZVR5cGUsIG5vZGUuc291cmNlUG9zaXRpb24sIG5vZGUudGFyZ2V0UG9zaXRpb25dKTtcbiAgICByZXR1cm4gbm9kZVJlZjtcbn1cblxuZnVuY3Rpb24gTm9kZVdyYXBwZXIoeyBpZCwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrLCBub2Rlc0RyYWdnYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgcmVzaXplT2JzZXJ2ZXIsIG5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQsIG5vZGVUeXBlcywgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCB7IG5vZGUsIGludGVybmFscywgaXNQYXJlbnQgfSA9IHVzZVN0b3JlKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgY29uc3QgaXNQYXJlbnQgPSBzLnBhcmVudExvb2t1cC5oYXMoaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGludGVybmFsczogbm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICBpc1BhcmVudCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBsZXQgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBOb2RlQ29tcG9uZW50ID0gbm9kZVR5cGVzPy5bbm9kZVR5cGVdIHx8IGJ1aWx0aW5Ob2RlVHlwZXNbbm9kZVR5cGVdO1xuICAgIGlmIChOb2RlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMDMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMyddKG5vZGVUeXBlKSk7XG4gICAgICAgIG5vZGVUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBOb2RlQ29tcG9uZW50ID0gbm9kZVR5cGVzPy5bJ2RlZmF1bHQnXSB8fCBidWlsdGluTm9kZVR5cGVzLmRlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISEobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1NlbGVjdGFibGUgPSAhIShub2RlLnNlbGVjdGFibGUgfHwgKGVsZW1lbnRzU2VsZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5zZWxlY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzQ29ubmVjdGFibGUgPSAhIShub2RlLmNvbm5lY3RhYmxlIHx8IChub2Rlc0Nvbm5lY3RhYmxlICYmIHR5cGVvZiBub2RlLmNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEobm9kZS5mb2N1c2FibGUgfHwgKG5vZGVzRm9jdXNhYmxlICYmIHR5cGVvZiBub2RlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaGFzRGltZW5zaW9ucyA9IG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG5vZGVSZWYgPSB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIgfSk7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSB1c2VEcmFnKHtcbiAgICAgICAgbm9kZVJlZixcbiAgICAgICAgZGlzYWJsZWQ6IG5vZGUuaGlkZGVuIHx8ICFpc0RyYWdnYWJsZSxcbiAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICBoYW5kbGVTZWxlY3Rvcjogbm9kZS5kcmFnSGFuZGxlLFxuICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgIH0pO1xuICAgIGNvbnN0IG1vdmVTZWxlY3RlZE5vZGVzID0gdXNlTW92ZVNlbGVjdGVkTm9kZXMoKTtcbiAgICBpZiAobm9kZS5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaW5saW5lRGltZW5zaW9ucyA9IGdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9IGlzU2VsZWN0YWJsZSB8fCBpc0RyYWdnYWJsZSB8fCBvbkNsaWNrIHx8IG9uTW91c2VFbnRlciB8fCBvbk1vdXNlTW92ZSB8fCBvbk1vdXNlTGVhdmU7XG4gICAgY29uc3Qgb25Nb3VzZUVudGVySGFuZGxlciA9IG9uTW91c2VFbnRlclxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZUVudGVyKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlTW92ZUhhbmRsZXIgPSBvbk1vdXNlTW92ZVxuICAgICAgICA/IChldmVudCkgPT4gb25Nb3VzZU1vdmUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZUhhbmRsZXIgPSBvbk1vdXNlTGVhdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VMZWF2ZShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Db250ZXh0TWVudUhhbmRsZXIgPSBvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiBvbkNvbnRleHRNZW51KGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkRvdWJsZUNsaWNrSGFuZGxlciA9IG9uRG91YmxlQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uRG91YmxlQ2xpY2soZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uU2VsZWN0Tm9kZUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZURyYWdUaHJlc2hvbGQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgKCFzZWxlY3ROb2Rlc09uRHJhZyB8fCAhaXNEcmFnZ2FibGUgfHwgbm9kZURyYWdUaHJlc2hvbGQgPiAwKSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHRoaXMgaGFuZGxlciBnZXRzIGNhbGxlZCBieSBYWURyYWcgb24gZHJhZyBzdGFydCB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPXRydWVcbiAgICAgICAgICAgICAqIGhlcmUgd2Ugb25seSBuZWVkIHRvIGNhbGwgaXQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz1mYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbGljaykge1xuICAgICAgICAgICAgb25DbGljayhldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoaXNJbnB1dERPTU5vZGUoZXZlbnQubmF0aXZlRXZlbnQpIHx8IGRpc2FibGVLZXlib2FyZEExMXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudFNlbGVjdGlvbktleXMuaW5jbHVkZXMoZXZlbnQua2V5KSAmJiBpc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICAgICAgdW5zZWxlY3QsXG4gICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRHJhZ2dhYmxlICYmIG5vZGUuc2VsZWN0ZWQgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycm93S2V5RGlmZnMsIGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgYmVoYXZpb3Igb24gYXJyb3cga2V5IHByZXNzIHdoZW4gbm9kZSBpcyBtb3ZlZFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYXJpYUxhYmVsQ29uZmlnIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZTogYXJpYUxhYmVsQ29uZmlnWydub2RlLmExMXlEZXNjcmlwdGlvbi5hcmlhTGl2ZU1lc3NhZ2UnXSh7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZXZlbnQua2V5LnJlcGxhY2UoJ0Fycm93JywgJycpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHg6IH5+aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogfn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb3ZlU2VsZWN0ZWROb2Rlcyh7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBhcnJvd0tleURpZmZzW2V2ZW50LmtleV0sXG4gICAgICAgICAgICAgICAgZmFjdG9yOiBldmVudC5zaGlmdEtleSA/IDQgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNhYmxlS2V5Ym9hcmRBMTF5IHx8ICFub2RlUmVmLmN1cnJlbnQ/Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgYXV0b1Bhbk9uTm9kZUZvY3VzLCBzZXRDZW50ZXIgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uTm9kZUZvY3VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2l0aGluVmlld3BvcnQgPSBnZXROb2Rlc0luc2lkZShuZXcgTWFwKFtbaWQsIG5vZGVdXSksIHsgeDogMCwgeTogMCwgd2lkdGgsIGhlaWdodCB9LCB0cmFuc2Zvcm0sIHRydWUpLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghd2l0aGluVmlld3BvcnQpIHtcbiAgICAgICAgICAgIHNldENlbnRlcihub2RlLnBvc2l0aW9uLnggKyBub2RlRGltZW5zaW9ucy53aWR0aCAvIDIsIG5vZGUucG9zaXRpb24ueSArIG5vZGVEaW1lbnNpb25zLmhlaWdodCAvIDIsIHtcbiAgICAgICAgICAgICAgICB6b29tOiB0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICdyZWFjdC1mbG93X19ub2RlJyxcbiAgICAgICAgICAgIGByZWFjdC1mbG93X19ub2RlLSR7bm9kZVR5cGV9YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG92ZXJ3cml0YWJsZSBieSBwYXNzaW5nIGBub3BhbmAgYXMgYSBjbGFzcyBuYW1lXG4gICAgICAgICAgICAgICAgW25vUGFuQ2xhc3NOYW1lXTogaXNEcmFnZ2FibGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IG5vZGUuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaXNQYXJlbnQsXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pLCByZWY6IG5vZGVSZWYsIHN0eWxlOiB7XG4gICAgICAgICAgICB6SW5kZXg6IGludGVybmFscy56LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueH1weCwke2ludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnl9cHgpYCxcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGhhc1BvaW50ZXJFdmVudHMgPyAnYWxsJyA6ICdub25lJyxcbiAgICAgICAgICAgIHZpc2liaWxpdHk6IGhhc0RpbWVuc2lvbnMgPyAndmlzaWJsZScgOiAnaGlkZGVuJyxcbiAgICAgICAgICAgIC4uLm5vZGUuc3R5bGUsXG4gICAgICAgICAgICAuLi5pbmxpbmVEaW1lbnNpb25zLFxuICAgICAgICB9LCBcImRhdGEtaWRcIjogaWQsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19ub2RlLSR7aWR9YCwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJIYW5kbGVyLCBvbk1vdXNlTW92ZTogb25Nb3VzZU1vdmVIYW5kbGVyLCBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZUhhbmRsZXIsIG9uQ29udGV4dE1lbnU6IG9uQ29udGV4dE1lbnVIYW5kbGVyLCBvbkNsaWNrOiBvblNlbGVjdE5vZGVIYW5kbGVyLCBvbkRvdWJsZUNsaWNrOiBvbkRvdWJsZUNsaWNrSGFuZGxlciwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgb25Gb2N1czogaXNGb2N1c2FibGUgPyBvbkZvY3VzIDogdW5kZWZpbmVkLCByb2xlOiBub2RlLmFyaWFSb2xlID8/IChpc0ZvY3VzYWJsZSA/ICdncm91cCcgOiB1bmRlZmluZWQpLCBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwibm9kZVwiLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIFwiYXJpYS1sYWJlbFwiOiBub2RlLmFyaWFMYWJlbCwgLi4ubm9kZS5kb21BdHRyaWJ1dGVzLCBjaGlsZHJlbjoganN4KFByb3ZpZGVyLCB7IHZhbHVlOiBpZCwgY2hpbGRyZW46IGpzeChOb2RlQ29tcG9uZW50LCB7IGlkOiBpZCwgZGF0YTogbm9kZS5kYXRhLCB0eXBlOiBub2RlVHlwZSwgcG9zaXRpb25BYnNvbHV0ZVg6IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsIHBvc2l0aW9uQWJzb2x1dGVZOiBpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55LCBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCA/PyBmYWxzZSwgc2VsZWN0YWJsZTogaXNTZWxlY3RhYmxlLCBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLCBkZWxldGFibGU6IG5vZGUuZGVsZXRhYmxlID8/IHRydWUsIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUsIHNvdXJjZVBvc2l0aW9uOiBub2RlLnNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogbm9kZS50YXJnZXRQb3NpdGlvbiwgZHJhZ2dpbmc6IGRyYWdnaW5nLCBkcmFnSGFuZGxlOiBub2RlLmRyYWdIYW5kbGUsIHpJbmRleDogaW50ZXJuYWxzLnosIHBhcmVudElkOiBub2RlLnBhcmVudElkLCAuLi5ub2RlRGltZW5zaW9ucyB9KSB9KSB9KSk7XG59XG52YXIgTm9kZVdyYXBwZXIkMSA9IG1lbW8oTm9kZVdyYXBwZXIpO1xuXG5jb25zdCBzZWxlY3RvciRiID0gKHMpID0+ICh7XG4gICAgbm9kZXNEcmFnZ2FibGU6IHMubm9kZXNEcmFnZ2FibGUsXG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIG5vZGVzRm9jdXNhYmxlOiBzLm5vZGVzRm9jdXNhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBOb2RlUmVuZGVyZXJDb21wb25lbnQocHJvcHMpIHtcbiAgICBjb25zdCB7IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlVmlzaWJsZU5vZGVJZHMocHJvcHMub25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzXCIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IG5vZGVJZHMubWFwKChub2RlSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIHNwbGl0IG9mIHJlc3BvbnNpYmlsaXRpZXMgYmV0d2VlbiBOb2RlUmVuZGVyZXIgYW5kXG4gICAgICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiB5b3XigJlyZSBkcmFnZ2luZyBhIHNpbmdsZSBub2RlLCB0aGF0IG5vZGUgZ2V0c1xuICAgICAgICAgICAgICogdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBwZXIgc2Vjb25kLiBJZiBgTm9kZVJlbmRlcmVyYCB3ZXJlIHRvIHVwZGF0ZVxuICAgICAgICAgICAgICogZXZlcnkgdGltZSwgaXQgd291bGQgaGF2ZSB0byByZS1ydW4gdGhlIGBub2Rlcy5tYXAoKWAgbG9vcCBldmVyeVxuICAgICAgICAgICAgICogdGltZS4gVGhpcyBnZXRzIHByaWNleSB3aXRoIGh1bmRyZWRzIG9mIG5vZGVzLCBlc3BlY2lhbGx5IGlmIGV2ZXJ5XG4gICAgICAgICAgICAgKiBsb29wIGN5Y2xlIGRvZXMgbW9yZSB0aGFuIGp1c3QgcmVuZGVyaW5nIGEgSlNYIGVsZW1lbnQhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQXMgYSByZXN1bHQgb2YgdGhpcyBjaG9pY2UsIHdlIHRvb2sgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICogZGVjaXNpb25zOlxuICAgICAgICAgICAgICogLSBOb2RlUmVuZGVyZXIgc3Vic2NyaWJlcyAqb25seSogdG8gbm9kZSBJRHMg4oCTIGFuZCB0aGVyZWZvcmVcbiAgICAgICAgICAgICAqICAgcmVyZW5kZXIgKm9ubHkqIHdoZW4gdmlzaWJsZSBub2RlcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgICAgICAgICAqIC0gTm9kZVJlbmRlcmVyIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIHRoZSByZXN1bHQgb2Ygd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAgKiAgIHNoYXJlZCBiZXR3ZWVuIG5vZGVzIChzdWNoIGFzIGNyZWF0aW5nIHRoZSBgUmVzaXplT2JzZXJ2ZXJgXG4gICAgICAgICAgICAgKiAgIGluc3RhbmNlLCBvciBzdWJzY3JpYmluZyB0byBgc2VsZWN0b3JgKS4gVGhpcyBtZWFucyBleHRyYSBwcm9wXG4gICAgICAgICAgICAgKiAgIGRyaWxsaW5nIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYCwgYnV0IGl0IG1lYW5zIHdlIG5lZWQgdG8gcnVuXG4gICAgICAgICAgICAgKiAgIHRoZXNlIG9wZXJhdGlvbnMgb25seSBvbmNlIOKAkyBpbnN0ZWFkIG9mIG9uY2UgcGVyIG5vZGUuXG4gICAgICAgICAgICAgKiAtIEFueSBvcGVyYXRpb25zIHRoYXQgeW914oCZZCBub3JtYWxseSB3cml0ZSBpbnNpZGUgYG5vZGVzLm1hcGAgYXJlXG4gICAgICAgICAgICAgKiAgIG1vdmVkIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYC4gVGhpcyBlbnN1cmVzIHRoZXkgYXJlXG4gICAgICAgICAgICAgKiAgIG1lbW9yaXplZCDigJMgc28gaWYgYE5vZGVSZW5kZXJlcmAgKmhhcyogdG8gcmVyZW5kZXIsIGl0IG9ubHlcbiAgICAgICAgICAgICAqICAgbmVlZHMgdG8gcmVnZW5lcmF0ZSB0aGUgbGlzdCBvZiBub2Rlcywgbm90aGluZyBlbHNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBqc3goTm9kZVdyYXBwZXIkMSwgeyBpZDogbm9kZUlkLCBub2RlVHlwZXM6IHByb3BzLm5vZGVUeXBlcywgbm9kZUV4dGVudDogcHJvcHMubm9kZUV4dGVudCwgb25DbGljazogcHJvcHMub25Ob2RlQ2xpY2ssIG9uTW91c2VFbnRlcjogcHJvcHMub25Ob2RlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IHByb3BzLm9uTm9kZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBwcm9wcy5vbk5vZGVNb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51OiBwcm9wcy5vbk5vZGVDb250ZXh0TWVudSwgb25Eb3VibGVDbGljazogcHJvcHMub25Ob2RlRG91YmxlQ2xpY2ssIG5vRHJhZ0NsYXNzTmFtZTogcHJvcHMubm9EcmFnQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZTogcHJvcHMubm9QYW5DbGFzc05hbWUsIHJmSWQ6IHByb3BzLnJmSWQsIGRpc2FibGVLZXlib2FyZEExMXk6IHByb3BzLmRpc2FibGVLZXlib2FyZEExMXksIHJlc2l6ZU9ic2VydmVyOiByZXNpemVPYnNlcnZlciwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBub2RlQ2xpY2tEaXN0YW5jZTogcHJvcHMubm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3I6IG9uRXJyb3IgfSwgbm9kZUlkKSk7XG4gICAgICAgIH0pIH0pKTtcbn1cbk5vZGVSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdOb2RlUmVuZGVyZXInO1xuY29uc3QgTm9kZVJlbmRlcmVyID0gbWVtbyhOb2RlUmVuZGVyZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEhvb2sgZm9yIGdldHRpbmcgdGhlIHZpc2libGUgZWRnZSBpZHMgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gb25seVJlbmRlclZpc2libGVcbiAqIEByZXR1cm5zIGFycmF5IHdpdGggdmlzaWJsZSBlZGdlIGlkc1xuICovXG5mdW5jdGlvbiB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBpZiAoIW9ubHlSZW5kZXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5lZGdlcy5tYXAoKGVkZ2UpID0+IGVkZ2UuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpc2libGVFZGdlSWRzID0gW107XG4gICAgICAgIGlmIChzLndpZHRoICYmIHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygcy5lZGdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gcy5ub2RlTG9va3VwLmdldChlZGdlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0VkZ2VWaXNpYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUVkZ2VJZHMucHVzaChlZGdlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc2libGVFZGdlSWRzO1xuICAgIH0sIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gZWRnZUlkcztcbn1cblxuY29uc3QgQXJyb3dTeW1ib2wgPSAoeyBjb2xvciA9ICdub25lJywgc3Ryb2tlV2lkdGggPSAxIH0pID0+IHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIC4uLihjb2xvciAmJiB7IHN0cm9rZTogY29sb3IgfSksXG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcInBvbHlsaW5lXCIsIHsgY2xhc3NOYW1lOiBcImFycm93XCIsIHN0eWxlOiBzdHlsZSwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0XCIgfSkpO1xufTtcbmNvbnN0IEFycm93Q2xvc2VkU3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAuLi4oY29sb3IgJiYgeyBzdHJva2U6IGNvbG9yLCBmaWxsOiBjb2xvciB9KSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBjbGFzc05hbWU6IFwiYXJyb3djbG9zZWRcIiwgc3R5bGU6IHN0eWxlLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNCAtNSwtNFwiIH0pKTtcbn07XG5jb25zdCBNYXJrZXJTeW1ib2xzID0ge1xuICAgIFtNYXJrZXJUeXBlLkFycm93XTogQXJyb3dTeW1ib2wsXG4gICAgW01hcmtlclR5cGUuQXJyb3dDbG9zZWRdOiBBcnJvd0Nsb3NlZFN5bWJvbCxcbn07XG5mdW5jdGlvbiB1c2VNYXJrZXJTeW1ib2wodHlwZSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCBzeW1ib2wgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3ltYm9sRXhpc3RzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1hcmtlclN5bWJvbHMsIHR5cGUpO1xuICAgICAgICBpZiAoIXN5bWJvbEV4aXN0cykge1xuICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwOScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA5J10odHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hcmtlclN5bWJvbHNbdHlwZV07XG4gICAgfSwgW3R5cGVdKTtcbiAgICByZXR1cm4gc3ltYm9sO1xufVxuXG5jb25zdCBNYXJrZXIgPSAoeyBpZCwgdHlwZSwgY29sb3IsIHdpZHRoID0gMTIuNSwgaGVpZ2h0ID0gMTIuNSwgbWFya2VyVW5pdHMgPSAnc3Ryb2tlV2lkdGgnLCBzdHJva2VXaWR0aCwgb3JpZW50ID0gJ2F1dG8tc3RhcnQtcmV2ZXJzZScsIH0pID0+IHtcbiAgICBjb25zdCBTeW1ib2wgPSB1c2VNYXJrZXJTeW1ib2wodHlwZSk7XG4gICAgaWYgKCFTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwibWFya2VyXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2Fycm93aGVhZFwiLCBpZDogaWQsIG1hcmtlcldpZHRoOiBgJHt3aWR0aH1gLCBtYXJrZXJIZWlnaHQ6IGAke2hlaWdodH1gLCB2aWV3Qm94OiBcIi0xMCAtMTAgMjAgMjBcIiwgbWFya2VyVW5pdHM6IG1hcmtlclVuaXRzLCBvcmllbnQ6IG9yaWVudCwgcmVmWDogXCIwXCIsIHJlZlk6IFwiMFwiLCBjaGlsZHJlbjoganN4KFN5bWJvbCwgeyBjb2xvcjogY29sb3IsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCB9KSB9KSk7XG59O1xuLypcbiAqIHdoZW4geW91IGhhdmUgbXVsdGlwbGUgZmxvd3Mgb24gYSBwYWdlIGFuZCB5b3UgaGlkZSB0aGUgZmlyc3Qgb25lLCB0aGUgb3RoZXIgb25lcyBoYXZlIG5vIG1hcmtlcnMgYW55bW9yZVxuICogd2hlbiB0aGV5IGRvIGhhdmUgbWFya2VycyB3aXRoIHRoZSBzYW1lIGlkcy4gVG8gcHJldmVudCB0aGlzIHRoZSB1c2VyIGNhbiBwYXNzIGEgdW5pcXVlIGlkIHRvIHRoZSByZWFjdCBmbG93IHdyYXBwZXJcbiAqIHRoYXQgd2UgY2FuIHRoZW4gdXNlIGZvciBjcmVhdGluZyBvdXIgdW5pcXVlIG1hcmtlciBpZHNcbiAqL1xuY29uc3QgTWFya2VyRGVmaW5pdGlvbnMgPSAoeyBkZWZhdWx0Q29sb3IsIHJmSWQgfSkgPT4ge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoKHMpID0+IHMuZWRnZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHVzZVN0b3JlKChzKSA9PiBzLmRlZmF1bHRFZGdlT3B0aW9ucyk7XG4gICAgY29uc3QgbWFya2VycyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBtYXJrZXJzID0gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7XG4gICAgICAgICAgICBpZDogcmZJZCxcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcixcbiAgICAgICAgICAgIGRlZmF1bHRNYXJrZXJTdGFydDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJTdGFydCxcbiAgICAgICAgICAgIGRlZmF1bHRNYXJrZXJFbmQ6IGRlZmF1bHRFZGdlT3B0aW9ucz8ubWFya2VyRW5kLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfSwgW2VkZ2VzLCBkZWZhdWx0RWRnZU9wdGlvbnMsIHJmSWQsIGRlZmF1bHRDb2xvcl0pO1xuICAgIGlmICghbWFya2Vycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21hcmtlclwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBjaGlsZHJlbjoganN4KFwiZGVmc1wiLCB7IGNoaWxkcmVuOiBtYXJrZXJzLm1hcCgobWFya2VyKSA9PiAoanN4KE1hcmtlciwgeyBpZDogbWFya2VyLmlkLCB0eXBlOiBtYXJrZXIudHlwZSwgY29sb3I6IG1hcmtlci5jb2xvciwgd2lkdGg6IG1hcmtlci53aWR0aCwgaGVpZ2h0OiBtYXJrZXIuaGVpZ2h0LCBtYXJrZXJVbml0czogbWFya2VyLm1hcmtlclVuaXRzLCBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoLCBvcmllbnQ6IG1hcmtlci5vcmllbnQgfSwgbWFya2VyLmlkKSkpIH0pIH0pKTtcbn07XG5NYXJrZXJEZWZpbml0aW9ucy5kaXNwbGF5TmFtZSA9ICdNYXJrZXJEZWZpbml0aW9ucyc7XG52YXIgTWFya2VyRGVmaW5pdGlvbnMkMSA9IG1lbW8oTWFya2VyRGVmaW5pdGlvbnMpO1xuXG5mdW5jdGlvbiBFZGdlVGV4dENvbXBvbmVudCh7IHgsIHksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZyA9IHRydWUsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcgPSBbMiwgNF0sIGxhYmVsQmdCb3JkZXJSYWRpdXMgPSAyLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBbZWRnZVRleHRCYm94LCBzZXRFZGdlVGV4dEJib3hdID0gdXNlU3RhdGUoeyB4OiAxLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0Q2xhc3NlcyA9IGNjKFsncmVhY3QtZmxvd19fZWRnZS10ZXh0d3JhcHBlcicsIGNsYXNzTmFtZV0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlZGdlVGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QmJveCA9IGVkZ2VUZXh0UmVmLmN1cnJlbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgc2V0RWRnZVRleHRCYm94KHtcbiAgICAgICAgICAgICAgICB4OiB0ZXh0QmJveC54LFxuICAgICAgICAgICAgICAgIHk6IHRleHRCYm94LnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRleHRCYm94LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dEJib3guaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbbGFiZWxdKTtcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeHMoXCJnXCIsIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7eCAtIGVkZ2VUZXh0QmJveC53aWR0aCAvIDJ9ICR7eSAtIGVkZ2VUZXh0QmJveC5oZWlnaHQgLyAyfSlgLCBjbGFzc05hbWU6IGVkZ2VUZXh0Q2xhc3NlcywgdmlzaWJpbGl0eTogZWRnZVRleHRCYm94LndpZHRoID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIC4uLnJlc3QsIGNoaWxkcmVuOiBbbGFiZWxTaG93QmcgJiYgKGpzeChcInJlY3RcIiwgeyB3aWR0aDogZWRnZVRleHRCYm94LndpZHRoICsgMiAqIGxhYmVsQmdQYWRkaW5nWzBdLCB4OiAtbGFiZWxCZ1BhZGRpbmdbMF0sIHk6IC1sYWJlbEJnUGFkZGluZ1sxXSwgaGVpZ2h0OiBlZGdlVGV4dEJib3guaGVpZ2h0ICsgMiAqIGxhYmVsQmdQYWRkaW5nWzFdLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZS10ZXh0YmdcIiwgc3R5bGU6IGxhYmVsQmdTdHlsZSwgcng6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHJ5OiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSwganN4KFwidGV4dFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRcIiwgeTogZWRnZVRleHRCYm94LmhlaWdodCAvIDIsIGR5OiBcIjAuM2VtXCIsIHJlZjogZWRnZVRleHRSZWYsIHN0eWxlOiBsYWJlbFN0eWxlLCBjaGlsZHJlbjogbGFiZWwgfSksIGNoaWxkcmVuXSB9KSk7XG59XG5FZGdlVGV4dENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlVGV4dCc7XG4vKipcbiAqIFlvdSBjYW4gdXNlIHRoZSBgPEVkZ2VUZXh0IC8+YCBjb21wb25lbnQgYXMgYSBoZWxwZXIgY29tcG9uZW50IHRvIGRpc3BsYXkgdGV4dFxuICogd2l0aGluIHlvdXIgY3VzdG9tIGVkZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgeyBFZGdlVGV4dCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlTGFiZWwoeyBsYWJlbCB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEVkZ2VUZXh0XG4gKiAgICAgICB4PXsxMDB9XG4gKiAgICAgICB5PXsxMDB9XG4gKiAgICAgICBsYWJlbD17bGFiZWx9XG4gKiAgICAgICBsYWJlbFN0eWxlPXt7IGZpbGw6ICd3aGl0ZScgfX1cbiAqICAgICAgIGxhYmVsU2hvd0JnXG4gKiAgICAgICBsYWJlbEJnU3R5bGU9e3sgZmlsbDogJ3JlZCcgfX1cbiAqICAgICAgIGxhYmVsQmdQYWRkaW5nPXtbMiwgNF19XG4gKiAgICAgICBsYWJlbEJnQm9yZGVyUmFkaXVzPXsyfVxuICogICAgIC8+XG4gKiAgICk7XG4gKiB9XG4gKmBgYFxuICovXG5jb25zdCBFZGdlVGV4dCA9IG1lbW8oRWRnZVRleHRDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBgPEJhc2VFZGdlIC8+YCBjb21wb25lbnQgZ2V0cyB1c2VkIGludGVybmFsbHkgZm9yIGFsbCB0aGUgZWRnZXMuIEl0IGNhbiBiZVxuICogdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSBhbmQgaGFuZGxlcyB0aGUgaW52aXNpYmxlIGhlbHBlciBlZGdlIGFuZCB0aGUgZWRnZSBsYWJlbFxuICogZm9yIHlvdS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IEJhc2VFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIC4uLnByb3BzIH0pIHtcbiAqICBjb25zdCBbZWRnZVBhdGhdID0gZ2V0U3RyYWlnaHRQYXRoKHtcbiAqICAgIHNvdXJjZVgsXG4gKiAgICBzb3VyY2VZLFxuICogICAgdGFyZ2V0WCxcbiAqICAgIHRhcmdldFksXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiA8QmFzZUVkZ2UgcGF0aD17ZWRnZVBhdGh9IHsuLi5wcm9wc30gLz47XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgSWYgeW91IHdhbnQgdG8gdXNlIGFuIGVkZ2UgbWFya2VyIHdpdGggdGhlIFtgPEJhc2VFZGdlIC8+YF0oL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9iYXNlLWVkZ2UpIGNvbXBvbmVudCxcbiAqIHlvdSBjYW4gcGFzcyB0aGUgYG1hcmtlclN0YXJ0YCBvciBgbWFya2VyRW5kYCBwcm9wcyBwYXNzZWQgdG8geW91ciBjdXN0b20gZWRnZVxuICogdGhyb3VnaCB0byB0aGUgW2A8QmFzZUVkZ2UgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2Jhc2UtZWRnZSkgY29tcG9uZW50LlxuICogWW91IGNhbiBzZWUgYWxsIHRoZSBwcm9wcyBwYXNzZWQgdG8gYSBjdXN0b20gZWRnZSBieSBsb29raW5nIGF0IHRoZSBbYEVkZ2VQcm9wc2BdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UtcHJvcHMpIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIEJhc2VFZGdlKHsgcGF0aCwgbGFiZWxYLCBsYWJlbFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgaW50ZXJhY3Rpb25XaWR0aCA9IDIwLCAuLi5wcm9wcyB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IC4uLnByb3BzLCBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2VkZ2UtcGF0aCcsIHByb3BzLmNsYXNzTmFtZV0pIH0pLCBpbnRlcmFjdGlvbldpZHRoID8gKGpzeChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlT3BhY2l0eTogMCwgc3Ryb2tlV2lkdGg6IGludGVyYWN0aW9uV2lkdGgsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLWludGVyYWN0aW9uXCIgfSkpIDogbnVsbCwgbGFiZWwgJiYgaXNOdW1lcmljKGxhYmVsWCkgJiYgaXNOdW1lcmljKGxhYmVsWSkgPyAoanN4KEVkZ2VUZXh0LCB7IHg6IGxhYmVsWCwgeTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cyB9KSkgOiBudWxsXSB9KSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRyb2woeyBwb3MsIHgxLCB5MSwgeDIsIHkyIH0pIHtcbiAgICBpZiAocG9zID09PSBQb3NpdGlvbi5MZWZ0IHx8IHBvcyA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFswLjUgKiAoeDEgKyB4MiksIHkxXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4MSwgMC41ICogKHkxICsgeTIpXTtcbn1cbi8qKlxuICogVGhlIGBnZXRTaW1wbGVCZXppZXJQYXRoYCB1dGlsIHJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byByZW5kZXIgYSBzaW1wbGVcbiAqIGJlemllciBlZGdlIGJldHdlZW4gdHdvIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHJldHVybnNcbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGdldFNpbXBsZUJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U2ltcGxlQmV6aWVyUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG5jb25zdCBTaW1wbGVCZXppZXJFZGdlID0gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuY29uc3QgU2ltcGxlQmV6aWVyRWRnZUludGVybmFsID0gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TaW1wbGVCZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2UnO1xuU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNtb290aFN0ZXBFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHBhdGhPcHRpb25zPy5ib3JkZXJSYWRpdXMsXG4gICAgICAgICAgICBvZmZzZXQ6IHBhdGhPcHRpb25zPy5vZmZzZXQsXG4gICAgICAgICAgICBzdGVwUG9zaXRpb246IHBhdGhPcHRpb25zPy5zdGVwUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBzbW9vdGggc3RlcCBlZGdlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBTbW9vdGhTdGVwRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxTbW9vdGhTdGVwRWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAgIHNvdXJjZVBvc2l0aW9uPXtzb3VyY2VQb3NpdGlvbn1cbiAqICAgICAgIHRhcmdldFBvc2l0aW9uPXt0YXJnZXRQb3NpdGlvbn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IFNtb290aFN0ZXBFZGdlID0gY3JlYXRlU21vb3RoU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNtb290aFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TbW9vdGhTdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTbW9vdGhTdGVwRWRnZSc7XG5TbW9vdGhTdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGVwRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIC4uLnByb3BzIH0pID0+IHtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goU21vb3RoU3RlcEVkZ2UsIHsgLi4ucHJvcHMsIGlkOiBfaWQsIHBhdGhPcHRpb25zOiB1c2VNZW1vKCgpID0+ICh7IGJvcmRlclJhZGl1czogMCwgb2Zmc2V0OiBwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0IH0pLCBbcHJvcHMucGF0aE9wdGlvbnM/Lm9mZnNldF0pIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgc3RlcCBlZGdlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBTdGVwRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSkge1xuICogICByZXR1cm4gKFxuICogICAgIDxTdGVwRWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAgIHNvdXJjZVBvc2l0aW9uPXtzb3VyY2VQb3NpdGlvbn1cbiAqICAgICAgIHRhcmdldFBvc2l0aW9uPXt0YXJnZXRQb3NpdGlvbn1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IFN0ZXBFZGdlID0gY3JlYXRlU3RlcEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0ZXBFZGdlSW50ZXJuYWwgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TdGVwRWRnZS5kaXNwbGF5TmFtZSA9ICdTdGVwRWRnZSc7XG5TdGVwRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJhaWdodEVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnNpZGUgYSBjdXN0b20gZWRnZSB0byByZW5kZXIgYSBzdHJhaWdodCBsaW5lLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBTdHJhaWdodEVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPFN0cmFpZ2h0RWRnZVxuICogICAgICAgc291cmNlWD17c291cmNlWH1cbiAqICAgICAgIHNvdXJjZVk9e3NvdXJjZVl9XG4gKiAgICAgICB0YXJnZXRYPXt0YXJnZXRYfVxuICogICAgICAgdGFyZ2V0WT17dGFyZ2V0WX1cbiAqICAgICAvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IFN0cmFpZ2h0RWRnZSA9IGNyZWF0ZVN0cmFpZ2h0RWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3RyYWlnaHRFZGdlSW50ZXJuYWwgPSBjcmVhdGVTdHJhaWdodEVkZ2UoeyBpc0ludGVybmFsOiB0cnVlIH0pO1xuU3RyYWlnaHRFZGdlLmRpc3BsYXlOYW1lID0gJ1N0cmFpZ2h0RWRnZSc7XG5TdHJhaWdodEVkZ2VJbnRlcm5hbC5kaXNwbGF5TmFtZSA9ICdTdHJhaWdodEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUJlemllckVkZ2UocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2Rpc3BsYXktbmFtZVxuICAgIHJldHVybiBtZW1vKCh7IGlkLCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIHBhdGhPcHRpb25zLCBpbnRlcmFjdGlvbldpZHRoLCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRCZXppZXJQYXRoKHtcbiAgICAgICAgICAgIHNvdXJjZVgsXG4gICAgICAgICAgICBzb3VyY2VZLFxuICAgICAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgICAgICB0YXJnZXRYLFxuICAgICAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgICAgICAgICAgY3VydmF0dXJlOiBwYXRoT3B0aW9ucz8uY3VydmF0dXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2lkID0gcGFyYW1zLmlzSW50ZXJuYWwgPyB1bmRlZmluZWQgOiBpZDtcbiAgICAgICAgcmV0dXJuIChqc3goQmFzZUVkZ2UsIHsgaWQ6IF9pZCwgcGF0aDogcGF0aCwgbGFiZWxYOiBsYWJlbFgsIGxhYmVsWTogbGFiZWxZLCBsYWJlbDogbGFiZWwsIGxhYmVsU3R5bGU6IGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnOiBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1czogbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGU6IHN0eWxlLCBtYXJrZXJFbmQ6IG1hcmtlckVuZCwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0LCBpbnRlcmFjdGlvbldpZHRoOiBpbnRlcmFjdGlvbldpZHRoIH0pKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIGEgY3VzdG9tIGVkZ2UgdG8gcmVuZGVyIGEgYmV6aWVyIGN1cnZlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBCZXppZXJFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICogZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiB9KSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEJlemllckVkZ2VcbiAqICAgICAgIHNvdXJjZVg9e3NvdXJjZVh9XG4gKiAgICAgICBzb3VyY2VZPXtzb3VyY2VZfVxuICogICAgICAgdGFyZ2V0WD17dGFyZ2V0WH1cbiAqICAgICAgIHRhcmdldFk9e3RhcmdldFl9XG4gKiAgICAgICBzb3VyY2VQb3NpdGlvbj17c291cmNlUG9zaXRpb259XG4gKiAgICAgICB0YXJnZXRQb3NpdGlvbj17dGFyZ2V0UG9zaXRpb259XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBCZXppZXJFZGdlID0gY3JlYXRlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQmV6aWVyRWRnZUludGVybmFsID0gY3JlYXRlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5CZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ0JlemllckVkZ2UnO1xuQmV6aWVyRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ0JlemllckVkZ2VJbnRlcm5hbCc7XG5cbmNvbnN0IGJ1aWx0aW5FZGdlVHlwZXMgPSB7XG4gICAgZGVmYXVsdDogQmV6aWVyRWRnZUludGVybmFsLFxuICAgIHN0cmFpZ2h0OiBTdHJhaWdodEVkZ2VJbnRlcm5hbCxcbiAgICBzdGVwOiBTdGVwRWRnZUludGVybmFsLFxuICAgIHNtb290aHN0ZXA6IFNtb290aFN0ZXBFZGdlSW50ZXJuYWwsXG4gICAgc2ltcGxlYmV6aWVyOiBTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwsXG59O1xuY29uc3QgbnVsbFBvc2l0aW9uID0ge1xuICAgIHNvdXJjZVg6IG51bGwsXG4gICAgc291cmNlWTogbnVsbCxcbiAgICB0YXJnZXRYOiBudWxsLFxuICAgIHRhcmdldFk6IG51bGwsXG4gICAgc291cmNlUG9zaXRpb246IG51bGwsXG4gICAgdGFyZ2V0UG9zaXRpb246IG51bGwsXG59O1xuXG5jb25zdCBzaGlmdFggPSAoeCwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0KVxuICAgICAgICByZXR1cm4geCAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpXG4gICAgICAgIHJldHVybiB4ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHg7XG59O1xuY29uc3Qgc2hpZnRZID0gKHksIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wKVxuICAgICAgICByZXR1cm4geSAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uQm90dG9tKVxuICAgICAgICByZXR1cm4geSArIHNoaWZ0O1xuICAgIHJldHVybiB5O1xufTtcbmNvbnN0IEVkZ2VVcGRhdGVyQ2xhc3NOYW1lID0gJ3JlYWN0LWZsb3dfX2VkZ2V1cGRhdGVyJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIEVkZ2VBbmNob3IoeyBwb3NpdGlvbiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzID0gMTAsIG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VPdXQsIHR5cGUsIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IG9uTW91c2VEb3duOiBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uTW91c2VPdXQsIGNsYXNzTmFtZTogY2MoW0VkZ2VVcGRhdGVyQ2xhc3NOYW1lLCBgJHtFZGdlVXBkYXRlckNsYXNzTmFtZX0tJHt0eXBlfWBdKSwgY3g6IHNoaWZ0WChjZW50ZXJYLCByYWRpdXMsIHBvc2l0aW9uKSwgY3k6IHNoaWZ0WShjZW50ZXJZLCByYWRpdXMsIHBvc2l0aW9uKSwgcjogcmFkaXVzLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgZmlsbDogXCJ0cmFuc3BhcmVudFwiIH0pKTtcbn1cblxuZnVuY3Rpb24gRWRnZVVwZGF0ZUFuY2hvcnMoeyBpc1JlY29ubmVjdGFibGUsIHJlY29ubmVjdFJhZGl1cywgZWRnZSwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIHNldFJlY29ubmVjdGluZywgc2V0VXBkYXRlSG92ZXIsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaGFuZGxlRWRnZVVwZGF0ZXIgPSAoZXZlbnQsIG9wcG9zaXRlSGFuZGxlKSA9PiB7XG4gICAgICAgIC8vIGF2b2lkIHRyaWdnZXJpbmcgZWRnZSB1cGRhdGVyIGlmIG1vdXNlIGJ0biBpcyBub3QgbGVmdFxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhdXRvUGFuT25Db25uZWN0LCBkb21Ob2RlLCBpc1ZhbGlkQ29ubmVjdGlvbiwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGxpYiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgY2FuY2VsQ29ubmVjdGlvbiwgbm9kZUxvb2t1cCwgcmZJZDogZmxvd0lkLCBwYW5CeSwgdXBkYXRlQ29ubmVjdGlvbiwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGlzVGFyZ2V0ID0gb3Bwb3NpdGVIYW5kbGUudHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgICAgIGNvbnN0IF9vblJlY29ubmVjdEVuZCA9IChldnQsIGNvbm5lY3Rpb25TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIG9uUmVjb25uZWN0RW5kPy4oZXZ0LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNvbm5lY3RFZGdlID0gKGNvbm5lY3Rpb24pID0+IG9uUmVjb25uZWN0Py4oZWRnZSwgY29ubmVjdGlvbik7XG4gICAgICAgIGNvbnN0IF9vbkNvbm5lY3RTdGFydCA9IChfZXZlbnQsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgc2V0UmVjb25uZWN0aW5nKHRydWUpO1xuICAgICAgICAgICAgb25SZWNvbm5lY3RTdGFydD8uKGV2ZW50LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlKTtcbiAgICAgICAgICAgIG9uQ29ubmVjdFN0YXJ0Py4oX2V2ZW50LCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICBYWUhhbmRsZS5vblBvaW50ZXJEb3duKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICBhdXRvUGFuT25Db25uZWN0LFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICBjb25uZWN0aW9uUmFkaXVzLFxuICAgICAgICAgICAgZG9tTm9kZSxcbiAgICAgICAgICAgIGhhbmRsZUlkOiBvcHBvc2l0ZUhhbmRsZS5pZCxcbiAgICAgICAgICAgIG5vZGVJZDogb3Bwb3NpdGVIYW5kbGUubm9kZUlkLFxuICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgIGlzVGFyZ2V0LFxuICAgICAgICAgICAgZWRnZVVwZGF0ZXJUeXBlOiBvcHBvc2l0ZUhhbmRsZS50eXBlLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICAgICAgZmxvd0lkLFxuICAgICAgICAgICAgY2FuY2VsQ29ubmVjdGlvbixcbiAgICAgICAgICAgIHBhbkJ5LFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEVkZ2UsXG4gICAgICAgICAgICBvbkNvbm5lY3RTdGFydDogX29uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgb25Db25uZWN0RW5kLFxuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ6IF9vblJlY29ubmVjdEVuZCxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24sXG4gICAgICAgICAgICBnZXRUcmFuc2Zvcm06ICgpID0+IHN0b3JlLmdldFN0YXRlKCkudHJhbnNmb3JtLFxuICAgICAgICAgICAgZ2V0RnJvbUhhbmRsZTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5jb25uZWN0aW9uLmZyb21IYW5kbGUsXG4gICAgICAgICAgICBkcmFnVGhyZXNob2xkOiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb25EcmFnVGhyZXNob2xkLFxuICAgICAgICAgICAgaGFuZGxlRG9tTm9kZTogZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnRhcmdldCwgaWQ6IGVkZ2UudGFyZ2V0SGFuZGxlID8/IG51bGwsIHR5cGU6ICd0YXJnZXQnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgeyBub2RlSWQ6IGVkZ2Uuc291cmNlLCBpZDogZWRnZS5zb3VyY2VIYW5kbGUgPz8gbnVsbCwgdHlwZTogJ3NvdXJjZScgfSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RNb3VzZUVudGVyID0gKCkgPT4gc2V0VXBkYXRlSG92ZXIodHJ1ZSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RNb3VzZU91dCA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKGZhbHNlKTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFsoaXNSZWNvbm5lY3RhYmxlID09PSB0cnVlIHx8IGlzUmVjb25uZWN0YWJsZSA9PT0gJ3NvdXJjZScpICYmIChqc3goRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGNlbnRlclg6IHNvdXJjZVgsIGNlbnRlclk6IHNvdXJjZVksIHJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbk1vdXNlRG93bjogb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25SZWNvbm5lY3RNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvblJlY29ubmVjdE1vdXNlT3V0LCB0eXBlOiBcInNvdXJjZVwiIH0pKSwgKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICd0YXJnZXQnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBjZW50ZXJYOiB0YXJnZXRYLCBjZW50ZXJZOiB0YXJnZXRZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJ0YXJnZXRcIiB9KSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRWRnZVdyYXBwZXIoeyBpZCwgZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvbkVycm9yLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgbGV0IGVkZ2UgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlTG9va3VwLmdldChpZCkpO1xuICAgIGNvbnN0IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHVzZVN0b3JlKChzKSA9PiBzLmRlZmF1bHRFZGdlT3B0aW9ucyk7XG4gICAgZWRnZSA9IGRlZmF1bHRFZGdlT3B0aW9ucyA/IHsgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLCAuLi5lZGdlIH0gOiBlZGdlO1xuICAgIGxldCBlZGdlVHlwZSA9IGVkZ2UudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IEVkZ2VDb21wb25lbnQgPSBlZGdlVHlwZXM/LltlZGdlVHlwZV0gfHwgYnVpbHRpbkVkZ2VUeXBlc1tlZGdlVHlwZV07XG4gICAgaWYgKEVkZ2VDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDExJ10oZWRnZVR5cGUpKTtcbiAgICAgICAgZWRnZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIEVkZ2VDb21wb25lbnQgPSBlZGdlVHlwZXM/LlsnZGVmYXVsdCddIHx8IGJ1aWx0aW5FZGdlVHlwZXMuZGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgaXNGb2N1c2FibGUgPSAhIShlZGdlLmZvY3VzYWJsZSB8fCAoZWRnZXNGb2N1c2FibGUgJiYgdHlwZW9mIGVkZ2UuZm9jdXNhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzUmVjb25uZWN0YWJsZSA9IHR5cGVvZiBvblJlY29ubmVjdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgKGVkZ2UucmVjb25uZWN0YWJsZSB8fCAoZWRnZXNSZWNvbm5lY3RhYmxlICYmIHR5cGVvZiBlZGdlLnJlY29ubmVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gISEoZWRnZS5zZWxlY3RhYmxlIHx8IChlbGVtZW50c1NlbGVjdGFibGUgJiYgdHlwZW9mIGVkZ2Uuc2VsZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBlZGdlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IFt1cGRhdGVIb3Zlciwgc2V0VXBkYXRlSG92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtyZWNvbm5lY3RpbmcsIHNldFJlY29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgekluZGV4LCBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24gfSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzdG9yZSkgPT4ge1xuICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gc3RvcmUubm9kZUxvb2t1cC5nZXQoZWRnZS5zb3VyY2UpO1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gc3RvcmUubm9kZUxvb2t1cC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICBpZiAoIXNvdXJjZU5vZGUgfHwgIXRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgekluZGV4OiBlZGdlLnpJbmRleCxcbiAgICAgICAgICAgICAgICAuLi5udWxsUG9zaXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9IGdldEVkZ2VQb3NpdGlvbih7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHNvdXJjZU5vZGUsXG4gICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgc291cmNlSGFuZGxlOiBlZGdlLnNvdXJjZUhhbmRsZSB8fCBudWxsLFxuICAgICAgICAgICAgdGFyZ2V0SGFuZGxlOiBlZGdlLnRhcmdldEhhbmRsZSB8fCBudWxsLFxuICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IHN0b3JlLmNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHpJbmRleCA9IGdldEVsZXZhdGVkRWRnZVpJbmRleCh7XG4gICAgICAgICAgICBzZWxlY3RlZDogZWRnZS5zZWxlY3RlZCxcbiAgICAgICAgICAgIHpJbmRleDogZWRnZS56SW5kZXgsXG4gICAgICAgICAgICBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgIGVsZXZhdGVPblNlbGVjdDogc3RvcmUuZWxldmF0ZUVkZ2VzT25TZWxlY3QsXG4gICAgICAgICAgICB6SW5kZXhNb2RlOiBzdG9yZS56SW5kZXhNb2RlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgIC4uLihlZGdlUG9zaXRpb24gfHwgbnVsbFBvc2l0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9LCBbZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0LCBlZGdlLnNvdXJjZUhhbmRsZSwgZWRnZS50YXJnZXRIYW5kbGUsIGVkZ2Uuc2VsZWN0ZWQsIGVkZ2UuekluZGV4XSksIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1hcmtlclN0YXJ0VXJsID0gdXNlTWVtbygoKSA9PiAoZWRnZS5tYXJrZXJTdGFydCA/IGB1cmwoJyMke2dldE1hcmtlcklkKGVkZ2UubWFya2VyU3RhcnQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlclN0YXJ0LCByZklkXSk7XG4gICAgY29uc3QgbWFya2VyRW5kVXJsID0gdXNlTWVtbygoKSA9PiAoZWRnZS5tYXJrZXJFbmQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlckVuZCwgcmZJZCl9JylgIDogdW5kZWZpbmVkKSwgW2VkZ2UubWFya2VyRW5kLCByZklkXSk7XG4gICAgaWYgKGVkZ2UuaGlkZGVuIHx8IHNvdXJjZVggPT09IG51bGwgfHwgc291cmNlWSA9PT0gbnVsbCB8fCB0YXJnZXRYID09PSBudWxsIHx8IHRhcmdldFkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9uRWRnZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWRFZGdlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbXSwgZWRnZXM6IFtlZGdlXSB9KTtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlbGVjdGVkRWRnZXMoW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIGVkZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkVkZ2VEb3VibGVDbGljayA9IG9uRG91YmxlQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uRG91YmxlQ2xpY2soZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VDb250ZXh0TWVudSA9IG9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uQ29udGV4dE1lbnUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZUVudGVyID0gb25Nb3VzZUVudGVyXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZU1vdmUgPSBvbk1vdXNlTW92ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZUxlYXZlID0gb25Nb3VzZUxlYXZlXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGVsZW1lbnRTZWxlY3Rpb25LZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgYWRkU2VsZWN0ZWRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgIGlmICh1bnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGVkZ2VSZWYuY3VycmVudD8uYmx1cigpO1xuICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHN0eWxlOiB7IHpJbmRleCB9LCBjaGlsZHJlbjoganN4cyhcImdcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICAgICAncmVhY3QtZmxvd19fZWRnZScsXG4gICAgICAgICAgICAgICAgYHJlYWN0LWZsb3dfX2VkZ2UtJHtlZGdlVHlwZX1gLFxuICAgICAgICAgICAgICAgIGVkZ2UuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkOiBlZGdlLmFuaW1hdGVkLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogIWlzU2VsZWN0YWJsZSAmJiAhb25DbGljayxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRpbmc6IHVwZGF0ZUhvdmVyLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pLCBvbkNsaWNrOiBvbkVkZ2VDbGljaywgb25Eb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgcm9sZTogZWRnZS5hcmlhUm9sZSA/PyAoaXNGb2N1c2FibGUgPyAnZ3JvdXAnIDogJ2ltZycpLCBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCI6IFwiZWRnZVwiLCBcImRhdGEtaWRcIjogaWQsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19lZGdlLSR7aWR9YCwgXCJhcmlhLWxhYmVsXCI6IGVkZ2UuYXJpYUxhYmVsID09PSBudWxsID8gdW5kZWZpbmVkIDogZWRnZS5hcmlhTGFiZWwgfHwgYEVkZ2UgZnJvbSAke2VkZ2Uuc291cmNlfSB0byAke2VkZ2UudGFyZ2V0fWAsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBpc0ZvY3VzYWJsZSA/IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAgOiB1bmRlZmluZWQsIHJlZjogZWRnZVJlZiwgLi4uZWRnZS5kb21BdHRyaWJ1dGVzLCBjaGlsZHJlbjogWyFyZWNvbm5lY3RpbmcgJiYgKGpzeChFZGdlQ29tcG9uZW50LCB7IGlkOiBpZCwgc291cmNlOiBlZGdlLnNvdXJjZSwgdGFyZ2V0OiBlZGdlLnRhcmdldCwgdHlwZTogZWRnZS50eXBlLCBzZWxlY3RlZDogZWRnZS5zZWxlY3RlZCwgYW5pbWF0ZWQ6IGVkZ2UuYW5pbWF0ZWQsIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSwgZGVsZXRhYmxlOiBlZGdlLmRlbGV0YWJsZSA/PyB0cnVlLCBsYWJlbDogZWRnZS5sYWJlbCwgbGFiZWxTdHlsZTogZWRnZS5sYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogZWRnZS5sYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlOiBlZGdlLmxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGVkZ2UubGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGVkZ2UubGFiZWxCZ0JvcmRlclJhZGl1cywgc291cmNlWDogc291cmNlWCwgc291cmNlWTogc291cmNlWSwgdGFyZ2V0WDogdGFyZ2V0WCwgdGFyZ2V0WTogdGFyZ2V0WSwgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGRhdGE6IGVkZ2UuZGF0YSwgc3R5bGU6IGVkZ2Uuc3R5bGUsIHNvdXJjZUhhbmRsZUlkOiBlZGdlLnNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlSWQ6IGVkZ2UudGFyZ2V0SGFuZGxlLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnRVcmwsIG1hcmtlckVuZDogbWFya2VyRW5kVXJsLCBwYXRoT3B0aW9uczogJ3BhdGhPcHRpb25zJyBpbiBlZGdlID8gZWRnZS5wYXRoT3B0aW9ucyA6IHVuZGVmaW5lZCwgaW50ZXJhY3Rpb25XaWR0aDogZWRnZS5pbnRlcmFjdGlvbldpZHRoIH0pKSwgaXNSZWNvbm5lY3RhYmxlICYmIChqc3goRWRnZVVwZGF0ZUFuY2hvcnMsIHsgZWRnZTogZWRnZSwgaXNSZWNvbm5lY3RhYmxlOiBpc1JlY29ubmVjdGFibGUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQ6IG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kOiBvblJlY29ubmVjdEVuZCwgc291cmNlWDogc291cmNlWCwgc291cmNlWTogc291cmNlWSwgdGFyZ2V0WDogdGFyZ2V0WCwgdGFyZ2V0WTogdGFyZ2V0WSwgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIHNldFVwZGF0ZUhvdmVyOiBzZXRVcGRhdGVIb3Zlciwgc2V0UmVjb25uZWN0aW5nOiBzZXRSZWNvbm5lY3RpbmcgfSkpXSB9KSB9KSk7XG59XG52YXIgRWRnZVdyYXBwZXIkMSA9IG1lbW8oRWRnZVdyYXBwZXIpO1xuXG5jb25zdCBzZWxlY3RvciRhID0gKHMpID0+ICh7XG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNSZWNvbm5lY3RhYmxlOiBzLmVkZ2VzUmVjb25uZWN0YWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gRWRnZVJlbmRlcmVyQ29tcG9uZW50KHsgZGVmYXVsdE1hcmtlckNvbG9yLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1cywgb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3QgeyBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXNcIiwgY2hpbGRyZW46IFtqc3goTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSwgZWRnZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRWRnZVdyYXBwZXIkMSwgeyBpZDogaWQsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlOiBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25Db250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25Nb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCBvbkNsaWNrOiBvbkVkZ2VDbGljaywgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIG9uRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIHJmSWQ6IHJmSWQsIG9uRXJyb3I6IG9uRXJyb3IsIGVkZ2VUeXBlczogZWRnZVR5cGVzLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0sIGlkKSk7XG4gICAgICAgICAgICB9KV0gfSkpO1xufVxuRWRnZVJlbmRlcmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0VkZ2VSZW5kZXJlcic7XG5jb25zdCBFZGdlUmVuZGVyZXIgPSBtZW1vKEVkZ2VSZW5kZXJlckNvbXBvbmVudCk7XG5cbmNvbnN0IHNlbGVjdG9yJDkgPSAocykgPT4gYHRyYW5zbGF0ZSgke3MudHJhbnNmb3JtWzBdfXB4LCR7cy50cmFuc2Zvcm1bMV19cHgpIHNjYWxlKCR7cy50cmFuc2Zvcm1bMl19KWA7XG5mdW5jdGlvbiBWaWV3cG9ydCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB1c2VTdG9yZShzZWxlY3RvciQ5KTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X192aWV3cG9ydCB4eWZsb3dfX3ZpZXdwb3J0IHJlYWN0LWZsb3dfX2NvbnRhaW5lclwiLCBzdHlsZTogeyB0cmFuc2Zvcm0gfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBjYWxsaW5nIG9uSW5pdCBoYW5kbGVyLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCkge1xuICAgIGNvbnN0IHJmSW5zdGFuY2UgPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBpc0luaXRpYWxpemVkID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWlzSW5pdGlhbGl6ZWQuY3VycmVudCAmJiByZkluc3RhbmNlLnZpZXdwb3J0SW5pdGlhbGl6ZWQgJiYgb25Jbml0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG9uSW5pdChyZkluc3RhbmNlKSwgMSk7XG4gICAgICAgICAgICBpc0luaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW29uSW5pdCwgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkXSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDggPSAoc3RhdGUpID0+IHN0YXRlLnBhblpvb20/LnN5bmNWaWV3cG9ydDtcbi8qKlxuICogSG9vayBmb3Igc3luY2luZyB0aGUgdmlld3BvcnQgd2l0aCB0aGUgcGFuem9vbSBpbnN0YW5jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB2aWV3cG9ydFxuICovXG5mdW5jdGlvbiB1c2VWaWV3cG9ydFN5bmModmlld3BvcnQpIHtcbiAgICBjb25zdCBzeW5jVmlld3BvcnQgPSB1c2VTdG9yZShzZWxlY3RvciQ4KTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBzeW5jVmlld3BvcnQ/Lih2aWV3cG9ydCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHRyYW5zZm9ybTogW3ZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0Lnpvb21dIH0pO1xuICAgICAgICB9XG4gICAgfSwgW3ZpZXdwb3J0LCBzeW5jVmlld3BvcnRdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc3RvcmVTZWxlY3RvciQxKHMpIHtcbiAgICByZXR1cm4gcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3NcbiAgICAgICAgPyB7IC4uLnMuY29ubmVjdGlvbiwgdG86IHBvaW50VG9SZW5kZXJlclBvaW50KHMuY29ubmVjdGlvbi50bywgcy50cmFuc2Zvcm0pIH1cbiAgICAgICAgOiB7IC4uLnMuY29ubmVjdGlvbiB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IoY29ubmVjdGlvblNlbGVjdG9yKSB7XG4gICAgaWYgKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBjb21iaW5lZFNlbGVjdG9yID0gKHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBzdG9yZVNlbGVjdG9yJDEocyk7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvblNlbGVjdG9yKGNvbm5lY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29tYmluZWRTZWxlY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlU2VsZWN0b3IkMTtcbn1cbi8qKlxuICogVGhlIGB1c2VDb25uZWN0aW9uYCBob29rIHJldHVybnMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB3aGVuIHRoZXJlIGlzIGFuIGFjdGl2ZVxuICogY29ubmVjdGlvbiBpbnRlcmFjdGlvbi4gSWYgbm8gY29ubmVjdGlvbiBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIGl0IHJldHVybnMgbnVsbFxuICogZm9yIGV2ZXJ5IHByb3BlcnR5LiBBIHR5cGljYWwgdXNlIGNhc2UgZm9yIHRoaXMgaG9vayBpcyB0byBjb2xvcml6ZSBoYW5kbGVzXG4gKiBiYXNlZCBvbiBhIGNlcnRhaW4gY29uZGl0aW9uIChlLmcuIGlmIHRoZSBjb25uZWN0aW9uIGlzIHZhbGlkIG9yIG5vdCkuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNvbm5lY3Rpb25TZWxlY3RvciAtIEFuIG9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gZXh0cmFjdCBhIHNsaWNlIG9mIHRoZVxuICogYENvbm5lY3Rpb25TdGF0ZWAgZGF0YS4gVXNpbmcgYSBzZWxlY3RvciBjYW4gcHJldmVudCBjb21wb25lbnQgcmUtcmVuZGVycyB3aGVyZSBkYXRhIHlvdSBkb24ndFxuICogb3RoZXJ3aXNlIGNhcmUgYWJvdXQgbWlnaHQgY2hhbmdlLiBJZiBhIHNlbGVjdG9yIGlzIG5vdCBwcm92aWRlZCwgdGhlIGVudGlyZSBgQ29ubmVjdGlvblN0YXRlYFxuICogb2JqZWN0IGlzIHJldHVybmVkIHVuY2hhbmdlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUNvbm5lY3Rpb24gfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIEFwcCgpIHtcbiAqICBjb25zdCBjb25uZWN0aW9uID0gdXNlQ29ubmVjdGlvbigpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj4ge2Nvbm5lY3Rpb24gPyBgU29tZW9uZSBpcyB0cnlpbmcgdG8gbWFrZSBhIGNvbm5lY3Rpb24gZnJvbSAke2Nvbm5lY3Rpb24uZnJvbU5vZGV9IHRvIHRoaXMgb25lLmAgOiAnVGhlcmUgYXJlIGN1cnJlbnRseSBubyBpbmNvbWluZyBjb25uZWN0aW9ucyEnfVxuICpcbiAqICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBDb25uZWN0aW9uU3RhdGVcbiAqL1xuZnVuY3Rpb24gdXNlQ29ubmVjdGlvbihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBjb25zdCBjb21iaW5lZFNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoY29ubmVjdGlvblNlbGVjdG9yKTtcbiAgICByZXR1cm4gdXNlU3RvcmUoY29tYmluZWRTZWxlY3Rvciwgc2hhbGxvdyk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDcgPSAocykgPT4gKHtcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgaXNWYWxpZDogcy5jb25uZWN0aW9uLmlzVmFsaWQsXG4gICAgaW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgd2lkdGg6IHMud2lkdGgsXG4gICAgaGVpZ2h0OiBzLmhlaWdodCxcbn0pO1xuZnVuY3Rpb24gQ29ubmVjdGlvbkxpbmVXcmFwcGVyKHsgY29udGFpbmVyU3R5bGUsIHN0eWxlLCB0eXBlLCBjb21wb25lbnQsIH0pIHtcbiAgICBjb25zdCB7IG5vZGVzQ29ubmVjdGFibGUsIHdpZHRoLCBoZWlnaHQsIGlzVmFsaWQsIGluUHJvZ3Jlc3MgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHJlbmRlckNvbm5lY3Rpb24gPSAhISh3aWR0aCAmJiBub2Rlc0Nvbm5lY3RhYmxlICYmIGluUHJvZ3Jlc3MpO1xuICAgIGlmICghcmVuZGVyQ29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogY29udGFpbmVyU3R5bGUsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9ubGluZSByZWFjdC1mbG93X19jb250YWluZXJcIiwgY2hpbGRyZW46IGpzeChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29ubmVjdGlvbicsIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCldKSwgY2hpbGRyZW46IGpzeChDb25uZWN0aW9uTGluZSwgeyBzdHlsZTogc3R5bGUsIHR5cGU6IHR5cGUsIEN1c3RvbUNvbXBvbmVudDogY29tcG9uZW50LCBpc1ZhbGlkOiBpc1ZhbGlkIH0pIH0pIH0pKTtcbn1cbmNvbnN0IENvbm5lY3Rpb25MaW5lID0gKHsgc3R5bGUsIHR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBDdXN0b21Db21wb25lbnQsIGlzVmFsaWQsIH0pID0+IHtcbiAgICBjb25zdCB7IGluUHJvZ3Jlc3MsIGZyb20sIGZyb21Ob2RlLCBmcm9tSGFuZGxlLCBmcm9tUG9zaXRpb24sIHRvLCB0b05vZGUsIHRvSGFuZGxlLCB0b1Bvc2l0aW9uLCBwb2ludGVyIH0gPSB1c2VDb25uZWN0aW9uKCk7XG4gICAgaWYgKCFpblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEN1c3RvbUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKGpzeChDdXN0b21Db21wb25lbnQsIHsgY29ubmVjdGlvbkxpbmVUeXBlOiB0eXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBzdHlsZSwgZnJvbU5vZGU6IGZyb21Ob2RlLCBmcm9tSGFuZGxlOiBmcm9tSGFuZGxlLCBmcm9tWDogZnJvbS54LCBmcm9tWTogZnJvbS55LCB0b1g6IHRvLngsIHRvWTogdG8ueSwgZnJvbVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sIHRvUG9zaXRpb246IHRvUG9zaXRpb24sIGNvbm5lY3Rpb25TdGF0dXM6IGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCksIHRvTm9kZTogdG9Ob2RlLCB0b0hhbmRsZTogdG9IYW5kbGUsIHBvaW50ZXI6IHBvaW50ZXIgfSkpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGNvbnN0IHBhdGhQYXJhbXMgPSB7XG4gICAgICAgIHNvdXJjZVg6IGZyb20ueCxcbiAgICAgICAgc291cmNlWTogZnJvbS55LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbjogZnJvbVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRYOiB0by54LFxuICAgICAgICB0YXJnZXRZOiB0by55LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbjogdG9Qb3NpdGlvbixcbiAgICB9O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXI6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlNpbXBsZUJlemllcjpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNpbXBsZUJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU3RlcDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgICAgICAuLi5wYXRoUGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlNtb290aFN0ZXA6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTbW9vdGhTdGVwUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U3RyYWlnaHRQYXRoKHBhdGhQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4ganN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbi1wYXRoXCIsIHN0eWxlOiBzdHlsZSB9KTtcbn07XG5Db25uZWN0aW9uTGluZS5kaXNwbGF5TmFtZSA9ICdDb25uZWN0aW9uTGluZSc7XG5cbmNvbnN0IGVtcHR5VHlwZXMgPSB7fTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKG5vZGVPckVkZ2VUeXBlcyA9IGVtcHR5VHlwZXMpIHtcbiAgICBjb25zdCB0eXBlc1JlZiA9IHVzZVJlZihub2RlT3JFZGdlVHlwZXMpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZWRLZXlzID0gbmV3IFNldChbLi4uT2JqZWN0LmtleXModHlwZXNSZWYuY3VycmVudCksIC4uLk9iamVjdC5rZXlzKG5vZGVPckVkZ2VUeXBlcyldKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVzZWRLZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVzUmVmLmN1cnJlbnRba2V5XSAhPT0gbm9kZU9yRWRnZVR5cGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAyJ10oKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzUmVmLmN1cnJlbnQgPSBub2RlT3JFZGdlVHlwZXM7XG4gICAgICAgIH1cbiAgICB9LCBbbm9kZU9yRWRnZVR5cGVzXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN0eWxlc0xvYWRlZFdhcm5pbmcoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGNoZWNrZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgaWYgKCFjaGVja2VkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3BhbmUnKTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZSAmJiAhKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhbmUpLnpJbmRleCA9PT0gJzEnKSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEzJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTMnXSgncmVhY3QnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIEdyYXBoVmlld0NvbXBvbmVudCh7IG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbkluaXQsIG9uTm9kZUNsaWNrLCBvbkVkZ2VDbGljaywgb25Ob2RlRG91YmxlQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51LCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGRlbGV0ZUtleUNvZGUsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIGRlZmF1bHRNYXJrZXJDb2xvciwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZywgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2UsIG5vZGVDbGlja0Rpc3RhbmNlLCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudCwgcmZJZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIH0pIHtcbiAgICB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKG5vZGVUeXBlcyk7XG4gICAgdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhlZGdlVHlwZXMpO1xuICAgIHVzZVN0eWxlc0xvYWRlZFdhcm5pbmcoKTtcbiAgICB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCk7XG4gICAgdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KTtcbiAgICByZXR1cm4gKGpzeChGbG93UmVuZGVyZXIsIHsgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlOiBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWc6IHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSwgb25TZWxlY3Rpb25TdGFydDogb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQ6IG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgb25WaWV3cG9ydENoYW5nZTogb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQ6ICEhdmlld3BvcnQsIGNoaWxkcmVuOiBqc3hzKFZpZXdwb3J0LCB7IGNoaWxkcmVuOiBbanN4KEVkZ2VSZW5kZXJlciwgeyBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgZGVmYXVsdE1hcmtlckNvbG9yOiBkZWZhdWx0TWFya2VyQ29sb3IsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZDogcmZJZCB9KSwganN4KENvbm5lY3Rpb25MaW5lV3JhcHBlciwgeyBzdHlsZTogY29ubmVjdGlvbkxpbmVTdHlsZSwgdHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb21wb25lbnQ6IGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlclwiIH0pLCBqc3goTm9kZVJlbmRlcmVyLCB7IG5vZGVUeXBlczogbm9kZVR5cGVzLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrOiBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgbm9kZUNsaWNrRGlzdGFuY2U6IG5vZGVDbGlja0Rpc3RhbmNlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCByZklkOiByZklkIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQtcG9ydGFsXCIgfSldIH0pIH0pKTtcbn1cbkdyYXBoVmlld0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdHcmFwaFZpZXcnO1xuY29uc3QgR3JhcGhWaWV3ID0gbWVtbyhHcmFwaFZpZXdDb21wb25lbnQpO1xuXG5jb25zdCBnZXRJbml0aWFsU3RhdGUgPSAoeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSA9IDAuNSwgbWF4Wm9vbSA9IDIsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHpJbmRleE1vZGUgPSAnYmFzaWMnLCB9ID0ge30pID0+IHtcbiAgICBjb25zdCBub2RlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhcmVudExvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVkZ2VMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3RvcmVFZGdlcyA9IGRlZmF1bHRFZGdlcyA/PyBlZGdlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVzID0gZGVmYXVsdE5vZGVzID8/IG5vZGVzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZU9yaWdpbiA9IG5vZGVPcmlnaW4gPz8gWzAsIDBdO1xuICAgIGNvbnN0IHN0b3JlTm9kZUV4dGVudCA9IG5vZGVFeHRlbnQgPz8gaW5maW5pdGVFeHRlbnQ7XG4gICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBzdG9yZUVkZ2VzKTtcbiAgICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gYWRvcHRVc2VyTm9kZXMoc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbixcbiAgICAgICAgbm9kZUV4dGVudDogc3RvcmVOb2RlRXh0ZW50LFxuICAgICAgICB6SW5kZXhNb2RlLFxuICAgIH0pO1xuICAgIGxldCB0cmFuc2Zvcm0gPSBbMCwgMCwgMV07XG4gICAgaWYgKGZpdFZpZXcgJiYgd2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZUxvb2t1cCwge1xuICAgICAgICAgICAgZmlsdGVyOiAobm9kZSkgPT4gISEoKG5vZGUud2lkdGggfHwgbm9kZS5pbml0aWFsV2lkdGgpICYmIChub2RlLmhlaWdodCB8fCBub2RlLmluaXRpYWxIZWlnaHQpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBmaXRWaWV3T3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICB0cmFuc2Zvcm0gPSBbeCwgeSwgem9vbV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJmSWQ6ICcxJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoID8/IDAsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ID8/IDAsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgbm9kZXM6IHN0b3JlTm9kZXMsXG4gICAgICAgIG5vZGVzSW5pdGlhbGl6ZWQsXG4gICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIHBhcmVudExvb2t1cCxcbiAgICAgICAgZWRnZXM6IHN0b3JlRWRnZXMsXG4gICAgICAgIGVkZ2VMb29rdXAsXG4gICAgICAgIGNvbm5lY3Rpb25Mb29rdXAsXG4gICAgICAgIG9uTm9kZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIG9uRWRnZXNDaGFuZ2U6IG51bGwsXG4gICAgICAgIGhhc0RlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIGhhc0RlZmF1bHRFZGdlczogZGVmYXVsdEVkZ2VzICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHBhblpvb206IG51bGwsXG4gICAgICAgIG1pblpvb20sXG4gICAgICAgIG1heFpvb20sXG4gICAgICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgICAgIG5vZGVFeHRlbnQ6IHN0b3JlTm9kZUV4dGVudCxcbiAgICAgICAgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG51bGwsXG4gICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBDb25uZWN0aW9uTW9kZS5TdHJpY3QsXG4gICAgICAgIGRvbU5vZGU6IG51bGwsXG4gICAgICAgIHBhbmVEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgICAgICBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVEcmFnVGhyZXNob2xkOiAxLFxuICAgICAgICBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZDogMSxcbiAgICAgICAgc25hcEdyaWQ6IFsxNSwgMTVdLFxuICAgICAgICBzbmFwVG9HcmlkOiBmYWxzZSxcbiAgICAgICAgbm9kZXNEcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIG5vZGVzQ29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIG5vZGVzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgZWRnZXNSZWNvbm5lY3RhYmxlOiB0cnVlLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiB0cnVlLFxuICAgICAgICBlbGV2YXRlRWRnZXNPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgc2VsZWN0Tm9kZXNPbkRyYWc6IHRydWUsXG4gICAgICAgIG11bHRpU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZml0Vmlld1F1ZXVlZDogZml0VmlldyA/PyBmYWxzZSxcbiAgICAgICAgZml0Vmlld09wdGlvbnMsXG4gICAgICAgIGZpdFZpZXdSZXNvbHZlcjogbnVsbCxcbiAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZTogbnVsbCxcbiAgICAgICAgY29ubmVjdE9uQ2xpY2s6IHRydWUsXG4gICAgICAgIGFyaWFMaXZlTWVzc2FnZTogJycsXG4gICAgICAgIGF1dG9QYW5PbkNvbm5lY3Q6IHRydWUsXG4gICAgICAgIGF1dG9QYW5Pbk5vZGVEcmFnOiB0cnVlLFxuICAgICAgICBhdXRvUGFuT25Ob2RlRm9jdXM6IHRydWUsXG4gICAgICAgIGF1dG9QYW5TcGVlZDogMTUsXG4gICAgICAgIGNvbm5lY3Rpb25SYWRpdXM6IDIwLFxuICAgICAgICBvbkVycm9yOiBkZXZXYXJuLFxuICAgICAgICBpc1ZhbGlkQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzOiBbXSxcbiAgICAgICAgbGliOiAncmVhY3QnLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGFyaWFMYWJlbENvbmZpZzogZGVmYXVsdEFyaWFMYWJlbENvbmZpZyxcbiAgICAgICAgekluZGV4TW9kZSxcbiAgICAgICAgb25Ob2Rlc0NoYW5nZU1pZGRsZXdhcmVNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgb25FZGdlc0NoYW5nZU1pZGRsZXdhcmVNYXA6IG5ldyBNYXAoKSxcbiAgICB9O1xufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgekluZGV4TW9kZSwgfSkgPT4gY3JlYXRlV2l0aEVxdWFsaXR5Rm4oKHNldCwgZ2V0KSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUZpdFZpZXcoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgcGFuWm9vbSwgZml0Vmlld09wdGlvbnMsIGZpdFZpZXdSZXNvbHZlciwgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGZpdFZpZXdwb3J0KHtcbiAgICAgICAgICAgIG5vZGVzOiBub2RlTG9va3VwLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgIH0sIGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgZml0Vmlld1Jlc29sdmVyPy5yZXNvbHZlKHRydWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogd2FpdCBmb3IgdGhlIGZpdFZpZXdwb3J0IHRvIHJlc29sdmUgYmVmb3JlIGRlbGV0aW5nIHRoZSByZXNvbHZlcixcbiAgICAgICAgICogd2Ugd2FudCB0byByZXVzZSB0aGUgb2xkIHJlc29sdmVyIGlmIHRoZSB1c2VyIGNhbGxzIGZpdFZpZXcgYWdhaW4gaW4gdGhlIG1lYW4gdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KHsgZml0Vmlld1Jlc29sdmVyOiBudWxsIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nZXRJbml0aWFsU3RhdGUoe1xuICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgZml0VmlldyxcbiAgICAgICAgICAgIGZpdFZpZXdPcHRpb25zLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgbm9kZUV4dGVudCxcbiAgICAgICAgICAgIGRlZmF1bHROb2RlcyxcbiAgICAgICAgICAgIGRlZmF1bHRFZGdlcyxcbiAgICAgICAgICAgIHpJbmRleE1vZGUsXG4gICAgICAgIH0pLFxuICAgICAgICBzZXROb2RlczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QsIGZpdFZpZXdRdWV1ZWQsIHpJbmRleE1vZGUgfSA9IGdldCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHNldE5vZGVzKCkgaXMgY2FsbGVkIGV4Y2x1c2l2ZWx5IGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9uczpcbiAgICAgICAgICAgICAqIC0gZWl0aGVyIHdoZW4gdGhlIGA8UmVhY3RGbG93IG5vZGVzPmAgcHJvcCBpcyB1cGRhdGVkIGluIHRoZSBjb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cCxcbiAgICAgICAgICAgICAqIC0gb3Igd2hlbiB0aGUgdXNlciBjYWxscyBzb21ldGhpbmcgbGlrZSBgcmVhY3RGbG93SW5zdGFuY2Uuc2V0Tm9kZXMoKWAgaW4gYW4gdW5jb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgd2UgdGFrZSB0aGUgbm90ZSBvYmplY3RzIHBhc3NlZCBieSB0aGUgdXNlciBhbmQgZXh0ZW5kIHRoZW0gd2l0aCBmaWVsZHNcbiAgICAgICAgICAgICAqIHJlbGV2YW50IGZvciBpbnRlcm5hbCBSZWFjdCBGbG93IG9wZXJhdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzSW5pdGlhbGl6ZWQgPSBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7XG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgekluZGV4TW9kZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQgJiYgbm9kZXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVGaXRWaWV3KCk7XG4gICAgICAgICAgICAgICAgc2V0KHsgbm9kZXMsIG5vZGVzSW5pdGlhbGl6ZWQsIGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0KHsgbm9kZXMsIG5vZGVzSW5pdGlhbGl6ZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEVkZ2VzOiAoZWRnZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uTG9va3VwKGNvbm5lY3Rpb25Mb29rdXAsIGVkZ2VMb29rdXAsIGVkZ2VzKTtcbiAgICAgICAgICAgIHNldCh7IGVkZ2VzIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXREZWZhdWx0Tm9kZXNBbmRFZGdlczogKG5vZGVzLCBlZGdlcykgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2V0Tm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgICAgIHNldCh7IGhhc0RlZmF1bHROb2RlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlZGdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2V0RWRnZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgICAgIHNldEVkZ2VzKGVkZ2VzKTtcbiAgICAgICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0RWRnZXM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qXG4gICAgICAgICAqIEV2ZXJ5IG5vZGUgZ2V0cyByZWdpc3RlcmQgYXQgYSBSZXNpemVPYnNlcnZlci4gV2hlbmV2ZXIgYSBub2RlXG4gICAgICAgICAqIGNoYW5nZXMgaXRzIGRpbWVuc2lvbnMsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIG1lYXN1cmUgdGhlXG4gICAgICAgICAqIG5ldyBkaW1lbnNpb25zIGFuZCB1cGRhdGUgdGhlIG5vZGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlTm9kZUludGVybmFsczogKHVwZGF0ZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIGRlYnVnLCBmaXRWaWV3UXVldWVkLCB6SW5kZXhNb2RlLCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBjb25zdCB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfSA9IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB6SW5kZXhNb2RlKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZEludGVybmFscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB6SW5kZXhNb2RlIH0pO1xuICAgICAgICAgICAgaWYgKGZpdFZpZXdRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRml0VmlldygpO1xuICAgICAgICAgICAgICAgIHNldCh7IGZpdFZpZXdRdWV1ZWQ6IGZhbHNlLCBmaXRWaWV3T3B0aW9uczogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gdHJpZ2dlciB1c2VTdG9yZSBjYWxscyB3aGVuZXZlciB1cGRhdGVOb2RlSW50ZXJuYWxzIGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgIHNldCh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnM6IChub2RlRHJhZ0l0ZW1zLCBkcmFnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCBjb25uZWN0aW9uLCB1cGRhdGVDb25uZWN0aW9uLCBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcCB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIG5vZGVEcmFnSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlIG5vZGVsb29rdXAgdG8gYmUgc3VyZSB0byB1c2UgdGhlIGN1cnJlbnQgZXhwYW5kUGFyZW50IGFuZCBwYXJlbnRJZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kUGFyZW50ID0gISEobm9kZT8uZXhwYW5kUGFyZW50ICYmIG5vZGU/LnBhcmVudElkICYmIGRyYWdJdGVtPy5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGV4cGFuZFBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5tYXgoMCwgZHJhZ0l0ZW0ucG9zaXRpb24ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5tYXgoMCwgZHJhZ0l0ZW0ucG9zaXRpb24ueSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRyYWdJdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIGNvbm5lY3Rpb24uaW5Qcm9ncmVzcyAmJiBjb25uZWN0aW9uLmZyb21Ob2RlLmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGcm9tID0gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgY29ubmVjdGlvbi5mcm9tSGFuZGxlLCBQb3NpdGlvbi5MZWZ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbih7IC4uLmNvbm5lY3Rpb24sIGZyb206IHVwZGF0ZWRGcm9tIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBkcmFnSXRlbS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBtaWRkbGV3YXJlKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uTm9kZXNDaGFuZ2UsIHNldE5vZGVzLCBub2RlcywgaGFzRGVmYXVsdE5vZGVzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkTm9kZXMgPSBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Tm9kZXModXBkYXRlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWFjdCBGbG93OiB0cmlnZ2VyIG5vZGUgY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbk5vZGVzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlczogKGNoYW5nZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25FZGdlc0NoYW5nZSwgc2V0RWRnZXMsIGVkZ2VzLCBoYXNEZWZhdWx0RWRnZXMsIGRlYnVnIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRFZGdlcyA9IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFZGdlcyh1cGRhdGVkRWRnZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgZWRnZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlczogKHNlbGVjdGVkTm9kZUlkcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgZWRnZUxvb2t1cCwgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgaWYgKG11bHRpU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBzZWxlY3RlZE5vZGVJZHMubWFwKChub2RlSWQpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShub2RlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkTm9kZUlkc10pLCB0cnVlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlbGVjdGVkRWRnZXM6IChzZWxlY3RlZEVkZ2VJZHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIGVkZ2VMb29rdXAsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRFZGdlcyA9IHNlbGVjdGVkRWRnZUlkcy5tYXAoKGVkZ2VJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhjaGFuZ2VkRWRnZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkRWRnZUlkc10pKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBuZXcgU2V0KCksIHRydWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzOiAoeyBub2RlcywgZWRnZXMgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVkZ2VzOiBzdG9yZUVkZ2VzLCBub2Rlczogc3RvcmVOb2Rlcywgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNUb1Vuc2VsZWN0ID0gbm9kZXMgPyBub2RlcyA6IHN0b3JlTm9kZXM7XG4gICAgICAgICAgICBjb25zdCBlZGdlc1RvVW5zZWxlY3QgPSBlZGdlcyA/IGVkZ2VzIDogc3RvcmVFZGdlcztcbiAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbm9kZXNUb1Vuc2VsZWN0Lm1hcCgobikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogd2UgbmVlZCB0byB1bnNlbGVjdCB0aGUgaW50ZXJuYWwgbm9kZSB0aGF0IHdhcyBzZWxlY3RlZCBwcmV2aW91c2x5IGJlZm9yZSB3ZVxuICAgICAgICAgICAgICAgICAgICAgKiBzZW5kIHRoZSBjaGFuZ2UgdG8gdGhlIHVzZXIgdG8gcHJldmVudCBpdCB0byBiZSBzZWxlY3RlZCB3aGlsZSBkcmFnZ2luZyB0aGUgbmV3IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsTm9kZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG4uaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZWRnZUNoYW5nZXMgPSBlZGdlc1RvVW5zZWxlY3QubWFwKChlZGdlKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoZWRnZS5pZCwgZmFsc2UpKTtcbiAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRNaW5ab29tOiAobWluWm9vbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtYXhab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHBhblpvb20/LnNldFNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSk7XG4gICAgICAgICAgICBzZXQoeyBtaW5ab29tIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRNYXhab29tOiAobWF4Wm9vbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtaW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHBhblpvb20/LnNldFNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSk7XG4gICAgICAgICAgICBzZXQoeyBtYXhab29tIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6ICh0cmFuc2xhdGVFeHRlbnQpID0+IHtcbiAgICAgICAgICAgIGdldCgpLnBhblpvb20/LnNldFRyYW5zbGF0ZUV4dGVudCh0cmFuc2xhdGVFeHRlbnQpO1xuICAgICAgICAgICAgc2V0KHsgdHJhbnNsYXRlRXh0ZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgZWxlbWVudHNTZWxlY3RhYmxlIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudHNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBub2Rlcy5yZWR1Y2UoKHJlcywgbm9kZSkgPT4gKG5vZGUuc2VsZWN0ZWQgPyBbLi4ucmVzLCBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZS5pZCwgZmFsc2UpXSA6IHJlcyksIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXMucmVkdWNlKChyZXMsIGVkZ2UpID0+IChlZGdlLnNlbGVjdGVkID8gWy4uLnJlcywgY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKV0gOiByZXMpLCBbXSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Tm9kZUV4dGVudDogKG5leHROb2RlRXh0ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4sIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlRXh0ZW50LCB6SW5kZXhNb2RlIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZUV4dGVudFswXVswXSA9PT0gbm9kZUV4dGVudFswXVswXSAmJlxuICAgICAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzBdWzFdID09PSBub2RlRXh0ZW50WzBdWzFdICYmXG4gICAgICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMV1bMF0gPT09IG5vZGVFeHRlbnRbMV1bMF0gJiZcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVsxXSA9PT0gbm9kZUV4dGVudFsxXVsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgICAgIGNoZWNrRXF1YWxpdHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHpJbmRleE1vZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldCh7IG5vZGVFeHRlbnQ6IG5leHROb2RlRXh0ZW50IH0pO1xuICAgICAgICB9LFxuICAgICAgICBwYW5CeTogKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgdHJhbnNsYXRlRXh0ZW50IH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBwYW5CeSh7IGRlbHRhLCBwYW5ab29tLCB0cmFuc2Zvcm0sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2VudGVyOiBhc3luYyAoeCwgeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBtYXhab29tLCBwYW5ab29tIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV4dFpvb20gPSB0eXBlb2Ygb3B0aW9ucz8uem9vbSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnpvb20gOiBtYXhab29tO1xuICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh7XG4gICAgICAgICAgICAgICAgeDogd2lkdGggLyAyIC0geCAqIG5leHRab29tLFxuICAgICAgICAgICAgICAgIHk6IGhlaWdodCAvIDIgLSB5ICogbmV4dFpvb20sXG4gICAgICAgICAgICAgICAgem9vbTogbmV4dFpvb20sXG4gICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiwgZWFzZTogb3B0aW9ucz8uZWFzZSwgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiB7IC4uLmluaXRpYWxDb25uZWN0aW9uIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbjogKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHNldCh7IGNvbm5lY3Rpb24gfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiAoKSA9PiBzZXQoeyAuLi5nZXRJbml0aWFsU3RhdGUoKSB9KSxcbiAgICB9O1xufSwgT2JqZWN0LmlzKTtcblxuLyoqXG4gKiBUaGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IGlzIGEgW2NvbnRleHQgcHJvdmlkZXJdKGh0dHBzOi8vcmVhY3QuZGV2L2xlYXJuL3Bhc3NpbmctZGF0YS1kZWVwbHktd2l0aC1jb250ZXh0IylcbiAqIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gYWNjZXNzIGEgZmxvdydzIGludGVybmFsIHN0YXRlIG91dHNpZGUgb2YgdGhlXG4gKiBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93KSBjb21wb25lbnQuIE1hbnkgb2YgdGhlIGhvb2tzIHdlXG4gKiBwcm92aWRlIHJlbHkgb24gdGhpcyBjb21wb25lbnQgdG8gd29yay5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dQcm92aWRlcj5cbiAqICAgICAgPFJlYWN0RmxvdyBub2Rlcz17Li4ufSBlZGdlcz17Li4ufSAvPlxuICogICAgICA8U2lkZWJhciAvPlxuICogICAgPC9SZWFjdEZsb3dQcm92aWRlcj5cbiAqICApO1xuICp9XG4gKlxuICpmdW5jdGlvbiBTaWRlYmFyKCkge1xuICogIC8vIFRoaXMgaG9vayB3aWxsIG9ubHkgd29yayBpZiB0aGUgY29tcG9uZW50IGl0J3MgdXNlZCBpbiBpcyBhIGNoaWxkIG9mIGFcbiAqICAvLyA8UmVhY3RGbG93UHJvdmlkZXIgLz4uXG4gKiAgY29uc3Qgbm9kZXMgPSB1c2VOb2RlcygpXG4gKlxuICogIHJldHVybiA8YXNpZGU+ZG8gc29tZXRoaW5nIHdpdGggbm9kZXM8L2FzaWRlPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UncmUgdXNpbmcgYSByb3V0ZXIgYW5kIHdhbnQgeW91ciBmbG93J3Mgc3RhdGUgdG8gcGVyc2lzdCBhY3Jvc3Mgcm91dGVzLFxuICogaXQncyB2aXRhbCB0aGF0IHlvdSBwbGFjZSB0aGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IF9vdXRzaWRlXyBvZlxuICogeW91ciByb3V0ZXIuIElmIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIHRoZSBzYW1lIHBhZ2UgeW91IHdpbGwgbmVlZCB0byB1c2UgYSBzZXBhcmF0ZVxuICogYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgZm9yIGVhY2ggZmxvdy5cbiAqL1xuZnVuY3Rpb24gUmVhY3RGbG93UHJvdmlkZXIoeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBpbml0aWFsTWluWm9vbTogbWluWm9vbSwgaW5pdGlhbE1heFpvb206IG1heFpvb20sIGluaXRpYWxGaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIGZpdFZpZXcsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHpJbmRleE1vZGUsIGNoaWxkcmVuLCB9KSB7XG4gICAgY29uc3QgW3N0b3JlXSA9IHVzZVN0YXRlKCgpID0+IGNyZWF0ZVN0b3JlKHtcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIGVkZ2VzLFxuICAgICAgICBkZWZhdWx0Tm9kZXMsXG4gICAgICAgIGRlZmF1bHRFZGdlcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZml0VmlldyxcbiAgICAgICAgbWluWm9vbSxcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgZml0Vmlld09wdGlvbnMsXG4gICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgIHpJbmRleE1vZGUsXG4gICAgfSkpO1xuICAgIHJldHVybiAoanN4KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlLCBjaGlsZHJlbjoganN4KEJhdGNoUHJvdmlkZXIsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gV3JhcHBlcih7IGNoaWxkcmVuLCBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgekluZGV4TW9kZSwgfSkge1xuICAgIGNvbnN0IGlzV3JhcHBlZCA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoaXNXcmFwcGVkKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIHdlIG5lZWQgdG8gd3JhcCBpdCB3aXRoIGEgZnJhZ21lbnQgYmVjYXVzZSBpdCdzIG5vdCBhbGxvd2VkIGZvciBjaGlsZHJlbiB0byBiZSBhIFJlYWN0Tm9kZVxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZC9pc3N1ZXMvMTgwNTFcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChSZWFjdEZsb3dQcm92aWRlciwgeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMsIGluaXRpYWxXaWR0aDogd2lkdGgsIGluaXRpYWxIZWlnaHQ6IGhlaWdodCwgZml0VmlldzogZml0VmlldywgaW5pdGlhbEZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgaW5pdGlhbE1pblpvb206IG1pblpvb20sIGluaXRpYWxNYXhab29tOiBtYXhab29tLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB6SW5kZXhNb2RlOiB6SW5kZXhNb2RlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiAwLFxufTtcbmZ1bmN0aW9uIFJlYWN0Rmxvdyh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGNsYXNzTmFtZSwgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uTm9kZUNsaWNrLCBvbkVkZ2VDbGljaywgb25Jbml0LCBvbk1vdmUsIG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQsIG9uQ29ubmVjdCwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZSwgb25TZWxlY3Rpb25DaGFuZ2UsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvbkJlZm9yZURlbGV0ZSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25MaW5lVHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBkZWxldGVLZXlDb2RlID0gJ0JhY2tzcGFjZScsIHNlbGVjdGlvbktleUNvZGUgPSAnU2hpZnQnLCBzZWxlY3Rpb25PbkRyYWcgPSBmYWxzZSwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuQWN0aXZhdGlvbktleUNvZGUgPSAnU3BhY2UnLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgc25hcFRvR3JpZCwgc25hcEdyaWQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMgPSBmYWxzZSwgc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVzRHJhZ2dhYmxlLCBhdXRvUGFuT25Ob2RlRm9jdXMsIG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlLCBub2RlT3JpZ2luID0gZGVmYXVsdE5vZGVPcmlnaW4sIGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZSA9IHRydWUsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0JDEgPSBkZWZhdWx0Vmlld3BvcnQsIG1pblpvb20gPSAwLjUsIG1heFpvb20gPSAyLCB0cmFuc2xhdGVFeHRlbnQgPSBpbmZpbml0ZUV4dGVudCwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIG5vZGVFeHRlbnQsIGRlZmF1bHRNYXJrZXJDb2xvciA9ICcjYjFiMWI3Jywgem9vbU9uU2Nyb2xsID0gdHJ1ZSwgem9vbU9uUGluY2ggPSB0cnVlLCBwYW5PblNjcm9sbCA9IGZhbHNlLCBwYW5PblNjcm9sbFNwZWVkID0gMC41LCBwYW5PblNjcm9sbE1vZGUgPSBQYW5PblNjcm9sbE1vZGUuRnJlZSwgem9vbU9uRG91YmxlQ2xpY2sgPSB0cnVlLCBwYW5PbkRyYWcgPSB0cnVlLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51LCBwYW5lQ2xpY2tEaXN0YW5jZSA9IDEsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgY2hpbGRyZW4sIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cyA9IDEwLCBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlLCBub0RyYWdDbGFzc05hbWUgPSAnbm9kcmFnJywgbm9XaGVlbENsYXNzTmFtZSA9ICdub3doZWVsJywgbm9QYW5DbGFzc05hbWUgPSAnbm9wYW4nLCBmaXRWaWV3LCBmaXRWaWV3T3B0aW9ucywgY29ubmVjdE9uQ2xpY2ssIGF0dHJpYnV0aW9uUG9zaXRpb24sIHByb09wdGlvbnMsIGRlZmF1bHRFZGdlT3B0aW9ucywgZWxldmF0ZU5vZGVzT25TZWxlY3QgPSB0cnVlLCBlbGV2YXRlRWRnZXNPblNlbGVjdCA9IGZhbHNlLCBkaXNhYmxlS2V5Ym9hcmRBMTF5ID0gZmFsc2UsIGF1dG9QYW5PbkNvbm5lY3QsIGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQsIGNvbm5lY3Rpb25SYWRpdXMsIGlzVmFsaWRDb25uZWN0aW9uLCBvbkVycm9yLCBzdHlsZSwgaWQsIG5vZGVEcmFnVGhyZXNob2xkLCBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIHdpZHRoLCBoZWlnaHQsIGNvbG9yTW9kZSA9ICdsaWdodCcsIGRlYnVnLCBvblNjcm9sbCwgYXJpYUxhYmVsQ29uZmlnLCB6SW5kZXhNb2RlID0gJ2Jhc2ljJywgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCByZklkID0gaWQgfHwgJzEnO1xuICAgIGNvbnN0IGNvbG9yTW9kZUNsYXNzTmFtZSA9IHVzZUNvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgLy8gVW5kbyBzY3JvbGwgZXZlbnRzLCBwcmV2ZW50aW5nIHZpZXdwb3J0IGZyb20gc2hpZnRpbmcgd2hlbiBub2RlcyBvdXRzaWRlIG9mIGl0IGFyZSBmb2N1c2VkXG4gICAgY29uc3Qgd3JhcHBlck9uU2Nyb2xsID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvKHsgdG9wOiAwLCBsZWZ0OiAwLCBiZWhhdmlvcjogJ2luc3RhbnQnIH0pO1xuICAgICAgICBvblNjcm9sbD8uKGUpO1xuICAgIH0sIFtvblNjcm9sbF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInJmX193cmFwcGVyXCIsIC4uLnJlc3QsIG9uU2Nyb2xsOiB3cmFwcGVyT25TY3JvbGwsIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi53cmFwcGVyU3R5bGUgfSwgcmVmOiByZWYsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93JywgY2xhc3NOYW1lLCBjb2xvck1vZGVDbGFzc05hbWVdKSwgaWQ6IGlkLCByb2xlOiBcImFwcGxpY2F0aW9uXCIsIGNoaWxkcmVuOiBqc3hzKFdyYXBwZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgekluZGV4TW9kZTogekluZGV4TW9kZSwgY2hpbGRyZW46IFtqc3goR3JhcGhWaWV3LCB7IG9uSW5pdDogb25Jbml0LCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uRWRnZUNsaWNrOiBvbkVkZ2VDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgb25Ob2RlRG91YmxlQ2xpY2s6IG9uTm9kZURvdWJsZUNsaWNrLCBub2RlVHlwZXM6IG5vZGVUeXBlcywgZWRnZVR5cGVzOiBlZGdlVHlwZXMsIGNvbm5lY3Rpb25MaW5lVHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudDogY29ubmVjdGlvbkxpbmVDb21wb25lbnQsIGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGU6IGNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUsIHNlbGVjdGlvbktleUNvZGU6IHNlbGVjdGlvbktleUNvZGUsIHNlbGVjdGlvbk9uRHJhZzogc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlOiBzZWxlY3Rpb25Nb2RlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgb25seVJlbmRlclZpc2libGVFbGVtZW50czogb25seVJlbmRlclZpc2libGVFbGVtZW50cywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQkMSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb206IG1pblpvb20sIG1heFpvb206IG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmc6IHByZXZlbnRTY3JvbGxpbmcsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZVNjcm9sbDogb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudTogb25QYW5lQ29udGV4dE1lbnUsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgbm9kZUNsaWNrRGlzdGFuY2U6IG5vZGVDbGlja0Rpc3RhbmNlLCBvblNlbGVjdGlvbkNvbnRleHRNZW51OiBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZURvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlcjogb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uRWRnZU1vdXNlTGVhdmU6IG9uRWRnZU1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBkZWZhdWx0TWFya2VyQ29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgdmlld3BvcnQ6IHZpZXdwb3J0LCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlIH0pLCBqc3goU3RvcmVVcGRhdGVyLCB7IG5vZGVzOiBub2RlcywgZWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXM6IGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMsIG9uQ29ubmVjdDogb25Db25uZWN0LCBvbkNvbm5lY3RTdGFydDogb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZDogb25Db25uZWN0RW5kLCBvbkNsaWNrQ29ubmVjdFN0YXJ0OiBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZDogb25DbGlja0Nvbm5lY3RFbmQsIG5vZGVzRHJhZ2dhYmxlOiBub2Rlc0RyYWdnYWJsZSwgYXV0b1Bhbk9uTm9kZUZvY3VzOiBhdXRvUGFuT25Ob2RlRm9jdXMsIG5vZGVzQ29ubmVjdGFibGU6IG5vZGVzQ29ubmVjdGFibGUsIG5vZGVzRm9jdXNhYmxlOiBub2Rlc0ZvY3VzYWJsZSwgZWRnZXNGb2N1c2FibGU6IGVkZ2VzRm9jdXNhYmxlLCBlZGdlc1JlY29ubmVjdGFibGU6IGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiBlbGV2YXRlTm9kZXNPblNlbGVjdCwgZWxldmF0ZUVkZ2VzT25TZWxlY3Q6IGVsZXZhdGVFZGdlc09uU2VsZWN0LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBvbk5vZGVzQ2hhbmdlOiBvbk5vZGVzQ2hhbmdlLCBvbkVkZ2VzQ2hhbmdlOiBvbkVkZ2VzQ2hhbmdlLCBzbmFwVG9HcmlkOiBzbmFwVG9HcmlkLCBzbmFwR3JpZDogc25hcEdyaWQsIGNvbm5lY3Rpb25Nb2RlOiBjb25uZWN0aW9uTW9kZSwgdHJhbnNsYXRlRXh0ZW50OiB0cmFuc2xhdGVFeHRlbnQsIGNvbm5lY3RPbkNsaWNrOiBjb25uZWN0T25DbGljaywgZGVmYXVsdEVkZ2VPcHRpb25zOiBkZWZhdWx0RWRnZU9wdGlvbnMsIGZpdFZpZXc6IGZpdFZpZXcsIGZpdFZpZXdPcHRpb25zOiBmaXRWaWV3T3B0aW9ucywgb25Ob2Rlc0RlbGV0ZTogb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZTogb25FZGdlc0RlbGV0ZSwgb25EZWxldGU6IG9uRGVsZXRlLCBvbk5vZGVEcmFnU3RhcnQ6IG9uTm9kZURyYWdTdGFydCwgb25Ob2RlRHJhZzogb25Ob2RlRHJhZywgb25Ob2RlRHJhZ1N0b3A6IG9uTm9kZURyYWdTdG9wLCBvblNlbGVjdGlvbkRyYWc6IG9uU2VsZWN0aW9uRHJhZywgb25TZWxlY3Rpb25EcmFnU3RhcnQ6IG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWdTdG9wOiBvblNlbGVjdGlvbkRyYWdTdG9wLCBvbk1vdmU6IG9uTW92ZSwgb25Nb3ZlU3RhcnQ6IG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQ6IG9uTW92ZUVuZCwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCByZklkOiByZklkLCBhdXRvUGFuT25Db25uZWN0OiBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZzogYXV0b1Bhbk9uTm9kZURyYWcsIGF1dG9QYW5TcGVlZDogYXV0b1BhblNwZWVkLCBvbkVycm9yOiBvbkVycm9yLCBjb25uZWN0aW9uUmFkaXVzOiBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb24sIHNlbGVjdE5vZGVzT25EcmFnOiBzZWxlY3ROb2Rlc09uRHJhZywgbm9kZURyYWdUaHJlc2hvbGQ6IG5vZGVEcmFnVGhyZXNob2xkLCBjb25uZWN0aW9uRHJhZ1RocmVzaG9sZDogY29ubmVjdGlvbkRyYWdUaHJlc2hvbGQsIG9uQmVmb3JlRGVsZXRlOiBvbkJlZm9yZURlbGV0ZSwgZGVidWc6IGRlYnVnLCBhcmlhTGFiZWxDb25maWc6IGFyaWFMYWJlbENvbmZpZywgekluZGV4TW9kZTogekluZGV4TW9kZSB9KSwganN4KFNlbGVjdGlvbkxpc3RlbmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KSwgY2hpbGRyZW4sIGpzeChBdHRyaWJ1dGlvbiwgeyBwcm9PcHRpb25zOiBwcm9PcHRpb25zLCBwb3NpdGlvbjogYXR0cmlidXRpb25Qb3NpdGlvbiB9KSwganN4KEExMXlEZXNjcmlwdGlvbnMsIHsgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KV0gfSkgfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCBpcyB0aGUgaGVhcnQgb2YgeW91ciBSZWFjdCBGbG93IGFwcGxpY2F0aW9uLlxuICogSXQgcmVuZGVycyB5b3VyIG5vZGVzIGFuZCBlZGdlcyBhbmQgaGFuZGxlcyB1c2VyIGludGVyYWN0aW9uXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuICg8UmVhY3RGbG93XG4gKiAgICBub2Rlcz17Li4ufVxuICogICAgZWRnZXM9ey4uLn1cbiAqICAgIG9uTm9kZXNDaGFuZ2U9ey4uLn1cbiAqICAgIC4uLlxuICogIC8+KTtcbiAqfVxuICpgYGBcbiAqL1xudmFyIGluZGV4ID0gZml4ZWRGb3J3YXJkUmVmKFJlYWN0Rmxvdyk7XG5cbmNvbnN0IHNlbGVjdG9yJDYgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyJyk7XG4vKipcbiAqIEVkZ2VzIGFyZSBTVkctYmFzZWQuIElmIHlvdSB3YW50IHRvIHJlbmRlciBtb3JlIGNvbXBsZXggbGFiZWxzIHlvdSBjYW4gdXNlIHRoZVxuICogYDxFZGdlTGFiZWxSZW5kZXJlciAvPmAgY29tcG9uZW50IHRvIGFjY2VzcyBhIGRpdiBiYXNlZCByZW5kZXJlci4gVGhpcyBjb21wb25lbnRcbiAqIGlzIGEgcG9ydGFsIHRoYXQgcmVuZGVycyB0aGUgbGFiZWwgaW4gYSBgPGRpdiAvPmAgdGhhdCBpcyBwb3NpdGlvbmVkIG9uIHRvcCBvZlxuICogdGhlIGVkZ2VzLiBZb3UgY2FuIHNlZSBhbiBleGFtcGxlIHVzYWdlIG9mIHRoZSBjb21wb25lbnQgaW4gdGhlXG4gKiBbZWRnZSBsYWJlbCByZW5kZXJlciBleGFtcGxlXSgvZXhhbXBsZXMvZWRnZXMvZWRnZS1sYWJlbC1yZW5kZXJlcikuXG4gKiBAcHVibGljXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IGdldEJlemllclBhdGgsIEVkZ2VMYWJlbFJlbmRlcmVyLCBCYXNlRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlKHsgaWQsIGRhdGEsIC4uLnByb3BzIH0pIHtcbiAqICAgY29uc3QgW2VkZ2VQYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRCZXppZXJQYXRoKHByb3BzKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPD5cbiAqICAgICAgIDxCYXNlRWRnZSBpZD17aWR9IHBhdGg9e2VkZ2VQYXRofSAvPlxuICogICAgICAgPEVkZ2VMYWJlbFJlbmRlcmVyPlxuICogICAgICAgICA8ZGl2XG4gKiAgICAgICAgICAgc3R5bGU9e3tcbiAqICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICogICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKC01MCUsIC01MCUpIHRyYW5zbGF0ZSgke2xhYmVsWH1weCwke2xhYmVsWX1weClgLFxuICogICAgICAgICAgICAgYmFja2dyb3VuZDogJyNmZmNjMDAnLFxuICogICAgICAgICAgICAgcGFkZGluZzogMTAsXG4gKiAgICAgICAgIH19XG4gKiAgICAgICAgICAgY2xhc3NOYW1lPVwibm9kcmFnIG5vcGFuXCJcbiAqICAgICAgICAgPlxuICogICAgICAgICAge2RhdGEubGFiZWx9XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgPC9FZGdlTGFiZWxSZW5kZXJlcj5cbiAqICAgICA8Lz5cbiAqICAgKTtcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGUgYDxFZGdlTGFiZWxSZW5kZXJlciAvPmAgaGFzIG5vIHBvaW50ZXIgZXZlbnRzIGJ5IGRlZmF1bHQuIElmIHlvdSB3YW50IHRvXG4gKiBhZGQgbW91c2UgaW50ZXJhY3Rpb25zIHlvdSBuZWVkIHRvIHNldCB0aGUgc3R5bGUgYHBvaW50ZXJFdmVudHM6IGFsbGAgYW5kIGFkZFxuICogdGhlIGBub3BhbmAgY2xhc3Mgb24gdGhlIGxhYmVsIG9yIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIGludGVyYWN0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEVkZ2VMYWJlbFJlbmRlcmVyKHsgY2hpbGRyZW4gfSkge1xuICAgIGNvbnN0IGVkZ2VMYWJlbFJlbmRlcmVyID0gdXNlU3RvcmUoc2VsZWN0b3IkNik7XG4gICAgaWYgKCFlZGdlTGFiZWxSZW5kZXJlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgZWRnZUxhYmVsUmVuZGVyZXIpO1xufVxuXG5jb25zdCBzZWxlY3RvciQ1ID0gKHMpID0+IHMuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3ZpZXdwb3J0LXBvcnRhbCcpO1xuLyoqXG4gKiBUaGUgYDxWaWV3cG9ydFBvcnRhbCAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGFkZCBjb21wb25lbnRzIHRvIHRoZSBzYW1lIHZpZXdwb3J0XG4gKiBvZiB0aGUgZmxvdyB3aGVyZSBub2RlcyBhbmQgZWRnZXMgYXJlIHJlbmRlcmVkLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHJlbmRlclxuICogeW91ciBvd24gY29tcG9uZW50cyB0aGF0IGFyZSBhZGhlcmUgdG8gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0gYXMgdGhlIG5vZGVzICYgZWRnZXNcbiAqIGFuZCBhcmUgYWxzbyBhZmZlY3RlZCBieSB6b29taW5nIGFuZCBwYW5uaW5nXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGpzeFxuICppbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBWaWV3cG9ydFBvcnRhbCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIHJldHVybiAoXG4gKiAgICA8Vmlld3BvcnRQb3J0YWw+XG4gKiAgICAgIDxkaXZcbiAqICAgICAgICBzdHlsZT17eyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMTAwcHgsIDEwMHB4KScsIHBvc2l0aW9uOiAnYWJzb2x1dGUnIH19XG4gKiAgICAgID5cbiAqICAgICAgICBUaGlzIGRpdiBpcyBwb3NpdGlvbmVkIGF0IFsxMDAsIDEwMF0gb24gdGhlIGZsb3cuXG4gKiAgICAgIDwvZGl2PlxuICogICAgPC9WaWV3cG9ydFBvcnRhbD5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiBWaWV3cG9ydFBvcnRhbCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB2aWV3UG9ydGFsRGl2ID0gdXNlU3RvcmUoc2VsZWN0b3IkNSk7XG4gICAgaWYgKCF2aWV3UG9ydGFsRGl2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB2aWV3UG9ydGFsRGl2KTtcbn1cblxuLyoqXG4gKiBXaGVuIHlvdSBwcm9ncmFtbWF0aWNhbGx5IGFkZCBvciByZW1vdmUgaGFuZGxlcyB0byBhIG5vZGUgb3IgdXBkYXRlIGEgbm9kZSdzXG4gKiBoYW5kbGUgcG9zaXRpb24sIHlvdSBuZWVkIHRvIGxldCBSZWFjdCBGbG93IGtub3cgYWJvdXQgaXQgdXNpbmcgdGhpcyBob29rLiBUaGlzXG4gKiB3aWxsIHVwZGF0ZSB0aGUgaW50ZXJuYWwgZGltZW5zaW9ucyBvZiB0aGUgbm9kZSBhbmQgcHJvcGVybHkgcmVwb3NpdGlvbiBoYW5kbGVzXG4gKiBvbiB0aGUgY2FudmFzIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBVc2UgdGhpcyBmdW5jdGlvbiB0byB0ZWxsIFJlYWN0IEZsb3cgdG8gdXBkYXRlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBvbmUgb3IgbW9yZSBub2Rlc1xuICogdGhhdCB5b3UgaGF2ZSBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgdXNlVXBkYXRlTm9kZUludGVybmFscyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmFuZG9tSGFuZGxlTm9kZSh7IGlkIH0pIHtcbiAqICBjb25zdCB1cGRhdGVOb2RlSW50ZXJuYWxzID0gdXNlVXBkYXRlTm9kZUludGVybmFscygpO1xuICogIGNvbnN0IFtoYW5kbGVDb3VudCwgc2V0SGFuZGxlQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gKiAgY29uc3QgcmFuZG9taXplSGFuZGxlQ291bnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgIHNldEhhbmRsZUNvdW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSk7XG4gKiAgICB1cGRhdGVOb2RlSW50ZXJuYWxzKGlkKTtcbiAqICB9LCBbaWQsIHVwZGF0ZU5vZGVJbnRlcm5hbHNdKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIHtBcnJheS5mcm9tKHsgbGVuZ3RoOiBoYW5kbGVDb3VudCB9KS5tYXAoKF8sIGluZGV4KSA9PiAoXG4gKiAgICAgICAgPEhhbmRsZVxuICogICAgICAgICAga2V5PXtpbmRleH1cbiAqICAgICAgICAgIHR5cGU9XCJ0YXJnZXRcIlxuICogICAgICAgICAgcG9zaXRpb249XCJsZWZ0XCJcbiAqICAgICAgICAgIGlkPXtgaGFuZGxlLSR7aW5kZXh9YH1cbiAqICAgICAgICAvPlxuICogICAgICApKX1cbiAqXG4gKiAgICAgIDxkaXY+XG4gKiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtyYW5kb21pemVIYW5kbGVDb3VudH0+UmFuZG9taXplIGhhbmRsZSBjb3VudDwvYnV0dG9uPlxuICogICAgICAgIDxwPlRoZXJlIGFyZSB7aGFuZGxlQ291bnR9IGhhbmRsZXMgb24gdGhpcyBub2RlLjwvcD5cbiAqICAgICAgPC9kaXY+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVGhpcyBob29rIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBhIGNoaWxkIG9mIGFcbiAqe0BsaW5rIFJlYWN0Rmxvd1Byb3ZpZGVyfSBvciBhIHtAbGluayBSZWFjdEZsb3d9IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlVXBkYXRlTm9kZUludGVybmFscygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRvbU5vZGUsIHVwZGF0ZU5vZGVJbnRlcm5hbHMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuICAgICAgICBjb25zdCB1cGRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB1cGRhdGVJZHMuZm9yRWFjaCgodXBkYXRlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtZW50ID0gZG9tTm9kZT8ucXVlcnlTZWxlY3RvcihgLnJlYWN0LWZsb3dfX25vZGVbZGF0YS1pZD1cIiR7dXBkYXRlSWR9XCJdYCk7XG4gICAgICAgICAgICBpZiAobm9kZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldCh1cGRhdGVJZCwgeyBpZDogdXBkYXRlSWQsIG5vZGVFbGVtZW50LCBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMsIHsgdHJpZ2dlckZpdFZpZXc6IGZhbHNlIH0pKTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IG5vZGVzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLm5vZGVzO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBub2Rlcy4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgYW55IG5vZGUgY2hhbmdlcyoqLCBpbmNsdWRpbmcgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWRcbiAqIG9yIG1vdmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBub2RlcyBjdXJyZW50bHkgaW4gdGhlIGZsb3cuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VOb2RlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gKiAgY29uc3Qgbm9kZXMgPSB1c2VOb2RlcygpO1xuICpcbiAqICByZXR1cm4gPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtub2Rlcy5sZW5ndGh9IG5vZGVzITwvZGl2PjtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXMoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5cbmNvbnN0IGVkZ2VzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmVkZ2VzO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBlZGdlcy4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgYW55IGVkZ2UgY2hhbmdlcyoqLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBlZGdlcyBjdXJyZW50bHkgaW4gdGhlIGZsb3cuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VFZGdlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGVkZ2VzID0gdXNlRWRnZXMoKTtcbiAqXG4gKiAgcmV0dXJuIDxkaXY+VGhlcmUgYXJlIGN1cnJlbnRseSB7ZWRnZXMubGVuZ3RofSBlZGdlcyE8L2Rpdj47XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzKCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoZWRnZXNTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VzO1xufVxuXG5jb25zdCB2aWV3cG9ydFNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxufSk7XG4vKipcbiAqIFRoZSBgdXNlVmlld3BvcnRgIGhvb2sgaXMgYSBjb252ZW5pZW50IHdheSB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICoge0BsaW5rIFZpZXdwb3J0fSBpbiBhIGNvbXBvbmVudC4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgdGhlIHZpZXdwb3J0IGNoYW5nZXMqKi5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBUaGUgY3VycmVudCB2aWV3cG9ydC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBganN4XG4gKmltcG9ydCB7IHVzZVZpZXdwb3J0IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBWaWV3cG9ydERpc3BsYXkoKSB7XG4gKiAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSB1c2VWaWV3cG9ydCgpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHA+XG4gKiAgICAgICAgVGhlIHZpZXdwb3J0IGlzIGN1cnJlbnRseSBhdCAoe3h9LCB7eX0pIGFuZCB6b29tZWQgdG8ge3pvb219LlxuICogICAgICA8L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBjYW4gb25seSBiZSB1c2VkIGluIGEgY29tcG9uZW50IHRoYXQgaXMgYSBjaGlsZCBvZiBhXG4gKntAbGluayBSZWFjdEZsb3dQcm92aWRlcn0gb3IgYSB7QGxpbmsgUmVhY3RGbG93fSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdXNlU3RvcmUodmlld3BvcnRTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0O1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayBtYWtlcyBpdCBlYXN5IHRvIHByb3RvdHlwZSBhIGNvbnRyb2xsZWQgZmxvdyB3aGVyZSB5b3UgbWFuYWdlIHRoZVxuICogc3RhdGUgb2Ygbm9kZXMgYW5kIGVkZ2VzIG91dHNpZGUgdGhlIGBSZWFjdEZsb3dJbnN0YW5jZWAuIFlvdSBjYW4gdGhpbmsgb2YgaXRcbiAqIGxpa2UgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2sgd2l0aCBhbiBhZGRpdGlvbmFsIGhlbHBlciBjYWxsYmFjay5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmV0dXJuc1xuICogLSBgbm9kZXNgOiBUaGUgY3VycmVudCBhcnJheSBvZiBub2Rlcy4gWW91IG1pZ2h0IHBhc3MgdGhpcyBkaXJlY3RseSB0byB0aGUgYG5vZGVzYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQsIG9yIHlvdSBtYXkgd2FudCB0byBtYW5pcHVsYXRlIGl0IGZpcnN0IHRvIHBlcmZvcm0gc29tZSBsYXlvdXRpbmcsXG4gKiBmb3IgZXhhbXBsZS5cbiAqIC0gYHNldE5vZGVzYDogQSBmdW5jdGlvbiB0aGF0IHlvdSBjYW4gdXNlIHRvIHVwZGF0ZSB0aGUgbm9kZXMuIFlvdSBjYW4gcGFzcyBpdCBhIG5ldyBhcnJheSBvZlxuICogbm9kZXMgb3IgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBjdXJyZW50IGFycmF5IG9mIG5vZGVzIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IG9mIG5vZGVzLlxuICogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIHR1cGxlIHJldHVybmVkIGJ5IFJlYWN0J3MgYHVzZVN0YXRlYCBob29rLlxuICogLSBgb25Ob2Rlc0NoYW5nZWA6IEEgaGFuZHkgY2FsbGJhY2sgdGhhdCBjYW4gdGFrZSBhbiBhcnJheSBvZiBgTm9kZUNoYW5nZXNgIGFuZCB1cGRhdGUgdGhlIG5vZGVzXG4gKiBzdGF0ZSBhY2NvcmRpbmdseS4gWW91J2xsIHR5cGljYWxseSBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBvbk5vZGVzQ2hhbmdlYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQuXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgdXNlTm9kZXNTdGF0ZSwgdXNlRWRnZXNTdGF0ZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3QgaW5pdGlhbE5vZGVzID0gW107XG4gKmNvbnN0IGluaXRpYWxFZGdlcyA9IFtdO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdID0gdXNlTm9kZXNTdGF0ZShpbml0aWFsTm9kZXMpO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdID0gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0Rmxvd1xuICogICAgICBub2Rlcz17bm9kZXN9XG4gKiAgICAgIGVkZ2VzPXtlZGdlc31cbiAqICAgICAgb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX1cbiAqICAgICAgb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX1cbiAqICAgIC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgd2FzIGNyZWF0ZWQgdG8gbWFrZSBwcm90b3R5cGluZyBlYXNpZXIgYW5kIG91ciBkb2N1bWVudGF0aW9uXG4gKiBleGFtcGxlcyBjbGVhcmVyLiBBbHRob3VnaCBpdCBpcyBPSyB0byB1c2UgdGhpcyBob29rIGluIHByb2R1Y3Rpb24sIGluXG4gKiBwcmFjdGljZSB5b3UgbWF5IHdhbnQgdG8gdXNlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHN0YXRlIG1hbmFnZW1lbnQgc29sdXRpb25cbiAqIGxpa2UgWnVzdGFuZCB7QGxpbmsgaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2RvY3MvZ3VpZGVzL3N0YXRlLW1hbmFnZW1lbnQvfSBpbnN0ZWFkLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXNTdGF0ZShpbml0aWFsTm9kZXMpIHtcbiAgICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlKGluaXRpYWxOb2Rlcyk7XG4gICAgY29uc3Qgb25Ob2Rlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKChjaGFuZ2VzKSA9PiBzZXROb2RlcygobmRzKSA9PiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5kcykpLCBbXSk7XG4gICAgcmV0dXJuIFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdO1xufVxuLyoqXG4gKiBUaGlzIGhvb2sgbWFrZXMgaXQgZWFzeSB0byBwcm90b3R5cGUgYSBjb250cm9sbGVkIGZsb3cgd2hlcmUgeW91IG1hbmFnZSB0aGVcbiAqIHN0YXRlIG9mIG5vZGVzIGFuZCBlZGdlcyBvdXRzaWRlIHRoZSBgUmVhY3RGbG93SW5zdGFuY2VgLiBZb3UgY2FuIHRoaW5rIG9mIGl0XG4gKiBsaWtlIFJlYWN0J3MgYHVzZVN0YXRlYCBob29rIHdpdGggYW4gYWRkaXRpb25hbCBoZWxwZXIgY2FsbGJhY2suXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnNcbiAqIC0gYGVkZ2VzYDogVGhlIGN1cnJlbnQgYXJyYXkgb2YgZWRnZXMuIFlvdSBtaWdodCBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBlZGdlc2AgcHJvcCBvZiB5b3VyXG4gKiBgPFJlYWN0RmxvdyAvPmAgY29tcG9uZW50LCBvciB5b3UgbWF5IHdhbnQgdG8gbWFuaXB1bGF0ZSBpdCBmaXJzdCB0byBwZXJmb3JtIHNvbWUgbGF5b3V0aW5nLFxuICogZm9yIGV4YW1wbGUuXG4gKlxuICogLSBgc2V0RWRnZXNgOiBBIGZ1bmN0aW9uIHRoYXQgeW91IGNhbiB1c2UgdG8gdXBkYXRlIHRoZSBlZGdlcy4gWW91IGNhbiBwYXNzIGl0IGEgbmV3IGFycmF5IG9mXG4gKiBlZGdlcyBvciBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2YgZWRnZXMgYW5kIHJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWRnZXMuXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgdHVwbGUgcmV0dXJuZWQgYnkgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2suXG4gKlxuICogLSBgb25FZGdlc0NoYW5nZWA6IEEgaGFuZHkgY2FsbGJhY2sgdGhhdCBjYW4gdGFrZSBhbiBhcnJheSBvZiBgRWRnZUNoYW5nZXNgIGFuZCB1cGRhdGUgdGhlIGVkZ2VzXG4gKiBzdGF0ZSBhY2NvcmRpbmdseS4gWW91J2xsIHR5cGljYWxseSBwYXNzIHRoaXMgZGlyZWN0bHkgdG8gdGhlIGBvbkVkZ2VzQ2hhbmdlYCBwcm9wIG9mIHlvdXJcbiAqIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQuXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgdXNlTm9kZXNTdGF0ZSwgdXNlRWRnZXNTdGF0ZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3QgaW5pdGlhbE5vZGVzID0gW107XG4gKmNvbnN0IGluaXRpYWxFZGdlcyA9IFtdO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdID0gdXNlTm9kZXNTdGF0ZShpbml0aWFsTm9kZXMpO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdID0gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0Rmxvd1xuICogICAgICBub2Rlcz17bm9kZXN9XG4gKiAgICAgIGVkZ2VzPXtlZGdlc31cbiAqICAgICAgb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX1cbiAqICAgICAgb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX1cbiAqICAgIC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgd2FzIGNyZWF0ZWQgdG8gbWFrZSBwcm90b3R5cGluZyBlYXNpZXIgYW5kIG91ciBkb2N1bWVudGF0aW9uXG4gKiBleGFtcGxlcyBjbGVhcmVyLiBBbHRob3VnaCBpdCBpcyBPSyB0byB1c2UgdGhpcyBob29rIGluIHByb2R1Y3Rpb24sIGluXG4gKiBwcmFjdGljZSB5b3UgbWF5IHdhbnQgdG8gdXNlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHN0YXRlIG1hbmFnZW1lbnQgc29sdXRpb25cbiAqIGxpa2UgWnVzdGFuZCB7QGxpbmsgaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2RvY3MvZ3VpZGVzL3N0YXRlLW1hbmFnZW1lbnQvfSBpbnN0ZWFkLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpIHtcbiAgICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzXSA9IHVzZVN0YXRlKGluaXRpYWxFZGdlcyk7XG4gICAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKChjaGFuZ2VzKSA9PiBzZXRFZGdlcygoZWRzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkcykpLCBbXSk7XG4gICAgcmV0dXJuIFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdO1xufVxuXG4vKipcbiAqIFRoZSBgdXNlT25WaWV3cG9ydENoYW5nZWAgaG9vayBsZXRzIHlvdSBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIHZpZXdwb3J0IHN1Y2hcbiAqIGFzIHBhbm5pbmcgYW5kIHpvb21pbmcuIFlvdSBjYW4gcHJvdmlkZSBhIGNhbGxiYWNrIGZvciBlYWNoIHBoYXNlIG9mIGEgdmlld3BvcnRcbiAqIGNoYW5nZTogYG9uU3RhcnRgLCBgb25DaGFuZ2VgLCBhbmQgYG9uRW5kYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyB1c2VPblZpZXdwb3J0Q2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBWaWV3cG9ydENoYW5nZUxvZ2dlcigpIHtcbiAqICB1c2VPblZpZXdwb3J0Q2hhbmdlKHtcbiAqICAgIG9uU3RhcnQ6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdzdGFydCcsIHZpZXdwb3J0KSxcbiAqICAgIG9uQ2hhbmdlOiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnY2hhbmdlJywgdmlld3BvcnQpLFxuICogICAgb25FbmQ6ICh2aWV3cG9ydDogVmlld3BvcnQpID0+IGNvbnNvbGUubG9nKCdlbmQnLCB2aWV3cG9ydCksXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiBudWxsO1xuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiB1c2VPblZpZXdwb3J0Q2hhbmdlKHsgb25TdGFydCwgb25DaGFuZ2UsIG9uRW5kIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlU3RhcnQ6IG9uU3RhcnQgfSk7XG4gICAgfSwgW29uU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2U6IG9uQ2hhbmdlIH0pO1xuICAgIH0sIFtvbkNoYW5nZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZUVuZDogb25FbmQgfSk7XG4gICAgfSwgW29uRW5kXSk7XG59XG5cbi8qKlxuICogVGhpcyBob29rIGxldHMgeW91IGxpc3RlbiBmb3IgY2hhbmdlcyB0byBib3RoIG5vZGUgYW5kIGVkZ2Ugc2VsZWN0aW9uLiBBcyB0aGVcbiAqbmFtZSBpbXBsaWVzLCB0aGUgY2FsbGJhY2sgeW91IHByb3ZpZGUgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBvZlxuICpfZWl0aGVyXyBub2RlcyBvciBlZGdlcyBjaGFuZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgdXNlT25TZWxlY3Rpb25DaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFNlbGVjdGlvbkRpc3BsYXkoKSB7XG4gKiAgY29uc3QgW3NlbGVjdGVkTm9kZXMsIHNldFNlbGVjdGVkTm9kZXNdID0gdXNlU3RhdGUoW10pO1xuICogIGNvbnN0IFtzZWxlY3RlZEVkZ2VzLCBzZXRTZWxlY3RlZEVkZ2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAqXG4gKiAgLy8gdGhlIHBhc3NlZCBoYW5kbGVyIGhhcyB0byBiZSBtZW1vaXplZCwgb3RoZXJ3aXNlIHRoZSBob29rIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5XG4gKiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VDYWxsYmFjaygoeyBub2RlcywgZWRnZXMgfSkgPT4ge1xuICogICAgc2V0U2VsZWN0ZWROb2Rlcyhub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAqICAgIHNldFNlbGVjdGVkRWRnZXMoZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLmlkKSk7XG4gKiAgfSwgW10pO1xuICpcbiAqICB1c2VPblNlbGVjdGlvbkNoYW5nZSh7XG4gKiAgICBvbkNoYW5nZSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIDxwPlNlbGVjdGVkIG5vZGVzOiB7c2VsZWN0ZWROb2Rlcy5qb2luKCcsICcpfTwvcD5cbiAqICAgICAgPHA+U2VsZWN0ZWQgZWRnZXM6IHtzZWxlY3RlZEVkZ2VzLmpvaW4oJywgJyl9PC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBZb3UgbmVlZCB0byBtZW1vaXplIHRoZSBwYXNzZWQgYG9uQ2hhbmdlYCBoYW5kbGVyLCBvdGhlcndpc2UgdGhlIGhvb2sgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIHVzZU9uU2VsZWN0aW9uQ2hhbmdlKHsgb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgPSBbLi4uc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLCBvbkNoYW5nZV07XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlcnMgPSBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZmlsdGVyKChmbikgPT4gZm4gIT09IG9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVyczogbmV4dEhhbmRsZXJzIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtvbkNoYW5nZV0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ0ID0gKG9wdGlvbnMpID0+IChzKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVIaWRkZW5Ob2Rlcykge1xuICAgICAgICByZXR1cm4gcy5ub2Rlc0luaXRpYWxpemVkO1xuICAgIH1cbiAgICBpZiAocy5ub2RlTG9va3VwLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFssIHsgaW50ZXJuYWxzIH1dIG9mIHMubm9kZUxvb2t1cCkge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyA9PT0gdW5kZWZpbmVkIHx8ICFub2RlSGFzRGltZW5zaW9ucyhpbnRlcm5hbHMudXNlck5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBUaGlzIGhvb2sgdGVsbHMgeW91IHdoZXRoZXIgYWxsIHRoZSBub2RlcyBpbiBhIGZsb3cgaGF2ZSBiZWVuIG1lYXN1cmVkIGFuZCBnaXZlblxuICphIHdpZHRoIGFuZCBoZWlnaHQuIFdoZW4geW91IGFkZCBhIG5vZGUgdG8gdGhlIGZsb3csIHRoaXMgaG9vayB3aWxsIHJldHVyblxuICpgZmFsc2VgIGFuZCB0aGVuIGB0cnVlYCBhZ2FpbiBvbmNlIHRoZSBub2RlIGhhcyBiZWVuIG1lYXN1cmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBub2RlcyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQgYnkgdGhlIGA8UmVhY3RGbG93IC8+YCBjb21wb25lbnQgYW5kXG4gKiBnaXZlbiBhIHdpZHRoIGFuZCBoZWlnaHQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VSZWFjdEZsb3csIHVzZU5vZGVzSW5pdGlhbGl6ZWQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqXG4gKmNvbnN0IG9wdGlvbnMgPSB7XG4gKiAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUxheW91dCgpIHtcbiAqICBjb25zdCB7IGdldE5vZGVzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gdXNlTm9kZXNJbml0aWFsaXplZChvcHRpb25zKTtcbiAqICBjb25zdCBbbGF5b3V0ZWROb2Rlcywgc2V0TGF5b3V0ZWROb2Rlc10gPSB1c2VTdGF0ZShnZXROb2RlcygpKTtcbiAqXG4gKiAgdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgIGlmIChub2Rlc0luaXRpYWxpemVkKSB7XG4gKiAgICAgIHNldExheW91dGVkTm9kZXMoeW91ckxheW91dGluZ0Z1bmN0aW9uKGdldE5vZGVzKCkpKTtcbiAqICAgIH1cbiAqICB9LCBbbm9kZXNJbml0aWFsaXplZF0pO1xuICpcbiAqICByZXR1cm4gbGF5b3V0ZWROb2RlcztcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXNJbml0aWFsaXplZChvcHRpb25zID0ge1xuICAgIGluY2x1ZGVIaWRkZW5Ob2RlczogZmFsc2UsXG59KSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciQ0KG9wdGlvbnMpKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZWQ7XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiBhIDxIYW5kbGUgLz4gaXMgY29ubmVjdGVkIHRvIGFub3RoZXIgPEhhbmRsZSAvPiBhbmQgZ2V0IHRoZSBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHVzZU5vZGVDb25uZWN0aW9uc2AgaW5zdGVhZC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggaGFuZGxlIGNvbm5lY3Rpb25zLlxuICovXG5mdW5jdGlvbiB1c2VIYW5kbGVDb25uZWN0aW9ucyh7IHR5cGUsIGlkLCBub2RlSWQsIG9uQ29ubmVjdCwgb25EaXNjb25uZWN0LCB9KSB7XG4gICAgY29uc29sZS53YXJuKCdbREVQUkVDQVRFRF0gYHVzZUhhbmRsZUNvbm5lY3Rpb25zYCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBgdXNlTm9kZUNvbm5lY3Rpb25zYCBodHRwczovL3JlYWN0Zmxvdy5kZXYvYXBpLXJlZmVyZW5jZS9ob29rcy91c2VOb2RlQ29ubmVjdGlvbnMnKTtcbiAgICBjb25zdCBfbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJZCA9IG5vZGVJZCA/PyBfbm9kZUlkO1xuICAgIGNvbnN0IHByZXZDb25uZWN0aW9ucyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7Y3VycmVudE5vZGVJZH0tJHt0eXBlfSR7aWQgPyBgLSR7aWR9YCA6ICcnfWApLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBAdG9kbyBkaWN1c3MgaWYgb25Db25uZWN0L29uRGlzY29ubmVjdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMvdW5tb3VudHNcbiAgICAgICAgaWYgKHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICYmIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICE9PSBjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgX2Nvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgX2Nvbm5lY3Rpb25zLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShfY29ubmVjdGlvbnMsIHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBvbkNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgIH0sIFtjb25uZWN0aW9ucywgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3RdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBBcnJheS5mcm9tKGNvbm5lY3Rpb25zPy52YWx1ZXMoKSA/PyBbXSksIFtjb25uZWN0aW9uc10pO1xufVxuXG5jb25zdCBlcnJvcjAxNCA9IGVycm9yTWVzc2FnZXNbJ2Vycm9yMDE0J10oKTtcbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYW4gYXJyYXkgb2YgY29ubmVjdGlvbnMgb24gYSBzcGVjaWZpYyBub2RlLCBoYW5kbGUgdHlwZSAoJ3NvdXJjZScsICd0YXJnZXQnKSBvciBoYW5kbGUgSUQuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCBjb25uZWN0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVDb25uZWN0aW9ucyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlTm9kZUNvbm5lY3Rpb25zKHtcbiAqICAgIGhhbmRsZVR5cGU6ICd0YXJnZXQnLFxuICogICAgaGFuZGxlSWQ6ICdteS1oYW5kbGUnLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtjb25uZWN0aW9ucy5sZW5ndGh9IGluY29taW5nIGNvbm5lY3Rpb25zITwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVDb25uZWN0aW9ucyh7IGlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0gPSB7fSkge1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlSWQgPSBpZCA/PyBub2RlSWQ7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcjAxNCk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZDb25uZWN0aW9ucyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHVzZVN0b3JlKChzdGF0ZSkgPT4gc3RhdGUuY29ubmVjdGlvbkxvb2t1cC5nZXQoYCR7Y3VycmVudE5vZGVJZH0ke2hhbmRsZVR5cGUgPyAoaGFuZGxlSWQgPyBgLSR7aGFuZGxlVHlwZX0tJHtoYW5kbGVJZH1gIDogYC0ke2hhbmRsZVR5cGV9YCkgOiAnJ31gKSwgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gQHRvZG8gZGlzY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB1c2VOb2Rlc0RhdGEobm9kZUlkcykge1xuICAgIGNvbnN0IG5vZGVzRGF0YSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgaXNBcnJheU9mSWRzID0gQXJyYXkuaXNBcnJheShub2RlSWRzKTtcbiAgICAgICAgY29uc3QgX25vZGVJZHMgPSBpc0FycmF5T2ZJZHMgPyBub2RlSWRzIDogW25vZGVJZHNdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBfbm9kZUlkcykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHMubm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbm9kZS5kYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5T2ZJZHMgPyBkYXRhIDogZGF0YVswXSA/PyBudWxsO1xuICAgIH0sIFtub2RlSWRzXSksIHNoYWxsb3dOb2RlRGF0YSk7XG4gICAgcmV0dXJuIG5vZGVzRGF0YTtcbn1cblxuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBzcGVjaWZpYyBub2RlLlxuICogQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2sgd2lsbCByZS1yZW5kZXIgKip3aGVuZXZlciB0aGUgbm9kZSBjaGFuZ2VzKiosXG4gKiBpbmNsdWRpbmcgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQgb3IgbW92ZWQuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIGEgbm9kZSB5b3Ugd2FudCB0byBvYnNlcnZlLlxuICogQHJldHVybnMgVGhlIGBJbnRlcm5hbE5vZGVgIG9iamVjdCBmb3IgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VJbnRlcm5hbE5vZGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBpbnRlcm5hbE5vZGUgPSB1c2VJbnRlcm5hbE5vZGUoJ25vZGUtMScpO1xuICogIGNvbnN0IGFic29sdXRlUG9zaXRpb24gPSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgaXMgYXQ6XG4gKiAgICAgIDxwPng6IHthYnNvbHV0ZVBvc2l0aW9uLnh9PC9wPlxuICogICAgICA8cD55OiB7YWJzb2x1dGVQb3NpdGlvbi55fTwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVybmFsTm9kZShpZCkge1xuICAgIGNvbnN0IG5vZGUgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4gcy5ub2RlTG9va3VwLmdldChpZCksIFtpZF0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBub2RlIGNoYW5nZXMuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIGZuIC0gTWlkZGxld2FyZSBmdW5jdGlvbi4gU2hvdWxkIGJlIG1lbW9pemVkIHdpdGggdXNlQ2FsbGJhY2sgdG8gYXZvaWQgcmUtcmVnaXN0cmF0aW9uLlxuICovXG5mdW5jdGlvbiBleHBlcmltZW50YWxfdXNlT25Ob2Rlc0NoYW5nZU1pZGRsZXdhcmUoZm4pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgW3N5bWJvbF0gPSB1c2VTdGF0ZSgoKSA9PiBTeW1ib2woKSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgb25Ob2Rlc0NoYW5nZU1pZGRsZXdhcmVNYXAuc2V0KHN5bWJvbCwgZm4pO1xuICAgIH0sIFtmbl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Ob2Rlc0NoYW5nZU1pZGRsZXdhcmVNYXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBvbk5vZGVzQ2hhbmdlTWlkZGxld2FyZU1hcC5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gZWRnZSBjaGFuZ2VzLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBmbiAtIE1pZGRsZXdhcmUgZnVuY3Rpb24uIFNob3VsZCBiZSBtZW1vaXplZCB3aXRoIHVzZUNhbGxiYWNrIHRvIGF2b2lkIHJlLXJlZ2lzdHJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX3VzZU9uRWRnZXNDaGFuZ2VNaWRkbGV3YXJlKGZuKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtzeW1ib2xdID0gdXNlU3RhdGUoKCkgPT4gU3ltYm9sKCkpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25FZGdlc0NoYW5nZU1pZGRsZXdhcmVNYXAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIG9uRWRnZXNDaGFuZ2VNaWRkbGV3YXJlTWFwLnNldChzeW1ib2wsIGZuKTtcbiAgICB9LCBbZm5dKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uRWRnZXNDaGFuZ2VNaWRkbGV3YXJlTWFwIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgb25FZGdlc0NoYW5nZU1pZGRsZXdhcmVNYXAuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBMaW5lUGF0dGVybih7IGRpbWVuc2lvbnMsIGxpbmVXaWR0aCwgdmFyaWFudCwgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogbGluZVdpZHRoLCBkOiBgTSR7ZGltZW5zaW9uc1swXSAvIDJ9IDAgViR7ZGltZW5zaW9uc1sxXX0gTTAgJHtkaW1lbnNpb25zWzFdIC8gMn0gSCR7ZGltZW5zaW9uc1swXX1gLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgdmFyaWFudCwgY2xhc3NOYW1lXSkgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IHJhZGl1cywgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IGN4OiByYWRpdXMsIGN5OiByYWRpdXMsIHI6IHJhZGl1cywgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsICdkb3RzJywgY2xhc3NOYW1lXSkgfSkpO1xufVxuXG4vKipcbiAqIFRoZSB0aHJlZSB2YXJpYW50cyBhcmUgZXhwb3J0ZWQgYXMgYW4gZW51bSBmb3IgY29udmVuaWVuY2UuIFlvdSBjYW4gZWl0aGVyIGltcG9ydFxuICogdGhlIGVudW0gYW5kIHVzZSBpdCBsaWtlIGBCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc2Agb3IgeW91IGNhbiB1c2UgdGhlIHJhdyBzdHJpbmdcbiAqIHZhbHVlIGRpcmVjdGx5LlxuICogQHB1YmxpY1xuICovXG52YXIgQmFja2dyb3VuZFZhcmlhbnQ7XG4oZnVuY3Rpb24gKEJhY2tncm91bmRWYXJpYW50KSB7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJMaW5lc1wiXSA9IFwibGluZXNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkRvdHNcIl0gPSBcImRvdHNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkNyb3NzXCJdID0gXCJjcm9zc1wiO1xufSkoQmFja2dyb3VuZFZhcmlhbnQgfHwgKEJhY2tncm91bmRWYXJpYW50ID0ge30pKTtcblxuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+ICh7IHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sIHBhdHRlcm5JZDogYHBhdHRlcm4tJHtzLnJmSWR9YCB9KTtcbmZ1bmN0aW9uIEJhY2tncm91bmRDb21wb25lbnQoeyBpZCwgdmFyaWFudCA9IEJhY2tncm91bmRWYXJpYW50LkRvdHMsIFxuLy8gb25seSB1c2VkIGZvciBkb3RzIGFuZCBjcm9zc1xuZ2FwID0gMjAsIFxuLy8gb25seSB1c2VkIGZvciBsaW5lcyBhbmQgY3Jvc3NcbnNpemUsIGxpbmVXaWR0aCA9IDEsIG9mZnNldCA9IDAsIGNvbG9yLCBiZ0NvbG9yLCBzdHlsZSwgY2xhc3NOYW1lLCBwYXR0ZXJuQ2xhc3NOYW1lLCB9KSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYXR0ZXJuSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBvZmZzZXRYWSA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IFtvZmZzZXQsIG9mZnNldF07XG4gICAgY29uc3QgcGF0dGVybkRpbWVuc2lvbnMgPSBpc0Nyb3NzID8gW3NjYWxlZFNpemUsIHNjYWxlZFNpemVdIDogc2NhbGVkR2FwO1xuICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IFtcbiAgICAgICAgb2Zmc2V0WFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzBdIC8gMixcbiAgICAgICAgb2Zmc2V0WFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzFdIC8gMixcbiAgICBdO1xuICAgIGNvbnN0IF9wYXR0ZXJuSWQgPSBgJHtwYXR0ZXJuSWR9JHtpZCA/IGlkIDogJyd9YDtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZCcsIGNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiBiZ0NvbG9yLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1wYXR0ZXJuLWNvbG9yLXByb3BzJzogY29sb3IsXG4gICAgICAgIH0sIHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2JhY2tncm91bmRcIiwgY2hpbGRyZW46IFtqc3goXCJwYXR0ZXJuXCIsIHsgaWQ6IF9wYXR0ZXJuSWQsIHg6IHRyYW5zZm9ybVswXSAlIHNjYWxlZEdhcFswXSwgeTogdHJhbnNmb3JtWzFdICUgc2NhbGVkR2FwWzFdLCB3aWR0aDogc2NhbGVkR2FwWzBdLCBoZWlnaHQ6IHNjYWxlZEdhcFsxXSwgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsIHBhdHRlcm5UcmFuc2Zvcm06IGB0cmFuc2xhdGUoLSR7c2NhbGVkT2Zmc2V0WzBdfSwtJHtzY2FsZWRPZmZzZXRbMV19KWAsIGNoaWxkcmVuOiBpc0RvdHMgPyAoanN4KERvdFBhdHRlcm4sIHsgcmFkaXVzOiBzY2FsZWRTaXplIC8gMiwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSA6IChqc3goTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGxpbmVXaWR0aDogbGluZVdpZHRoLCB2YXJpYW50OiB2YXJpYW50LCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIH0pLCBqc3goXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7X3BhdHRlcm5JZH0pYCB9KV0gfSkpO1xufVxuQmFja2dyb3VuZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdCYWNrZ3JvdW5kJztcbi8qKlxuICogVGhlIGA8QmFja2dyb3VuZCAvPmAgY29tcG9uZW50IG1ha2VzIGl0IGNvbnZlbmllbnQgdG8gcmVuZGVyIGRpZmZlcmVudCB0eXBlcyBvZiBiYWNrZ3JvdW5kcyBjb21tb24gaW4gbm9kZS1iYXNlZCBVSXMuIEl0IGNvbWVzIHdpdGggdGhyZWUgdmFyaWFudHM6IGxpbmVzLCBkb3RzIGFuZCBjcm9zcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEEgc2ltcGxlIGV4YW1wbGUgb2YgaG93IHRvIHVzZSB0aGUgQmFja2dyb3VuZCBjb21wb25lbnQuXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZCBjb2xvcj1cIiNjY2NcIiB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzfSAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUgeW91IGNhbiBzZWUgaG93IHRvIGNvbWJpbmUgbXVsdGlwbGUgYmFja2dyb3VuZHNcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqIGltcG9ydCAnQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8UmVhY3RGbG93IGRlZmF1bHROb2Rlcz17Wy4uLl19IGRlZmF1bHRFZGdlcz17Wy4uLl19PlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIxXCJcbiAqICAgICAgICAgZ2FwPXsxMH1cbiAqICAgICAgICAgY29sb3I9XCIjZjFmMWYxXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIyXCJcbiAqICAgICAgICAgZ2FwPXsxMDB9XG4gKiAgICAgICAgIGNvbG9yPVwiI2NjY1wiXG4gKiAgICAgICAgIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkxpbmVzfVxuICogICAgICAgLz5cbiAqICAgICA8L1JlYWN0Rmxvdz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogV2hlbiBjb21iaW5pbmcgbXVsdGlwbGUgPEJhY2tncm91bmQgLz4gY29tcG9uZW50cyBpdOKAmXMgaW1wb3J0YW50IHRvIGdpdmUgZWFjaCBvZiB0aGVtIGEgdW5pcXVlIGlkIHByb3AhXG4gKlxuICovXG5jb25zdCBCYWNrZ3JvdW5kID0gbWVtbyhCYWNrZ3JvdW5kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUGx1c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMyIDE4LjEzM0gxOC4xMzNWMzJoLTQuMjY2VjE4LjEzM0gwdi00LjI2NmgxMy44NjdWMGg0LjI2NnYxMy44NjdIMzJ6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiA1XCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gRml0Vmlld0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMFwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMuNjkyIDQuNjNjMC0uNTMuNC0uOTM4LjkzOS0uOTM4aDUuMjE1VjBINC43MDhDMi4xMyAwIDAgMi4wNTQgMCA0LjYzdjUuMjE2aDMuNjkyVjQuNjMxek0yNy4zNTQgMGgtNS4ydjMuNjkyaDUuMTdjLjUzIDAgLjk4NC40Ljk4NC45Mzl2NS4yMTVIMzJWNC42MzFBNC42MjQgNC42MjQgMCAwMDI3LjM1NCAwem0uOTU0IDI0LjgzYzAgLjUzMi0uNC45NC0uOTM5Ljk0aC01LjIxNXYzLjc2OGg1LjIxNWMyLjU3NyAwIDQuNjMxLTIuMTMgNC42MzEtNC43MDd2LTUuMTM5aC0zLjY5MnY1LjEzOXptLTIzLjY3Ny45NGMtLjUzMSAwLS45MzktLjQtLjkzOS0uOTR2LTUuMTM4SDB2NS4xMzljMCAyLjU3NyAyLjEzIDQuNzA3IDQuNzA4IDQuNzA3aDUuMTM4VjI1Ljc3SDQuNjMxelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gTG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwIDggMCA0LjU3MSAzLjQyOSA0LjU3MSA3LjYxOXYzLjA0OEgzLjA0OEEzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6bTQuNzI0LTEzLjg2Nkg3LjQ2N1Y3LjYxOWMwLTIuNTkgMi4xMzMtNC43MjQgNC43MjMtNC43MjQgMi41OTEgMCA0LjcyNCAyLjEzMyA0LjcyNCA0LjcyNHYzLjA0OHpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pIH0pKTtcbn1cblxuLyoqXG4gKiBZb3UgY2FuIGFkZCBidXR0b25zIHRvIHRoZSBjb250cm9sIHBhbmVsIGJ5IHVzaW5nIHRoZSBgPENvbnRyb2xCdXR0b24gLz5gIGNvbXBvbmVudFxuICogYW5kIHBhc3MgaXQgYXMgYSBjaGlsZCB0byB0aGUgW2A8Q29udHJvbHMgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2xzKSBjb21wb25lbnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IE1hZ2ljV2FuZCB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1pY29ucydcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scywgQ29udHJvbEJ1dHRvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzPlxuICogICAgICAgIDxDb250cm9sQnV0dG9uIG9uQ2xpY2s9eygpID0+IGFsZXJ0KCdTb21ldGhpbmcgbWFnaWNhbCBqdXN0IGhhcHBlbmVkLiDinKgnKX0+XG4gKiAgICAgICAgICA8TWFnaWNXYW5kIC8+XG4gKiAgICAgICAgPC9Db250cm9sQnV0dG9uPlxuICogICAgICA8L0NvbnRyb2xzPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiBDb250cm9sQnV0dG9uKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29udHJvbHMtYnV0dG9uJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDIgPSAocykgPT4gKHtcbiAgICBpc0ludGVyYWN0aXZlOiBzLm5vZGVzRHJhZ2dhYmxlIHx8IHMubm9kZXNDb25uZWN0YWJsZSB8fCBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBtaW5ab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPD0gcy5taW5ab29tLFxuICAgIG1heFpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA+PSBzLm1heFpvb20sXG4gICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbn0pO1xuZnVuY3Rpb24gQ29udHJvbHNDb21wb25lbnQoeyBzdHlsZSwgc2hvd1pvb20gPSB0cnVlLCBzaG93Rml0VmlldyA9IHRydWUsIHNob3dJbnRlcmFjdGl2ZSA9IHRydWUsIGZpdFZpZXdPcHRpb25zLCBvblpvb21Jbiwgb25ab29tT3V0LCBvbkZpdFZpZXcsIG9uSW50ZXJhY3RpdmVDaGFuZ2UsIGNsYXNzTmFtZSwgY2hpbGRyZW4sIHBvc2l0aW9uID0gJ2JvdHRvbS1sZWZ0Jywgb3JpZW50YXRpb24gPSAndmVydGljYWwnLCAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGlzSW50ZXJhY3RpdmUsIG1pblpvb21SZWFjaGVkLCBtYXhab29tUmVhY2hlZCwgYXJpYUxhYmVsQ29uZmlnIH0gPSB1c2VTdG9yZShzZWxlY3RvciQyLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IHpvb21Jbiwgem9vbU91dCwgZml0VmlldyB9ID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3Qgb25ab29tSW5IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tSW4oKTtcbiAgICAgICAgb25ab29tSW4/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25ab29tT3V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgem9vbU91dCgpO1xuICAgICAgICBvblpvb21PdXQ/LigpO1xuICAgIH07XG4gICAgY29uc3Qgb25GaXRWaWV3SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZml0VmlldyhmaXRWaWV3T3B0aW9ucyk7XG4gICAgICAgIG9uRml0Vmlldz8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblRvZ2dsZUludGVyYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHtcbiAgICAgICAgICAgIG5vZGVzRHJhZ2dhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIG5vZGVzQ29ubmVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgZWxlbWVudHNTZWxlY3RhYmxlOiAhaXNJbnRlcmFjdGl2ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uSW50ZXJhY3RpdmVDaGFuZ2U/LighaXNJbnRlcmFjdGl2ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvcmllbnRhdGlvbkNsYXNzID0gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgcmV0dXJuIChqc3hzKFBhbmVsLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19jb250cm9scycsIG9yaWVudGF0aW9uQ2xhc3MsIGNsYXNzTmFtZV0pLCBwb3NpdGlvbjogcG9zaXRpb24sIHN0eWxlOiBzdHlsZSwgXCJkYXRhLXRlc3RpZFwiOiBcInJmX19jb250cm9sc1wiLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsID8/IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBbc2hvd1pvb20gJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21JbkhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29taW5cIiwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuem9vbUluLmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tSW4uYXJpYUxhYmVsJ10sIGRpc2FibGVkOiBtYXhab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChQbHVzSWNvbiwge30pIH0pLCBqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21PdXRIYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbW91dFwiLCB0aXRsZTogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsQ29uZmlnWydjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCddLCBkaXNhYmxlZDogbWluWm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goTWludXNJY29uLCB7fSkgfSldIH0pKSwgc2hvd0ZpdFZpZXcgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1maXR2aWV3XCIsIG9uQ2xpY2s6IG9uRml0Vmlld0hhbmRsZXIsIHRpdGxlOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJ10sIGNoaWxkcmVuOiBqc3goRml0Vmlld0ljb24sIHt9KSB9KSksIHNob3dJbnRlcmFjdGl2ZSAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWludGVyYWN0aXZlXCIsIG9uQ2xpY2s6IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSwgdGl0bGU6IGFyaWFMYWJlbENvbmZpZ1snY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJ10sIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDb25maWdbJ2NvbnRyb2xzLmludGVyYWN0aXZlLmFyaWFMYWJlbCddLCBjaGlsZHJlbjogaXNJbnRlcmFjdGl2ZSA/IGpzeChVbmxvY2tJY29uLCB7fSkgOiBqc3goTG9ja0ljb24sIHt9KSB9KSksIGNoaWxkcmVuXSB9KSk7XG59XG5Db250cm9sc0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdDb250cm9scyc7XG4vKipcbiAqIFRoZSBgPENvbnRyb2xzIC8+YCBjb21wb25lbnQgcmVuZGVycyBhIHNtYWxsIHBhbmVsIHRoYXQgY29udGFpbnMgY29udmVuaWVudFxuICogYnV0dG9ucyB0byB6b29tIGluLCB6b29tIG91dCwgZml0IHRoZSB2aWV3LCBhbmQgbG9jayB0aGUgdmlld3BvcnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgQ29udHJvbHMgfSBmcm9tICdAeHlmbG93L3JlYWN0J1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17Wy4uLl19IGVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgIDxDb250cm9scyAvPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRvIGV4dGVuZCBvciBjdXN0b21pc2UgdGhlIGNvbnRyb2xzLCB5b3UgY2FuIHVzZSB0aGUgW2A8Q29udHJvbEJ1dHRvbiAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbC1idXR0b24pIGNvbXBvbmVudFxuICpcbiAqL1xuY29uc3QgQ29udHJvbHMgPSBtZW1vKENvbnRyb2xzQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gTWluaU1hcE5vZGVDb21wb25lbnQoeyBpZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc3R5bGUsIGNvbG9yLCBzdHJva2VDb2xvciwgc3Ryb2tlV2lkdGgsIGNsYXNzTmFtZSwgYm9yZGVyUmFkaXVzLCBzaGFwZVJlbmRlcmluZywgc2VsZWN0ZWQsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmQsIGJhY2tncm91bmRDb2xvciB9ID0gc3R5bGUgfHwge307XG4gICAgY29uc3QgZmlsbCA9IChjb2xvciB8fCBiYWNrZ3JvdW5kIHx8IGJhY2tncm91bmRDb2xvcik7XG4gICAgcmV0dXJuIChqc3goXCJyZWN0XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX21pbmltYXAtbm9kZScsIHsgc2VsZWN0ZWQgfSwgY2xhc3NOYW1lXSksIHg6IHgsIHk6IHksIHJ4OiBib3JkZXJSYWRpdXMsIHJ5OiBib3JkZXJSYWRpdXMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIHN0eWxlOiB7XG4gICAgICAgICAgICBmaWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB9LCBzaGFwZVJlbmRlcmluZzogc2hhcGVSZW5kZXJpbmcsIG9uQ2xpY2s6IG9uQ2xpY2sgPyAoZXZlbnQpID0+IG9uQ2xpY2soZXZlbnQsIGlkKSA6IHVuZGVmaW5lZCB9KSk7XG59XG5jb25zdCBNaW5pTWFwTm9kZSA9IG1lbW8oTWluaU1hcE5vZGVDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3Rvck5vZGVJZHMgPSAocykgPT4gcy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuY29uc3QgZ2V0QXR0ckZ1bmN0aW9uID0gKGZ1bmMpID0+IGZ1bmMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGZ1bmMgOiAoKSA9PiBmdW5jO1xuZnVuY3Rpb24gTWluaU1hcE5vZGVzKHsgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQgPSBNaW5pTWFwTm9kZSwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IG5vZGVJZHMgPSB1c2VTdG9yZShzZWxlY3Rvck5vZGVJZHMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IG5vZGVDb2xvckZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNvbG9yKTtcbiAgICBjb25zdCBub2RlU3Ryb2tlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVTdHJva2VDb2xvcik7XG4gICAgY29uc3Qgbm9kZUNsYXNzTmFtZUZ1bmMgPSBnZXRBdHRyRnVuY3Rpb24obm9kZUNsYXNzTmFtZSk7XG4gICAgY29uc3Qgc2hhcGVSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhIXdpbmRvdy5jaHJvbWUgPyAnY3Jpc3BFZGdlcycgOiAnZ2VvbWV0cmljUHJlY2lzaW9uJztcbiAgICByZXR1cm4gKGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogbm9kZUlkcy5tYXAoKG5vZGVJZCkgPT4gKFxuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgc3BsaXQgb2YgcmVzcG9uc2liaWxpdGllcyBiZXR3ZWVuIE1pbmlNYXBOb2RlcyBhbmRcbiAgICAgICAgICogTm9kZUNvbXBvbmVudFdyYXBwZXIgbWF5IGFwcGVhciB3ZWlyZC4gSG93ZXZlciwgaXTigJlzIGRlc2lnbmVkIHRvXG4gICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIGEgc2ltaWxhciBjb21taXQgaW4gYE5vZGVSZW5kZXJlci9pbmRleC50c3hgLlxuICAgICAgICAgKi9cbiAgICAgICAganN4KE5vZGVDb21wb25lbnRXcmFwcGVyLCB7IGlkOiBub2RlSWQsIG5vZGVDb2xvckZ1bmM6IG5vZGVDb2xvckZ1bmMsIG5vZGVTdHJva2VDb2xvckZ1bmM6IG5vZGVTdHJva2VDb2xvckZ1bmMsIG5vZGVDbGFzc05hbWVGdW5jOiBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIE5vZGVDb21wb25lbnQ6IE5vZGVDb21wb25lbnQsIG9uQ2xpY2s6IG9uQ2xpY2ssIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZyB9LCBub2RlSWQpKSkgfSkpO1xufVxuZnVuY3Rpb24gTm9kZUNvbXBvbmVudFdyYXBwZXJJbm5lcih7IGlkLCBub2RlQ29sb3JGdW5jLCBub2RlU3Ryb2tlQ29sb3JGdW5jLCBub2RlQ2xhc3NOYW1lRnVuYywgbm9kZUJvcmRlclJhZGl1cywgbm9kZVN0cm9rZVdpZHRoLCBzaGFwZVJlbmRlcmluZywgTm9kZUNvbXBvbmVudCwgb25DbGljaywgfSkge1xuICAgIGNvbnN0IHsgbm9kZSwgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdXNlU3RvcmUoKHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBpbnRlcm5hbHMgfSA9IHMubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICBjb25zdCBub2RlID0gaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaGlkZGVuIHx8ICFub2RlSGFzRGltZW5zaW9ucyhub2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goTm9kZUNvbXBvbmVudCwgeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZTogbm9kZS5zdHlsZSwgc2VsZWN0ZWQ6ICEhbm9kZS5zZWxlY3RlZCwgY2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lRnVuYyhub2RlKSwgY29sb3I6IG5vZGVDb2xvckZ1bmMobm9kZSksIGJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgc3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvckZ1bmMobm9kZSksIHN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljaywgaWQ6IG5vZGUuaWQgfSkpO1xufVxuY29uc3QgTm9kZUNvbXBvbmVudFdyYXBwZXIgPSBtZW1vKE5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIpO1xudmFyIE1pbmlNYXBOb2RlcyQxID0gbWVtbyhNaW5pTWFwTm9kZXMpO1xuXG5jb25zdCBkZWZhdWx0V2lkdGggPSAyMDA7XG5jb25zdCBkZWZhdWx0SGVpZ2h0ID0gMTUwO1xuY29uc3QgZmlsdGVySGlkZGVuID0gKG5vZGUpID0+ICFub2RlLmhpZGRlbjtcbmNvbnN0IHNlbGVjdG9yJDEgPSAocykgPT4ge1xuICAgIGNvbnN0IHZpZXdCQiA9IHtcbiAgICAgICAgeDogLXMudHJhbnNmb3JtWzBdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC1zLnRyYW5zZm9ybVsxXSAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICB3aWR0aDogcy53aWR0aCAvIHMudHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IHMuaGVpZ2h0IC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aWV3QkIsXG4gICAgICAgIGJvdW5kaW5nUmVjdDogcy5ub2RlTG9va3VwLnNpemUgPiAwXG4gICAgICAgICAgICA/IGdldEJvdW5kc09mUmVjdHMoZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhzLm5vZGVMb29rdXAsIHsgZmlsdGVyOiBmaWx0ZXJIaWRkZW4gfSksIHZpZXdCQilcbiAgICAgICAgICAgIDogdmlld0JCLFxuICAgICAgICByZklkOiBzLnJmSWQsXG4gICAgICAgIHBhblpvb206IHMucGFuWm9vbSxcbiAgICAgICAgdHJhbnNsYXRlRXh0ZW50OiBzLnRyYW5zbGF0ZUV4dGVudCxcbiAgICAgICAgZmxvd1dpZHRoOiBzLndpZHRoLFxuICAgICAgICBmbG93SGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgYXJpYUxhYmVsQ29uZmlnOiBzLmFyaWFMYWJlbENvbmZpZyxcbiAgICB9O1xufTtcbmNvbnN0IEFSSUFfTEFCRUxfS0VZID0gJ3JlYWN0LWZsb3dfX21pbmltYXAtZGVzYyc7XG5mdW5jdGlvbiBNaW5pTWFwQ29tcG9uZW50KHsgc3R5bGUsIGNsYXNzTmFtZSwgbm9kZVN0cm9rZUNvbG9yLCBub2RlQ29sb3IsIG5vZGVDbGFzc05hbWUgPSAnJywgbm9kZUJvcmRlclJhZGl1cyA9IDUsIG5vZGVTdHJva2VXaWR0aCwgXG4vKlxuICogV2UgbmVlZCB0byByZW5hbWUgdGhlIHByb3AgdG8gYmUgYENhcGl0YWxDYXNlYCBzbyB0aGF0IEpTWCB3aWxsIHJlbmRlciBpdCBhc1xuICogYSBjb21wb25lbnQgcHJvcGVybHkuXG4gKi9cbm5vZGVDb21wb25lbnQsIGJnQ29sb3IsIG1hc2tDb2xvciwgbWFza1N0cm9rZUNvbG9yLCBtYXNrU3Ryb2tlV2lkdGgsIHBvc2l0aW9uID0gJ2JvdHRvbS1yaWdodCcsIG9uQ2xpY2ssIG9uTm9kZUNsaWNrLCBwYW5uYWJsZSA9IGZhbHNlLCB6b29tYWJsZSA9IGZhbHNlLCBhcmlhTGFiZWwsIGludmVyc2VQYW4sIHpvb21TdGVwID0gMSwgb2Zmc2V0U2NhbGUgPSA1LCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN2ZyA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IGJvdW5kaW5nUmVjdCwgdmlld0JCLCByZklkLCBwYW5ab29tLCB0cmFuc2xhdGVFeHRlbnQsIGZsb3dXaWR0aCwgZmxvd0hlaWdodCwgYXJpYUxhYmVsQ29uZmlnIH0gPSB1c2VTdG9yZShzZWxlY3RvciQxLCBzaGFsbG93KTtcbiAgICBjb25zdCBlbGVtZW50V2lkdGggPSBzdHlsZT8ud2lkdGggPz8gZGVmYXVsdFdpZHRoO1xuICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBzdHlsZT8uaGVpZ2h0ID8/IGRlZmF1bHRIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggLyBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgdmlld1NjYWxlID0gTWF0aC5tYXgoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3Qgdmlld1dpZHRoID0gdmlld1NjYWxlICogZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHZpZXdIZWlnaHQgPSB2aWV3U2NhbGUgKiBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFNjYWxlICogdmlld1NjYWxlO1xuICAgIGNvbnN0IHggPSBib3VuZGluZ1JlY3QueCAtICh2aWV3V2lkdGggLSBib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB5ID0gYm91bmRpbmdSZWN0LnkgLSAodmlld0hlaWdodCAtIGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB3aWR0aCA9IHZpZXdXaWR0aCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdmlld0hlaWdodCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgbGFiZWxsZWRCeSA9IGAke0FSSUFfTEFCRUxfS0VZfS0ke3JmSWR9YDtcbiAgICBjb25zdCB2aWV3U2NhbGVSZWYgPSB1c2VSZWYoMCk7XG4gICAgY29uc3QgbWluaW1hcEluc3RhbmNlID0gdXNlUmVmKCk7XG4gICAgdmlld1NjYWxlUmVmLmN1cnJlbnQgPSB2aWV3U2NhbGU7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN2Zy5jdXJyZW50ICYmIHBhblpvb20pIHtcbiAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50ID0gWFlNaW5pbWFwKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBzdmcuY3VycmVudCxcbiAgICAgICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgZ2V0Vmlld1NjYWxlOiAoKSA9PiB2aWV3U2NhbGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtwYW5ab29tXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICB3aWR0aDogZmxvd1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBmbG93SGVpZ2h0LFxuICAgICAgICAgICAgaW52ZXJzZVBhbixcbiAgICAgICAgICAgIHBhbm5hYmxlLFxuICAgICAgICAgICAgem9vbVN0ZXAsXG4gICAgICAgICAgICB6b29tYWJsZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW3Bhbm5hYmxlLCB6b29tYWJsZSwgaW52ZXJzZVBhbiwgem9vbVN0ZXAsIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0XSk7XG4gICAgY29uc3Qgb25TdmdDbGljayA9IG9uQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5wb2ludGVyKGV2ZW50KSB8fCBbMCwgMF07XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TdmdOb2RlQ2xpY2sgPSBvbk5vZGVDbGlja1xuICAgICAgICA/IHVzZUNhbGxiYWNrKChldmVudCwgbm9kZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChub2RlSWQpLmludGVybmFscy51c2VyTm9kZTtcbiAgICAgICAgICAgIG9uTm9kZUNsaWNrKGV2ZW50LCBub2RlKTtcbiAgICAgICAgfSwgW10pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IF9hcmlhTGFiZWwgPSBhcmlhTGFiZWwgPz8gYXJpYUxhYmVsQ29uZmlnWydtaW5pbWFwLmFyaWFMYWJlbCddO1xuICAgIHJldHVybiAoanN4KFBhbmVsLCB7IHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIGJnQ29sb3IgPT09ICdzdHJpbmcnID8gYmdDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBtYXNrU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW1hc2stc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG1hc2tTdHJva2VXaWR0aCA9PT0gJ251bWJlcicgPyBtYXNrU3Ryb2tlV2lkdGggKiB2aWV3U2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtYmFja2dyb3VuZC1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS1jb2xvci1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnID8gbm9kZVN0cm9rZUNvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1ub2RlLXN0cm9rZS13aWR0aC1wcm9wcyc6IHR5cGVvZiBub2RlU3Ryb2tlV2lkdGggPT09ICdudW1iZXInID8gbm9kZVN0cm9rZVdpZHRoIDogdW5kZWZpbmVkLFxuICAgICAgICB9LCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbWluaW1hcCcsIGNsYXNzTmFtZV0pLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX21pbmltYXBcIiwgY2hpbGRyZW46IGpzeHMoXCJzdmdcIiwgeyB3aWR0aDogZWxlbWVudFdpZHRoLCBoZWlnaHQ6IGVsZW1lbnRIZWlnaHQsIHZpZXdCb3g6IGAke3h9ICR7eX0gJHt3aWR0aH0gJHtoZWlnaHR9YCwgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX21pbmltYXAtc3ZnXCIsIHJvbGU6IFwiaW1nXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGxhYmVsbGVkQnksIHJlZjogc3ZnLCBvbkNsaWNrOiBvblN2Z0NsaWNrLCBjaGlsZHJlbjogW19hcmlhTGFiZWwgJiYganN4KFwidGl0bGVcIiwgeyBpZDogbGFiZWxsZWRCeSwgY2hpbGRyZW46IF9hcmlhTGFiZWwgfSksIGpzeChNaW5pTWFwTm9kZXMkMSwgeyBvbkNsaWNrOiBvblN2Z05vZGVDbGljaywgbm9kZUNvbG9yOiBub2RlQ29sb3IsIG5vZGVTdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlQ2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgbm9kZUNvbXBvbmVudDogbm9kZUNvbXBvbmVudCB9KSwganN4KFwicGF0aFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLW1hc2tcIiwgZDogYE0ke3ggLSBvZmZzZXR9LCR7eSAtIG9mZnNldH1oJHt3aWR0aCArIG9mZnNldCAqIDJ9diR7aGVpZ2h0ICsgb2Zmc2V0ICogMn1oJHstd2lkdGggLSBvZmZzZXQgKiAyfXpcbiAgICAgICAgTSR7dmlld0JCLnh9LCR7dmlld0JCLnl9aCR7dmlld0JCLndpZHRofXYke3ZpZXdCQi5oZWlnaHR9aCR7LXZpZXdCQi53aWR0aH16YCwgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLCBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIiB9KV0gfSkgfSkpO1xufVxuTWluaU1hcENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdNaW5pTWFwJztcbi8qKlxuICogVGhlIGA8TWluaU1hcCAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIHJlbmRlciBhbiBvdmVydmlldyBvZiB5b3VyIGZsb3cuIEl0XG4gKiByZW5kZXJzIGVhY2ggbm9kZSBhcyBhbiBTVkcgZWxlbWVudCBhbmQgdmlzdWFsaXplcyB3aGVyZSB0aGUgY3VycmVudCB2aWV3cG9ydCBpc1xuICogaW4gcmVsYXRpb24gdG8gdGhlIHJlc3Qgb2YgdGhlIGZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBNaW5pTWFwIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXV19IGVkZ2VzPXtbLi4uXV19PlxuICogICAgICA8TWluaU1hcCBub2RlU3Ryb2tlV2lkdGg9ezN9IC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5jb25zdCBNaW5pTWFwID0gbWVtbyhNaW5pTWFwQ29tcG9uZW50KTtcblxuY29uc3Qgc2NhbGVTZWxlY3RvciA9IChjYWxjdWxhdGVTY2FsZSkgPT4gKHN0b3JlKSA9PiBjYWxjdWxhdGVTY2FsZSA/IGAke01hdGgubWF4KDEgLyBzdG9yZS50cmFuc2Zvcm1bMl0sIDEpfWAgOiB1bmRlZmluZWQ7XG5jb25zdCBkZWZhdWx0UG9zaXRpb25zID0ge1xuICAgIFtSZXNpemVDb250cm9sVmFyaWFudC5MaW5lXTogJ3JpZ2h0JyxcbiAgICBbUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlXTogJ2JvdHRvbS1yaWdodCcsXG59O1xuZnVuY3Rpb24gUmVzaXplQ29udHJvbCh7IG5vZGVJZCwgcG9zaXRpb24sIHZhcmlhbnQgPSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGUsIGNsYXNzTmFtZSwgc3R5bGUgPSB1bmRlZmluZWQsIGNoaWxkcmVuLCBjb2xvciwgbWluV2lkdGggPSAxMCwgbWluSGVpZ2h0ID0gMTAsIG1heFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRSwgbWF4SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRSwga2VlcEFzcGVjdFJhdGlvID0gZmFsc2UsIHJlc2l6ZURpcmVjdGlvbiwgYXV0b1NjYWxlID0gdHJ1ZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgaWQgPSB0eXBlb2Ygbm9kZUlkID09PSAnc3RyaW5nJyA/IG5vZGVJZCA6IGNvbnRleHROb2RlSWQ7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHJlc2l6ZUNvbnRyb2xSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaXNIYW5kbGVDb250cm9sID0gdmFyaWFudCA9PT0gUmVzaXplQ29udHJvbFZhcmlhbnQuSGFuZGxlO1xuICAgIGNvbnN0IHNjYWxlID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soc2NhbGVTZWxlY3Rvcihpc0hhbmRsZUNvbnRyb2wgJiYgYXV0b1NjYWxlKSwgW2lzSGFuZGxlQ29udHJvbCwgYXV0b1NjYWxlXSksIHNoYWxsb3cpO1xuICAgIGNvbnN0IHJlc2l6ZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY29udHJvbFBvc2l0aW9uID0gcG9zaXRpb24gPz8gZGVmYXVsdFBvc2l0aW9uc1t2YXJpYW50XTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCB8fCAhaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZXIuY3VycmVudCkge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50ID0gWFlSZXNpemVyKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiByZXNpemVDb250cm9sUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZURvbU5vZGU6IGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiBjaGFuZ2UueCwgeTogY2hhbmdlLnkgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY2hhbmdlLndpZHRoID8/IG5vZGUubWVhc3VyZWQud2lkdGggPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGNoYW5nZS5oZWlnaHQgPz8gbm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoYW5nZS54ID8/IG5vZGUucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoYW5nZS55ID8/IG5vZGUucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyB3aWR0aCwgaGVpZ2h0IH0sIG5vZGUucGFyZW50SWQsIG5vZGVMb29rdXAsIG9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KFtjaGlsZF0sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2hlbiB0aGUgcGFyZW50IHdhcyBleHBhbmRlZCBieSB0aGUgY2hpbGQgbm9kZSwgaXRzIHBvc2l0aW9uIHdpbGwgYmUgY2xhbXBlZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogMCwwIHdoZW4gbm9kZSBvcmlnaW4gaXMgMCwwIGFuZCB0byB3aWR0aCwgaGVpZ2h0IGlmIGl0J3MgMSwxXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi54ID0gY2hhbmdlLnggPyBNYXRoLm1heChvcmlnaW5bMF0gKiB3aWR0aCwgY2hhbmdlLngpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnkgPSBjaGFuZ2UueSA/IE1hdGgubWF4KG9yaWdpblsxXSAqIGhlaWdodCwgY2hhbmdlLnkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIG5leHRQb3NpdGlvbi55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4ubmV4dFBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLndpZHRoICE9PSB1bmRlZmluZWQgJiYgY2hhbmdlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXRBdHRyaWJ1dGVzID0gIXJlc2l6ZURpcmVjdGlvbiA/IHRydWUgOiByZXNpemVEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXppbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjaGFuZ2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2hhbmdlLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChkaW1lbnNpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRDaGFuZ2Ugb2YgY2hpbGRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChwb3NpdGlvbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25FbmQ6ICh7IHdpZHRoLCBoZWlnaHQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS50cmlnZ2VyTm9kZUNoYW5nZXMoW2RpbWVuc2lvbkNoYW5nZV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNpemVyLmN1cnJlbnQudXBkYXRlKHtcbiAgICAgICAgICAgIGNvbnRyb2xQb3NpdGlvbixcbiAgICAgICAgICAgIGJvdW5kYXJpZXM6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIHJlc2l6ZURpcmVjdGlvbixcbiAgICAgICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZXIuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgIG9uUmVzaXplLFxuICAgICAgICBvblJlc2l6ZUVuZCxcbiAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgIF0pO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NOYW1lcyA9IGNvbnRyb2xQb3NpdGlvbi5zcGxpdCgnLScpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3Jlc2l6ZS1jb250cm9sJywgJ25vZHJhZycsIC4uLnBvc2l0aW9uQ2xhc3NOYW1lcywgdmFyaWFudCwgY2xhc3NOYW1lXSksIHJlZjogcmVzaXplQ29udHJvbFJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgICAgICAuLi4oY29sb3IgJiYgeyBbaXNIYW5kbGVDb250cm9sID8gJ2JhY2tncm91bmRDb2xvcicgOiAnYm9yZGVyQ29sb3InXTogY29sb3IgfSksXG4gICAgICAgIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG4vKipcbiAqIFRvIGNyZWF0ZSB5b3VyIG93biByZXNpemluZyBVSSwgeW91IGNhbiB1c2UgdGhlIGBOb2RlUmVzaXplQ29udHJvbGAgY29tcG9uZW50IHdoZXJlIHlvdSBjYW4gcGFzcyBjaGlsZHJlbiAoc3VjaCBhcyBpY29ucykuXG4gKiBAcHVibGljXG4gKlxuICovXG5jb25zdCBOb2RlUmVzaXplQ29udHJvbCA9IG1lbW8oUmVzaXplQ29udHJvbCk7XG5cbi8qKlxuICogVGhlIGA8Tm9kZVJlc2l6ZXIgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBhZGQgYSByZXNpemUgZnVuY3Rpb25hbGl0eSB0byB5b3VyXG4gKiBub2Rlcy4gSXQgcmVuZGVycyBkcmFnZ2FibGUgY29udHJvbHMgYXJvdW5kIHRoZSBub2RlIHRvIHJlc2l6ZSBpbiBhbGwgZGlyZWN0aW9ucy5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVJlc2l6ZXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFJlc2l6YWJsZU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVSZXNpemVyIG1pbldpZHRoPXsxMDB9IG1pbkhlaWdodD17MzB9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6IDEwIH19PntkYXRhLmxhYmVsfTwvZGl2PlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhSZXNpemFibGVOb2RlKTtcbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIE5vZGVSZXNpemVyKHsgbm9kZUlkLCBpc1Zpc2libGUgPSB0cnVlLCBoYW5kbGVDbGFzc05hbWUsIGhhbmRsZVN0eWxlLCBsaW5lQ2xhc3NOYW1lLCBsaW5lU3R5bGUsIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgYXV0b1NjYWxlID0gdHJ1ZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUy5tYXAoKHBvc2l0aW9uKSA9PiAoanN4KE5vZGVSZXNpemVDb250cm9sLCB7IGNsYXNzTmFtZTogbGluZUNsYXNzTmFtZSwgc3R5bGU6IGxpbmVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgdmFyaWFudDogUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZSwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgYXV0b1NjYWxlOiBhdXRvU2NhbGUsIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKSwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLm1hcCgocG9zaXRpb24pID0+IChqc3goTm9kZVJlc2l6ZUNvbnRyb2wsIHsgY2xhc3NOYW1lOiBoYW5kbGVDbGFzc05hbWUsIHN0eWxlOiBoYW5kbGVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgYXV0b1NjYWxlOiBhdXRvU2NhbGUsIHNob3VsZFJlc2l6ZTogc2hvdWxkUmVzaXplLCBvblJlc2l6ZTogb25SZXNpemUsIG9uUmVzaXplRW5kOiBvblJlc2l6ZUVuZCB9LCBwb3NpdGlvbikpKV0gfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUuZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3JlbmRlcmVyJyk7XG5mdW5jdGlvbiBOb2RlVG9vbGJhclBvcnRhbCh7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCB3cmFwcGVyUmVmID0gdXNlU3RvcmUoc2VsZWN0b3IpO1xuICAgIGlmICghd3JhcHBlclJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgd3JhcHBlclJlZik7XG59XG5cbmNvbnN0IG5vZGVFcXVhbGl0eUZuID0gKGEsIGIpID0+IGE/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggIT09IGI/LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggfHxcbiAgICBhPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55ICE9PSBiPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IHx8XG4gICAgYT8ubWVhc3VyZWQud2lkdGggIT09IGI/Lm1lYXN1cmVkLndpZHRoIHx8XG4gICAgYT8ubWVhc3VyZWQuaGVpZ2h0ICE9PSBiPy5tZWFzdXJlZC5oZWlnaHQgfHxcbiAgICBhPy5zZWxlY3RlZCAhPT0gYj8uc2VsZWN0ZWQgfHxcbiAgICBhPy5pbnRlcm5hbHMueiAhPT0gYj8uaW50ZXJuYWxzLno7XG5jb25zdCBub2Rlc0VxdWFsaXR5Rm4gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgYSkge1xuICAgICAgICBpZiAobm9kZUVxdWFsaXR5Rm4obm9kZSwgYi5nZXQoa2V5KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBzdG9yZVNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxuICAgIHNlbGVjdGVkTm9kZXNDb3VudDogc3RhdGUubm9kZXMuZmlsdGVyKChub2RlKSA9PiBub2RlLnNlbGVjdGVkKS5sZW5ndGgsXG59KTtcbi8qKlxuICogVGhpcyBjb21wb25lbnQgY2FuIHJlbmRlciBhIHRvb2xiYXIgb3IgdG9vbHRpcCB0byBvbmUgc2lkZSBvZiBhIGN1c3RvbSBub2RlLiBUaGlzXG4gKiB0b29sYmFyIGRvZXNuJ3Qgc2NhbGUgd2l0aCB0aGUgdmlld3BvcnQgc28gdGhhdCB0aGUgY29udGVudCBpcyBhbHdheXMgdmlzaWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IG1lbW8gfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgUG9zaXRpb24sIE5vZGVUb29sYmFyIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBDdXN0b21Ob2RlKHsgZGF0YSB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxOb2RlVG9vbGJhciBpc1Zpc2libGU9e2RhdGEudG9vbGJhclZpc2libGV9IHBvc2l0aW9uPXtkYXRhLnRvb2xiYXJQb3NpdGlvbn0+XG4gKiAgICAgICAgPGJ1dHRvbj5kZWxldGU8L2J1dHRvbj5cbiAqICAgICAgICA8YnV0dG9uPmNvcHk8L2J1dHRvbj5cbiAqICAgICAgICA8YnV0dG9uPmV4cGFuZDwvYnV0dG9uPlxuICogICAgICA8L05vZGVUb29sYmFyPlxuICpcbiAqICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCAyMHB4JyB9fT5cbiAqICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgPC9kaXY+XG4gKlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJ0YXJnZXRcIiBwb3NpdGlvbj17UG9zaXRpb24uTGVmdH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwic291cmNlXCIgcG9zaXRpb249e1Bvc2l0aW9uLlJpZ2h0fSAvPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IG1lbW8oQ3VzdG9tTm9kZSk7XG4gKmBgYFxuICogQHJlbWFya3MgQnkgZGVmYXVsdCwgdGhlIHRvb2xiYXIgaXMgb25seSB2aXNpYmxlIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkLiBJZiBtdWx0aXBsZVxuICogbm9kZXMgYXJlIHNlbGVjdGVkIGl0IHdpbGwgbm90IGJlIHZpc2libGUgdG8gcHJldmVudCBvdmVybGFwcGluZyB0b29sYmFycyBvclxuICogY2x1dHRlci4gWW91IGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIGJ5IHNldHRpbmcgdGhlIGBpc1Zpc2libGVgIHByb3AgdG8gYHRydWVgLlxuICovXG5mdW5jdGlvbiBOb2RlVG9vbGJhcih7IG5vZGVJZCwgY2hpbGRyZW4sIGNsYXNzTmFtZSwgc3R5bGUsIGlzVmlzaWJsZSwgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIG9mZnNldCA9IDEwLCBhbGlnbiA9ICdjZW50ZXInLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3Qgbm9kZXNTZWxlY3RvciA9IHVzZUNhbGxiYWNrKChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBub2RlSWRzID0gQXJyYXkuaXNBcnJheShub2RlSWQpID8gbm9kZUlkIDogW25vZGVJZCB8fCBjb250ZXh0Tm9kZUlkIHx8ICcnXTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlcyA9IG5vZGVJZHMucmVkdWNlKChyZXMsIGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RhdGUubm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgbmV3IE1hcCgpKTtcbiAgICAgICAgcmV0dXJuIGludGVybmFsTm9kZXM7XG4gICAgfSwgW25vZGVJZCwgY29udGV4dE5vZGVJZF0pO1xuICAgIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUobm9kZXNTZWxlY3Rvciwgbm9kZXNFcXVhbGl0eUZuKTtcbiAgICBjb25zdCB7IHgsIHksIHpvb20sIHNlbGVjdGVkTm9kZXNDb3VudCB9ID0gdXNlU3RvcmUoc3RvcmVTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgLy8gaWYgaXNWaXNpYmxlIGlzIG5vdCBzZXQsIHdlIHNob3cgdGhlIHRvb2xiYXIgb25seSBpZiBpdHMgbm9kZSBpcyBzZWxlY3RlZCBhbmQgbm8gb3RoZXIgbm9kZSBpcyBzZWxlY3RlZFxuICAgIGNvbnN0IGlzQWN0aXZlID0gdHlwZW9mIGlzVmlzaWJsZSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgID8gaXNWaXNpYmxlXG4gICAgICAgIDogbm9kZXMuc2l6ZSA9PT0gMSAmJiBub2Rlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU/LnNlbGVjdGVkICYmIHNlbGVjdGVkTm9kZXNDb3VudCA9PT0gMTtcbiAgICBpZiAoIWlzQWN0aXZlIHx8ICFub2Rlcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlUmVjdCA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZXMpO1xuICAgIGNvbnN0IG5vZGVzQXJyYXkgPSBBcnJheS5mcm9tKG5vZGVzLnZhbHVlcygpKTtcbiAgICBjb25zdCB6SW5kZXggPSBNYXRoLm1heCguLi5ub2Rlc0FycmF5Lm1hcCgobm9kZSkgPT4gbm9kZS5pbnRlcm5hbHMueiArIDEpKTtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0cmFuc2Zvcm06IGdldE5vZGVUb29sYmFyVHJhbnNmb3JtKG5vZGVSZWN0LCB7IHgsIHksIHpvb20gfSwgcG9zaXRpb24sIG9mZnNldCwgYWxpZ24pLFxuICAgICAgICB6SW5kZXgsXG4gICAgICAgIC4uLnN0eWxlLFxuICAgIH07XG4gICAgcmV0dXJuIChqc3goTm9kZVRvb2xiYXJQb3J0YWwsIHsgY2hpbGRyZW46IGpzeChcImRpdlwiLCB7IHN0eWxlOiB3cmFwcGVyU3R5bGUsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19ub2RlLXRvb2xiYXInLCBjbGFzc05hbWVdKSwgLi4ucmVzdCwgXCJkYXRhLWlkXCI6IG5vZGVzQXJyYXkucmVkdWNlKChhY2MsIG5vZGUpID0+IGAke2FjY30ke25vZGUuaWR9IGAsICcnKS50cmltKCksIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmNvbnN0IHpvb21TZWxlY3RvciA9IChzdGF0ZSkgPT4gc3RhdGUudHJhbnNmb3JtWzJdO1xuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjYW4gcmVuZGVyIGEgdG9vbGJhciBvciB0b29sdGlwIHRvIG9uZSBzaWRlIG9mIGEgY3VzdG9tIGVkZ2UuIFRoaXNcbiAqIHRvb2xiYXIgZG9lc24ndCBzY2FsZSB3aXRoIHRoZSB2aWV3cG9ydCBzbyB0aGF0IHRoZSBjb250ZW50IHN0YXlzIHRoZSBzYW1lIHNpemUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgRWRnZVRvb2xiYXIsIEJhc2VFZGdlLCBnZXRCZXppZXJQYXRoLCB0eXBlIEVkZ2VQcm9wcyB9IGZyb20gXCJAeHlmbG93L3JlYWN0XCI7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbUVkZ2UoeyBpZCwgZGF0YSwgLi4ucHJvcHMgfTogRWRnZVByb3BzKSB7XG4gKiAgIGNvbnN0IFtlZGdlUGF0aCwgY2VudGVyWCwgY2VudGVyWV0gPSBnZXRCZXppZXJQYXRoKHByb3BzKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPD5cbiAqICAgICAgIDxCYXNlRWRnZSBpZD17aWR9IHBhdGg9e2VkZ2VQYXRofSAvPlxuICogICAgICAgPEVkZ2VUb29sYmFyIGVkZ2VJZD17aWR9IHg9e2NlbnRlclh9IHk9e2NlbnRlcll9IGlzVmlzaWJsZT5cbiAqICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBjb25zb2xlLmxvZygnZWRnZScsIGlkLCAnY2xpY2snKX19PkNsaWNrIG1lPC9idXR0b24+XG4gKiAgICAgICA8L0VkZ2VUb29sYmFyPlxuICogICAgIDwvPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIEVkZ2VUb29sYmFyKHsgZWRnZUlkLCB4LCB5LCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgaXNWaXNpYmxlLCBhbGlnblggPSAnY2VudGVyJywgYWxpZ25ZID0gJ2NlbnRlcicsIC4uLnJlc3QgfSkge1xuICAgIGNvbnN0IGVkZ2VTZWxlY3RvciA9IHVzZUNhbGxiYWNrKChzdGF0ZSkgPT4gc3RhdGUuZWRnZUxvb2t1cC5nZXQoZWRnZUlkKSwgW2VkZ2VJZF0pO1xuICAgIGNvbnN0IGVkZ2UgPSB1c2VTdG9yZShlZGdlU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdHlwZW9mIGlzVmlzaWJsZSA9PT0gJ2Jvb2xlYW4nID8gaXNWaXNpYmxlIDogZWRnZT8uc2VsZWN0ZWQ7XG4gICAgY29uc3Qgem9vbSA9IHVzZVN0b3JlKHpvb21TZWxlY3Rvcik7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgekluZGV4ID0gKGVkZ2U/LnpJbmRleCA/PyAwKSArIDE7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gZ2V0RWRnZVRvb2xiYXJUcmFuc2Zvcm0oeCwgeSwgem9vbSwgYWxpZ25YLCBhbGlnblkpO1xuICAgIHJldHVybiAoanN4KEVkZ2VMYWJlbFJlbmRlcmVyLCB7IGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICB6SW5kZXgsXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ2FsbCcsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnMCAwJyxcbiAgICAgICAgICAgICAgICAuLi5zdHlsZSxcbiAgICAgICAgICAgIH0sIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19lZGdlLXRvb2xiYXInLCBjbGFzc05hbWVdKSwgXCJkYXRhLWlkXCI6IGVkZ2U/LmlkID8/ICcnLCAuLi5yZXN0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCwgQmFzZUVkZ2UsIEJlemllckVkZ2UsIENvbnRyb2xCdXR0b24sIENvbnRyb2xzLCBFZGdlTGFiZWxSZW5kZXJlciwgRWRnZVRleHQsIEVkZ2VUb29sYmFyLCBIYW5kbGUsIE1pbmlNYXAsIE1pbmlNYXBOb2RlLCBOb2RlUmVzaXplQ29udHJvbCwgTm9kZVJlc2l6ZXIsIE5vZGVUb29sYmFyLCBQYW5lbCwgaW5kZXggYXMgUmVhY3RGbG93LCBSZWFjdEZsb3dQcm92aWRlciwgU2ltcGxlQmV6aWVyRWRnZSwgU21vb3RoU3RlcEVkZ2UsIFN0ZXBFZGdlLCBTdHJhaWdodEVkZ2UsIFZpZXdwb3J0UG9ydGFsLCBhcHBseUVkZ2VDaGFuZ2VzLCBhcHBseU5vZGVDaGFuZ2VzLCBleHBlcmltZW50YWxfdXNlT25FZGdlc0NoYW5nZU1pZGRsZXdhcmUsIGV4cGVyaW1lbnRhbF91c2VPbk5vZGVzQ2hhbmdlTWlkZGxld2FyZSwgZ2V0U2ltcGxlQmV6aWVyUGF0aCwgaXNFZGdlLCBpc05vZGUsIHVzZUNvbm5lY3Rpb24sIHVzZUVkZ2VzLCB1c2VFZGdlc1N0YXRlLCB1c2VIYW5kbGVDb25uZWN0aW9ucywgdXNlSW50ZXJuYWxOb2RlLCB1c2VLZXlQcmVzcywgdXNlTm9kZUNvbm5lY3Rpb25zLCB1c2VOb2RlSWQsIHVzZU5vZGVzLCB1c2VOb2Rlc0RhdGEsIHVzZU5vZGVzSW5pdGlhbGl6ZWQsIHVzZU5vZGVzU3RhdGUsIHVzZU9uU2VsZWN0aW9uQ2hhbmdlLCB1c2VPblZpZXdwb3J0Q2hhbmdlLCB1c2VSZWFjdEZsb3csIHVzZVN0b3JlLCB1c2VTdG9yZUFwaSwgdXNlVXBkYXRlTm9kZUludGVybmFscywgdXNlVmlld3BvcnQgfTtcbiJdLCJuYW1lcyI6WyJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJmb3J3YXJkUmVmIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIm1lbW8iLCJjYyIsImVycm9yTWVzc2FnZXMiLCJtZXJnZUFyaWFMYWJlbENvbmZpZyIsImluZmluaXRlRXh0ZW50IiwiaXNJbnB1dERPTU5vZGUiLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInBvaW50VG9SZW5kZXJlclBvaW50IiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJpc05vZGVCYXNlIiwiaXNFZGdlQmFzZSIsImdldEVsZW1lbnRzVG9SZW1vdmUiLCJpc1JlY3RPYmplY3QiLCJub2RlVG9SZWN0IiwiZ2V0T3ZlcmxhcHBpbmdBcmVhIiwiZ2V0Tm9kZXNCb3VuZHMiLCJ3aXRoUmVzb2x2ZXJzIiwiZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uIiwiZ2V0RGltZW5zaW9ucyIsIlhZUGFuWm9vbSIsIlBhbk9uU2Nyb2xsTW9kZSIsIlNlbGVjdGlvbk1vZGUiLCJnZXRFdmVudFBvc2l0aW9uIiwiZ2V0Tm9kZXNJbnNpZGUiLCJhcmVTZXRzRXF1YWwiLCJYWURyYWciLCJzbmFwUG9zaXRpb24iLCJjYWxjdWxhdGVOb2RlUG9zaXRpb24iLCJQb3NpdGlvbiIsIkNvbm5lY3Rpb25Nb2RlIiwiaXNNb3VzZUV2ZW50IiwiWFlIYW5kbGUiLCJnZXRIb3N0Rm9yRWxlbWVudCIsImFkZEVkZ2UiLCJnZXRJbnRlcm5hbE5vZGVzQm91bmRzIiwiaXNOdW1lcmljIiwibm9kZUhhc0RpbWVuc2lvbnMiLCJnZXROb2RlRGltZW5zaW9ucyIsImVsZW1lbnRTZWxlY3Rpb25LZXlzIiwiaXNFZGdlVmlzaWJsZSIsIk1hcmtlclR5cGUiLCJjcmVhdGVNYXJrZXJJZHMiLCJnZXRCZXppZXJFZGdlQ2VudGVyIiwiZ2V0U21vb3RoU3RlcFBhdGgiLCJnZXRTdHJhaWdodFBhdGgiLCJnZXRCZXppZXJQYXRoIiwiZ2V0RWRnZVBvc2l0aW9uIiwiZ2V0RWxldmF0ZWRFZGdlWkluZGV4IiwiZ2V0TWFya2VySWQiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwiQ29ubmVjdGlvbkxpbmVUeXBlIiwidXBkYXRlQ29ubmVjdGlvbkxvb2t1cCIsImFkb3B0VXNlck5vZGVzIiwiaW5pdGlhbENvbm5lY3Rpb24iLCJkZXZXYXJuIiwiZGVmYXVsdEFyaWFMYWJlbENvbmZpZyIsInVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyIsImdldEhhbmRsZVBvc2l0aW9uIiwiaGFuZGxlRXhwYW5kUGFyZW50IiwicGFuQnkiLCJmaXRWaWV3cG9ydCIsImlzTWFjT3MiLCJhcmVDb25uZWN0aW9uTWFwc0VxdWFsIiwiaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSIsInNoYWxsb3dOb2RlRGF0YSIsIlhZTWluaW1hcCIsImdldEJvdW5kc09mUmVjdHMiLCJSZXNpemVDb250cm9sVmFyaWFudCIsIlhZUmVzaXplciIsIlhZX1JFU0laRVJfTElORV9QT1NJVElPTlMiLCJYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMiLCJnZXROb2RlVG9vbGJhclRyYW5zZm9ybSIsImdldEVkZ2VUb29sYmFyVHJhbnNmb3JtIiwiZ2V0Q29ubmVjdGVkRWRnZXMiLCJnZXRFZGdlQ2VudGVyIiwiZ2V0SW5jb21lcnMiLCJnZXRPdXRnb2VycyIsInJlY29ubmVjdEVkZ2UiLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93IiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsInN0eWxlIiwiZGlzcGxheSIsImFyaWFMaXZlU3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJhcmlhTGl2ZVNlbGVjdG9yIiwicyIsImFyaWFMaXZlTWVzc2FnZSIsImFyaWFMYWJlbENvbmZpZ1NlbGVjdG9yIiwiYXJpYUxhYmVsQ29uZmlnIiwiQXJpYUxpdmVNZXNzYWdlIiwicmZJZCIsImlkIiwiY2hpbGRyZW4iLCJBMTF5RGVzY3JpcHRpb25zIiwiZGlzYWJsZUtleWJvYXJkQTExeSIsIlBhbmVsIiwiY2xhc3NOYW1lIiwicmVzdCIsInJlZiIsInBvc2l0aW9uQ2xhc3NlcyIsInNwbGl0IiwiZGlzcGxheU5hbWUiLCJBdHRyaWJ1dGlvbiIsInByb09wdGlvbnMiLCJoaWRlQXR0cmlidXRpb24iLCJocmVmIiwidGFyZ2V0IiwicmVsIiwic2VsZWN0b3IkbSIsInNlbGVjdGVkTm9kZXMiLCJzZWxlY3RlZEVkZ2VzIiwibm9kZSIsIm5vZGVMb29rdXAiLCJzZWxlY3RlZCIsInB1c2giLCJpbnRlcm5hbHMiLCJ1c2VyTm9kZSIsImVkZ2UiLCJlZGdlTG9va3VwIiwic2VsZWN0SWQiLCJvYmoiLCJhcmVFcXVhbCIsImEiLCJiIiwibWFwIiwiU2VsZWN0aW9uTGlzdGVuZXJJbm5lciIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwicGFyYW1zIiwibm9kZXMiLCJlZGdlcyIsIm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJmb3JFYWNoIiwiZm4iLCJjaGFuZ2VTZWxlY3RvciIsIlNlbGVjdGlvbkxpc3RlbmVyIiwic3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyIsImRlZmF1bHROb2RlT3JpZ2luIiwiZGVmYXVsdFZpZXdwb3J0IiwieCIsInkiLCJ6b29tIiwicmVhY3RGbG93RmllbGRzVG9UcmFjayIsImZpZWxkc1RvVHJhY2siLCJzZWxlY3RvciRsIiwic2V0Tm9kZXMiLCJzZXRFZGdlcyIsInNldE1pblpvb20iLCJzZXRNYXhab29tIiwic2V0VHJhbnNsYXRlRXh0ZW50Iiwic2V0Tm9kZUV4dGVudCIsInJlc2V0Iiwic2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMiLCJpbml0UHJldlZhbHVlcyIsInRyYW5zbGF0ZUV4dGVudCIsIm5vZGVPcmlnaW4iLCJtaW5ab29tIiwibWF4Wm9vbSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsIm5vUGFuQ2xhc3NOYW1lIiwiU3RvcmVVcGRhdGVyIiwicHJvcHMiLCJkZWZhdWx0Tm9kZXMiLCJkZWZhdWx0RWRnZXMiLCJwcmV2aW91c0ZpZWxkcyIsImN1cnJlbnQiLCJmaWVsZE5hbWUiLCJmaWVsZFZhbHVlIiwicHJldmlvdXNGaWVsZFZhbHVlIiwiZml0Vmlld1F1ZXVlZCIsImZpdFZpZXdPcHRpb25zIiwiZ2V0TWVkaWFRdWVyeSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJ1c2VDb2xvck1vZGVDbGFzcyIsImNvbG9yTW9kZSIsImNvbG9yTW9kZUNsYXNzIiwic2V0Q29sb3JNb2RlQ2xhc3MiLCJtZWRpYVF1ZXJ5IiwidXBkYXRlQ29sb3JNb2RlQ2xhc3MiLCJtYXRjaGVzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZWZhdWx0RG9jIiwiZG9jdW1lbnQiLCJ1c2VLZXlQcmVzcyIsImtleUNvZGUiLCJvcHRpb25zIiwiYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIiLCJrZXlQcmVzc2VkIiwic2V0S2V5UHJlc3NlZCIsIm1vZGlmaWVyUHJlc3NlZCIsInByZXNzZWRLZXlzIiwiU2V0Iiwia2V5Q29kZXMiLCJrZXlzVG9XYXRjaCIsImtleUNvZGVBcnIiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwiZmlsdGVyIiwia2MiLCJyZXBsYWNlIiwia2V5c0ZsYXQiLCJyZWR1Y2UiLCJyZXMiLCJpdGVtIiwiY29uY2F0IiwiZG93bkhhbmRsZXIiLCJldmVudCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJwcmV2ZW50QWN0aW9uIiwia2V5T3JDb2RlIiwidXNlS2V5T3JDb2RlIiwiY29kZSIsImFkZCIsImlzTWF0Y2hpbmdLZXkiLCJjb21wb3NlZFBhdGgiLCJpc0ludGVyYWN0aXZlRWxlbWVudCIsIm5vZGVOYW1lIiwicHJldmVudERlZmF1bHQiLCJ1cEhhbmRsZXIiLCJjbGVhciIsImRlbGV0ZSIsImtleSIsInJlc2V0SGFuZGxlciIsImlzVXAiLCJsZW5ndGgiLCJzaXplIiwic29tZSIsImV2ZXJ5IiwiayIsImhhcyIsImV2ZW50Q29kZSIsImluY2x1ZGVzIiwidXNlVmlld3BvcnRIZWxwZXIiLCJ6b29tSW4iLCJwYW5ab29tIiwic2NhbGVCeSIsImR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ6b29tT3V0Iiwiem9vbVRvIiwiem9vbUxldmVsIiwic2NhbGVUbyIsImdldFpvb20iLCJ0cmFuc2Zvcm0iLCJzZXRWaWV3cG9ydCIsInZpZXdwb3J0IiwidFgiLCJ0WSIsInRab29tIiwiZ2V0Vmlld3BvcnQiLCJzZXRDZW50ZXIiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJlYXNlIiwiaW50ZXJwb2xhdGUiLCJzY3JlZW5Ub0Zsb3dQb3NpdGlvbiIsImNsaWVudFBvc2l0aW9uIiwic25hcEdyaWQiLCJzbmFwVG9HcmlkIiwiZG9tTm9kZSIsImRvbVgiLCJkb21ZIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY29ycmVjdGVkUG9zaXRpb24iLCJfc25hcEdyaWQiLCJfc25hcFRvR3JpZCIsImZsb3dUb1NjcmVlblBvc2l0aW9uIiwiZmxvd1Bvc2l0aW9uIiwicmVuZGVyZXJQb3NpdGlvbiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJlbGVtZW50cyIsInVwZGF0ZWRFbGVtZW50cyIsImNoYW5nZXNNYXAiLCJNYXAiLCJhZGRJdGVtQ2hhbmdlcyIsImNoYW5nZSIsInR5cGUiLCJzZXQiLCJlbGVtZW50Q2hhbmdlcyIsImdldCIsImVsZW1lbnQiLCJ1cGRhdGVkRWxlbWVudCIsImFwcGx5Q2hhbmdlIiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJzcGxpY2UiLCJkcmFnZ2luZyIsImRpbWVuc2lvbnMiLCJtZWFzdXJlZCIsInNldEF0dHJpYnV0ZXMiLCJyZXNpemluZyIsImFwcGx5Tm9kZUNoYW5nZXMiLCJhcHBseUVkZ2VDaGFuZ2VzIiwiY3JlYXRlU2VsZWN0aW9uQ2hhbmdlIiwiZ2V0U2VsZWN0aW9uQ2hhbmdlcyIsIml0ZW1zIiwic2VsZWN0ZWRJZHMiLCJtdXRhdGVJdGVtIiwid2lsbEJlU2VsZWN0ZWQiLCJnZXRFbGVtZW50c0RpZmZDaGFuZ2VzIiwibG9va3VwIiwiaXRlbXNMb29rdXAiLCJlbnRyaWVzIiwibG9va3VwSXRlbSIsInN0b3JlSXRlbSIsIm5leHROb2RlIiwiZWxlbWVudFRvUmVtb3ZlQ2hhbmdlIiwiaXNOb2RlIiwiaXNFZGdlIiwiZml4ZWRGb3J3YXJkUmVmIiwicmVuZGVyIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsInVzZVF1ZXVlIiwicnVuUXVldWUiLCJzZXJpYWwiLCJzZXRTZXJpYWwiLCJCaWdJbnQiLCJxdWV1ZSIsImNyZWF0ZVF1ZXVlIiwibiIsInF1ZXVlSXRlbXMiLCJjYiIsIkJhdGNoQ29udGV4dCIsIkJhdGNoUHJvdmlkZXIiLCJub2RlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdE5vZGVzIiwib25Ob2Rlc0NoYW5nZSIsIm9uTm9kZXNDaGFuZ2VNaWRkbGV3YXJlTWFwIiwibmV4dCIsInBheWxvYWQiLCJtaWRkbGV3YXJlIiwidmFsdWVzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibm9kZVF1ZXVlIiwiZWRnZVF1ZXVlSGFuZGxlciIsImhhc0RlZmF1bHRFZGdlcyIsIm9uRWRnZXNDaGFuZ2UiLCJlZGdlUXVldWUiLCJ2YWx1ZSIsInVzZUJhdGNoQ29udGV4dCIsImJhdGNoQ29udGV4dCIsInNlbGVjdG9yJGsiLCJ1c2VSZWFjdEZsb3ciLCJ2aWV3cG9ydEhlbHBlciIsInZpZXdwb3J0SW5pdGlhbGl6ZWQiLCJnZW5lcmFsSGVscGVyIiwiZ2V0SW50ZXJuYWxOb2RlIiwiZ2V0Tm9kZVJlY3QiLCJub2RlVG9Vc2UiLCJwYXJlbnRJZCIsIm5vZGVXaXRoUG9zaXRpb24iLCJ1cGRhdGVOb2RlIiwibm9kZVVwZGF0ZSIsInByZXZOb2RlcyIsInVwZGF0ZUVkZ2UiLCJlZGdlVXBkYXRlIiwicHJldkVkZ2VzIiwibmV4dEVkZ2UiLCJnZXROb2RlcyIsImdldE5vZGUiLCJnZXRFZGdlcyIsImUiLCJnZXRFZGdlIiwiYWRkTm9kZXMiLCJuZXdOb2RlcyIsImFkZEVkZ2VzIiwibmV3RWRnZXMiLCJ0b09iamVjdCIsImRlbGV0ZUVsZW1lbnRzIiwibm9kZXNUb1JlbW92ZSIsImVkZ2VzVG9SZW1vdmUiLCJvbk5vZGVzRGVsZXRlIiwib25FZGdlc0RlbGV0ZSIsInRyaWdnZXJOb2RlQ2hhbmdlcyIsInRyaWdnZXJFZGdlQ2hhbmdlcyIsIm9uRGVsZXRlIiwib25CZWZvcmVEZWxldGUiLCJtYXRjaGluZ05vZGVzIiwibWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nRWRnZXMiLCJoYXNNYXRjaGluZ05vZGVzIiwiZWRnZUNoYW5nZXMiLCJub2RlQ2hhbmdlcyIsImRlbGV0ZWROb2RlcyIsImRlbGV0ZWRFZGdlcyIsImdldEludGVyc2VjdGluZ05vZGVzIiwibm9kZU9yUmVjdCIsInBhcnRpYWxseSIsImlzUmVjdCIsIm5vZGVSZWN0IiwiaGFzTm9kZXNPcHRpb24iLCJpbnRlcm5hbE5vZGUiLCJwb3NpdGlvbkFic29sdXRlIiwiY3Vyck5vZGVSZWN0Iiwib3ZlcmxhcHBpbmdBcmVhIiwicGFydGlhbGx5VmlzaWJsZSIsImlzTm9kZUludGVyc2VjdGluZyIsImFyZWEiLCJ1cGRhdGVOb2RlRGF0YSIsImRhdGFVcGRhdGUiLCJuZXh0RGF0YSIsImRhdGEiLCJ1cGRhdGVFZGdlRGF0YSIsImdldEhhbmRsZUNvbm5lY3Rpb25zIiwibm9kZUlkIiwiZnJvbSIsImNvbm5lY3Rpb25Mb29rdXAiLCJnZXROb2RlQ29ubmVjdGlvbnMiLCJoYW5kbGVJZCIsImZpdFZpZXciLCJmaXRWaWV3UmVzb2x2ZXIiLCJwcm9taXNlIiwid2luJDEiLCJ1c2VHbG9iYWxLZXlIYW5kbGVyIiwiZGVsZXRlS2V5Q29kZSIsIm11bHRpU2VsZWN0aW9uS2V5Q29kZSIsImRlbGV0ZUtleVByZXNzZWQiLCJtdWx0aVNlbGVjdGlvbktleVByZXNzZWQiLCJub2Rlc1NlbGVjdGlvbkFjdGl2ZSIsIm11bHRpU2VsZWN0aW9uQWN0aXZlIiwidXNlUmVzaXplSGFuZGxlciIsInVwZGF0ZURpbWVuc2lvbnMiLCJjaGVja1Zpc2liaWxpdHkiLCJvbkVycm9yIiwicmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJjb250YWluZXJTdHlsZSIsInRvcCIsImxlZnQiLCJzZWxlY3RvciRqIiwidXNlclNlbGVjdGlvbkFjdGl2ZSIsImxpYiIsImNvbm5lY3Rpb25JblByb2dyZXNzIiwiY29ubmVjdGlvbiIsImluUHJvZ3Jlc3MiLCJab29tUGFuZSIsIm9uUGFuZUNvbnRleHRNZW51Iiwiem9vbU9uU2Nyb2xsIiwiem9vbU9uUGluY2giLCJwYW5PblNjcm9sbCIsInBhbk9uU2Nyb2xsU3BlZWQiLCJwYW5PblNjcm9sbE1vZGUiLCJGcmVlIiwiem9vbU9uRG91YmxlQ2xpY2siLCJwYW5PbkRyYWciLCJ6b29tQWN0aXZhdGlvbktleUNvZGUiLCJwcmV2ZW50U2Nyb2xsaW5nIiwibm9XaGVlbENsYXNzTmFtZSIsIm9uVmlld3BvcnRDaGFuZ2UiLCJpc0NvbnRyb2xsZWRWaWV3cG9ydCIsInBhbmVDbGlja0Rpc3RhbmNlIiwic2VsZWN0aW9uT25EcmFnIiwiem9vbVBhbmUiLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJvblRyYW5zZm9ybUNoYW5nZSIsIm9uRHJhZ2dpbmdDaGFuZ2UiLCJwYW5lRHJhZ2dpbmciLCJvblBhblpvb21TdGFydCIsInZwIiwib25WaWV3cG9ydENoYW5nZVN0YXJ0Iiwib25Nb3ZlU3RhcnQiLCJvblBhblpvb20iLCJvbk1vdmUiLCJvblBhblpvb21FbmQiLCJvblZpZXdwb3J0Q2hhbmdlRW5kIiwib25Nb3ZlRW5kIiwiY2xvc2VzdCIsImRlc3Ryb3kiLCJ1cGRhdGUiLCJzZWxlY3RvciRpIiwidXNlclNlbGVjdGlvblJlY3QiLCJVc2VyU2VsZWN0aW9uIiwiaXNBY3RpdmUiLCJ3cmFwSGFuZGxlciIsImhhbmRsZXIiLCJjb250YWluZXJSZWYiLCJzZWxlY3RvciRoIiwiUGFuZSIsImlzU2VsZWN0aW5nIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbk1vZGUiLCJGdWxsIiwib25TZWxlY3Rpb25TdGFydCIsIm9uU2VsZWN0aW9uRW5kIiwib25QYW5lQ2xpY2siLCJvblBhbmVTY3JvbGwiLCJvblBhbmVNb3VzZUVudGVyIiwib25QYW5lTW91c2VNb3ZlIiwib25QYW5lTW91c2VMZWF2ZSIsImlzU2VsZWN0aW9uRW5hYmxlZCIsImNvbnRhaW5lciIsImNvbnRhaW5lckJvdW5kcyIsInNlbGVjdGVkTm9kZUlkcyIsInNlbGVjdGVkRWRnZUlkcyIsInNlbGVjdGlvbkluUHJvZ3Jlc3MiLCJvbkNsaWNrIiwicmVzZXRTZWxlY3RlZEVsZW1lbnRzIiwib25Db250ZXh0TWVudSIsIm9uV2hlZWwiLCJvbkNsaWNrQ2FwdHVyZSIsInN0b3BQcm9wYWdhdGlvbiIsIm9uUG9pbnRlckRvd25DYXB0dXJlIiwiZXZlbnRUYXJnZXRJc0NvbnRhaW5lciIsImlzTm9LZXlFdmVudCIsImlzU2VsZWN0aW9uQWN0aXZlIiwiYnV0dG9uIiwiaXNQcmltYXJ5Iiwic2V0UG9pbnRlckNhcHR1cmUiLCJwb2ludGVySWQiLCJuYXRpdmVFdmVudCIsInN0YXJ0WCIsInN0YXJ0WSIsIm9uUG9pbnRlck1vdmUiLCJkZWZhdWx0RWRnZU9wdGlvbnMiLCJtb3VzZVgiLCJtb3VzZVkiLCJyZXF1aXJlZERpc3RhbmNlIiwiZGlzdGFuY2UiLCJNYXRoIiwiaHlwb3QiLCJuZXh0VXNlclNlbGVjdFJlY3QiLCJhYnMiLCJwcmV2U2VsZWN0ZWROb2RlSWRzIiwicHJldlNlbGVjdGVkRWRnZUlkcyIsIlBhcnRpYWwiLCJlZGdlc1NlbGVjdGFibGUiLCJzZWxlY3RhYmxlIiwiY29ubmVjdGlvbnMiLCJlZGdlSWQiLCJvblBvaW50ZXJVcCIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsImRyYWdnYWJsZSIsInNlbGVjdGlvbiIsIm9uUG9pbnRlckVudGVyIiwib25Qb2ludGVyTGVhdmUiLCJoYW5kbGVOb2RlQ2xpY2siLCJ1bnNlbGVjdCIsIm5vZGVSZWYiLCJhZGRTZWxlY3RlZE5vZGVzIiwidW5zZWxlY3ROb2Rlc0FuZEVkZ2VzIiwiYmx1ciIsInVzZURyYWciLCJkaXNhYmxlZCIsIm5vRHJhZ0NsYXNzTmFtZSIsImhhbmRsZVNlbGVjdG9yIiwiaXNTZWxlY3RhYmxlIiwibm9kZUNsaWNrRGlzdGFuY2UiLCJzZXREcmFnZ2luZyIsInh5RHJhZyIsImdldFN0b3JlSXRlbXMiLCJvbk5vZGVNb3VzZURvd24iLCJvbkRyYWdTdGFydCIsIm9uRHJhZ1N0b3AiLCJzZWxlY3RlZEFuZERyYWdnYWJsZSIsIm5vZGVzRHJhZ2dhYmxlIiwidXNlTW92ZVNlbGVjdGVkTm9kZXMiLCJtb3ZlU2VsZWN0ZWROb2RlcyIsIm5vZGVFeHRlbnQiLCJ1cGRhdGVOb2RlUG9zaXRpb25zIiwibm9kZVVwZGF0ZXMiLCJpc1NlbGVjdGVkIiwieFZlbG8iLCJ5VmVsbyIsInhEaWZmIiwiZGlyZWN0aW9uIiwiZmFjdG9yIiwieURpZmYiLCJuZXh0UG9zaXRpb24iLCJOb2RlSWRDb250ZXh0IiwiQ29uc3VtZXIiLCJ1c2VOb2RlSWQiLCJzZWxlY3RvciRnIiwiY29ubmVjdE9uQ2xpY2siLCJjb25uZWN0aW5nU2VsZWN0b3IiLCJzdGF0ZSIsImNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlIiwiY2xpY2tIYW5kbGUiLCJjb25uZWN0aW9uTW9kZSIsImZyb21IYW5kbGUiLCJ0b0hhbmRsZSIsImlzVmFsaWQiLCJjb25uZWN0aW5nVG8iLCJjb25uZWN0aW5nRnJvbSIsImNsaWNrQ29ubmVjdGluZyIsImlzUG9zc2libGVFbmRIYW5kbGUiLCJTdHJpY3QiLCJjb25uZWN0aW9uSW5Qcm9jZXNzIiwiY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzIiwidmFsaWQiLCJIYW5kbGVDb21wb25lbnQiLCJUb3AiLCJpc1ZhbGlkQ29ubmVjdGlvbiIsImlzQ29ubmVjdGFibGUiLCJpc0Nvbm5lY3RhYmxlU3RhcnQiLCJpc0Nvbm5lY3RhYmxlRW5kIiwib25Db25uZWN0Iiwib25Nb3VzZURvd24iLCJvblRvdWNoU3RhcnQiLCJpc1RhcmdldCIsIm9uQ29ubmVjdEV4dGVuZGVkIiwib25Db25uZWN0QWN0aW9uIiwiZWRnZVBhcmFtcyIsIm9uUG9pbnRlckRvd24iLCJpc01vdXNlVHJpZ2dlcmVkIiwiY3VycmVudFN0b3JlIiwiaGFuZGxlRG9tTm9kZSIsImN1cnJlbnRUYXJnZXQiLCJhdXRvUGFuT25Db25uZWN0IiwiY29ubmVjdGlvblJhZGl1cyIsImZsb3dJZCIsImNhbmNlbENvbm5lY3Rpb24iLCJvbkNvbm5lY3RTdGFydCIsIm9uQ29ubmVjdEVuZCIsInVwZGF0ZUNvbm5lY3Rpb24iLCJnZXRUcmFuc2Zvcm0iLCJnZXRGcm9tSGFuZGxlIiwiYXV0b1BhblNwZWVkIiwiZHJhZ1RocmVzaG9sZCIsImNvbm5lY3Rpb25EcmFnVGhyZXNob2xkIiwib25DbGlja0Nvbm5lY3RTdGFydCIsIm9uQ2xpY2tDb25uZWN0RW5kIiwiaXNWYWxpZENvbm5lY3Rpb25TdG9yZSIsImNvbm5lY3Rpb25TdGF0ZSIsImhhbmRsZVR5cGUiLCJkb2MiLCJpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIiLCJoYW5kbGUiLCJmcm9tTm9kZUlkIiwiZnJvbUhhbmRsZUlkIiwiZnJvbVR5cGUiLCJjb25uZWN0aW9uQ2xvbmUiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJ0b1Bvc2l0aW9uIiwic291cmNlIiwiY29ubmVjdGFibGUiLCJjb25uZWN0YWJsZXN0YXJ0IiwiY29ubmVjdGFibGVlbmQiLCJjbGlja2Nvbm5lY3RpbmciLCJjb25uZWN0aW5nZnJvbSIsImNvbm5lY3Rpbmd0byIsImNvbm5lY3Rpb25pbmRpY2F0b3IiLCJIYW5kbGUiLCJJbnB1dE5vZGUiLCJzb3VyY2VQb3NpdGlvbiIsIkJvdHRvbSIsImxhYmVsIiwiRGVmYXVsdE5vZGUiLCJ0YXJnZXRQb3NpdGlvbiIsIkdyb3VwTm9kZSIsIk91dHB1dE5vZGUiLCJhcnJvd0tleURpZmZzIiwiQXJyb3dVcCIsIkFycm93RG93biIsIkFycm93TGVmdCIsIkFycm93UmlnaHQiLCJidWlsdGluTm9kZVR5cGVzIiwiaW5wdXQiLCJkZWZhdWx0Iiwib3V0cHV0IiwiZ3JvdXAiLCJnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zIiwiaGFuZGxlQm91bmRzIiwiaW5pdGlhbFdpZHRoIiwiaW5pdGlhbEhlaWdodCIsInNlbGVjdG9yJGYiLCJ0cmFuc2Zvcm1TdHJpbmciLCJOb2Rlc1NlbGVjdGlvbiIsIm9uU2VsZWN0aW9uQ29udGV4dE1lbnUiLCJmb2N1cyIsInByZXZlbnRTY3JvbGwiLCJvbktleURvd24iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ0YWJJbmRleCIsIndpbiIsInNlbGVjdG9yJGUiLCJGbG93UmVuZGVyZXJDb21wb25lbnQiLCJzZWxlY3Rpb25LZXlDb2RlIiwicGFuQWN0aXZhdGlvbktleUNvZGUiLCJfcGFuT25TY3JvbGwiLCJfcGFuT25EcmFnIiwicGFuQWN0aXZhdGlvbktleVByZXNzZWQiLCJfc2VsZWN0aW9uT25EcmFnIiwiRmxvd1JlbmRlcmVyIiwic2VsZWN0b3IkZCIsIm9ubHlSZW5kZXJWaXNpYmxlIiwidXNlVmlzaWJsZU5vZGVJZHMiLCJub2RlSWRzIiwic2VsZWN0b3IkYyIsInVzZVJlc2l6ZU9ic2VydmVyIiwidXBkYXRlcyIsImVudHJ5IiwiZ2V0QXR0cmlidXRlIiwibm9kZUVsZW1lbnQiLCJmb3JjZSIsImRpc2Nvbm5lY3QiLCJ1c2VOb2RlT2JzZXJ2ZXIiLCJub2RlVHlwZSIsImhhc0RpbWVuc2lvbnMiLCJvYnNlcnZlZE5vZGUiLCJwcmV2U291cmNlUG9zaXRpb24iLCJwcmV2VGFyZ2V0UG9zaXRpb24iLCJwcmV2VHlwZSIsImlzSW5pdGlhbGl6ZWQiLCJoaWRkZW4iLCJ0eXBlQ2hhbmdlZCIsInNvdXJjZVBvc0NoYW5nZWQiLCJ0YXJnZXRQb3NDaGFuZ2VkIiwiTm9kZVdyYXBwZXIiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VMZWF2ZSIsIm9uRG91YmxlQ2xpY2siLCJub2Rlc0Nvbm5lY3RhYmxlIiwibm9kZXNGb2N1c2FibGUiLCJub2RlVHlwZXMiLCJpc1BhcmVudCIsInBhcmVudExvb2t1cCIsIk5vZGVDb21wb25lbnQiLCJpc0RyYWdnYWJsZSIsImlzRm9jdXNhYmxlIiwiZm9jdXNhYmxlIiwiZHJhZ0hhbmRsZSIsIm5vZGVEaW1lbnNpb25zIiwiaW5saW5lRGltZW5zaW9ucyIsImhhc1BvaW50ZXJFdmVudHMiLCJvbk1vdXNlRW50ZXJIYW5kbGVyIiwib25Nb3VzZU1vdmVIYW5kbGVyIiwib25Nb3VzZUxlYXZlSGFuZGxlciIsIm9uQ29udGV4dE1lbnVIYW5kbGVyIiwib25Eb3VibGVDbGlja0hhbmRsZXIiLCJvblNlbGVjdE5vZGVIYW5kbGVyIiwic2VsZWN0Tm9kZXNPbkRyYWciLCJub2RlRHJhZ1RocmVzaG9sZCIsInRvTG93ZXJDYXNlIiwib25Gb2N1cyIsImF1dG9QYW5Pbk5vZGVGb2N1cyIsIndpdGhpblZpZXdwb3J0IiwicGFyZW50IiwiekluZGV4IiwieiIsInBvaW50ZXJFdmVudHMiLCJ2aXNpYmlsaXR5Iiwicm9sZSIsImFyaWFSb2xlIiwiYXJpYUxhYmVsIiwiZG9tQXR0cmlidXRlcyIsInBvc2l0aW9uQWJzb2x1dGVYIiwicG9zaXRpb25BYnNvbHV0ZVkiLCJkZWxldGFibGUiLCJOb2RlV3JhcHBlciQxIiwic2VsZWN0b3IkYiIsIk5vZGVSZW5kZXJlckNvbXBvbmVudCIsIm9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMiLCJvbk5vZGVDbGljayIsIm9uTm9kZU1vdXNlRW50ZXIiLCJvbk5vZGVNb3VzZU1vdmUiLCJvbk5vZGVNb3VzZUxlYXZlIiwib25Ob2RlQ29udGV4dE1lbnUiLCJvbk5vZGVEb3VibGVDbGljayIsIk5vZGVSZW5kZXJlciIsInVzZVZpc2libGVFZGdlSWRzIiwiZWRnZUlkcyIsInZpc2libGVFZGdlSWRzIiwic291cmNlTm9kZSIsInRhcmdldE5vZGUiLCJBcnJvd1N5bWJvbCIsImNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdHJva2UiLCJzdHJva2VMaW5lY2FwIiwiZmlsbCIsInN0cm9rZUxpbmVqb2luIiwicG9pbnRzIiwiQXJyb3dDbG9zZWRTeW1ib2wiLCJNYXJrZXJTeW1ib2xzIiwiQXJyb3ciLCJBcnJvd0Nsb3NlZCIsInVzZU1hcmtlclN5bWJvbCIsInN5bWJvbCIsInN5bWJvbEV4aXN0cyIsIk1hcmtlciIsIm1hcmtlclVuaXRzIiwib3JpZW50IiwiU3ltYm9sIiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJ2aWV3Qm94IiwicmVmWCIsInJlZlkiLCJNYXJrZXJEZWZpbml0aW9ucyIsImRlZmF1bHRDb2xvciIsIm1hcmtlcnMiLCJkZWZhdWx0TWFya2VyU3RhcnQiLCJtYXJrZXJTdGFydCIsImRlZmF1bHRNYXJrZXJFbmQiLCJtYXJrZXJFbmQiLCJtYXJrZXIiLCJNYXJrZXJEZWZpbml0aW9ucyQxIiwiRWRnZVRleHRDb21wb25lbnQiLCJsYWJlbFN0eWxlIiwibGFiZWxTaG93QmciLCJsYWJlbEJnU3R5bGUiLCJsYWJlbEJnUGFkZGluZyIsImxhYmVsQmdCb3JkZXJSYWRpdXMiLCJlZGdlVGV4dEJib3giLCJzZXRFZGdlVGV4dEJib3giLCJlZGdlVGV4dENsYXNzZXMiLCJlZGdlVGV4dFJlZiIsInRleHRCYm94IiwiZ2V0QkJveCIsInJ4IiwicnkiLCJkeSIsIkVkZ2VUZXh0IiwiQmFzZUVkZ2UiLCJwYXRoIiwibGFiZWxYIiwibGFiZWxZIiwiaW50ZXJhY3Rpb25XaWR0aCIsImQiLCJzdHJva2VPcGFjaXR5IiwiZ2V0Q29udHJvbCIsInBvcyIsIngxIiwieTEiLCJ4MiIsInkyIiwiTGVmdCIsIlJpZ2h0IiwiZ2V0U2ltcGxlQmV6aWVyUGF0aCIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzb3VyY2VDb250cm9sWCIsInNvdXJjZUNvbnRyb2xZIiwidGFyZ2V0Q29udHJvbFgiLCJ0YXJnZXRDb250cm9sWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwiY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSIsIl9pZCIsImlzSW50ZXJuYWwiLCJTaW1wbGVCZXppZXJFZGdlIiwiU2ltcGxlQmV6aWVyRWRnZUludGVybmFsIiwiY3JlYXRlU21vb3RoU3RlcEVkZ2UiLCJwYXRoT3B0aW9ucyIsImJvcmRlclJhZGl1cyIsIm9mZnNldCIsInN0ZXBQb3NpdGlvbiIsIlNtb290aFN0ZXBFZGdlIiwiU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCIsImNyZWF0ZVN0ZXBFZGdlIiwiU3RlcEVkZ2UiLCJTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlIiwiU3RyYWlnaHRFZGdlSW50ZXJuYWwiLCJjcmVhdGVCZXppZXJFZGdlIiwiY3VydmF0dXJlIiwiQmV6aWVyRWRnZSIsIkJlemllckVkZ2VJbnRlcm5hbCIsImJ1aWx0aW5FZGdlVHlwZXMiLCJzdHJhaWdodCIsInN0ZXAiLCJzbW9vdGhzdGVwIiwic2ltcGxlYmV6aWVyIiwibnVsbFBvc2l0aW9uIiwic2hpZnRYIiwic2hpZnQiLCJzaGlmdFkiLCJFZGdlVXBkYXRlckNsYXNzTmFtZSIsIkVkZ2VBbmNob3IiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJhZGl1cyIsIm9uTW91c2VPdXQiLCJjeCIsImN5IiwiciIsIkVkZ2VVcGRhdGVBbmNob3JzIiwiaXNSZWNvbm5lY3RhYmxlIiwicmVjb25uZWN0UmFkaXVzIiwib25SZWNvbm5lY3QiLCJvblJlY29ubmVjdFN0YXJ0Iiwib25SZWNvbm5lY3RFbmQiLCJzZXRSZWNvbm5lY3RpbmciLCJzZXRVcGRhdGVIb3ZlciIsImhhbmRsZUVkZ2VVcGRhdGVyIiwib3Bwb3NpdGVIYW5kbGUiLCJfb25SZWNvbm5lY3RFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwiX29uQ29ubmVjdFN0YXJ0IiwiX2V2ZW50IiwiZWRnZVVwZGF0ZXJUeXBlIiwib25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24iLCJ0YXJnZXRIYW5kbGUiLCJvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biIsInNvdXJjZUhhbmRsZSIsIm9uUmVjb25uZWN0TW91c2VFbnRlciIsIm9uUmVjb25uZWN0TW91c2VPdXQiLCJFZGdlV3JhcHBlciIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNSZWNvbm5lY3RhYmxlIiwiZWRnZVR5cGVzIiwiZWRnZVR5cGUiLCJFZGdlQ29tcG9uZW50IiwicmVjb25uZWN0YWJsZSIsImVkZ2VSZWYiLCJ1cGRhdGVIb3ZlciIsInJlY29ubmVjdGluZyIsImVkZ2VQb3NpdGlvbiIsImVsZXZhdGVPblNlbGVjdCIsImVsZXZhdGVFZGdlc09uU2VsZWN0IiwiekluZGV4TW9kZSIsIm1hcmtlclN0YXJ0VXJsIiwibWFya2VyRW5kVXJsIiwib25FZGdlQ2xpY2siLCJhZGRTZWxlY3RlZEVkZ2VzIiwib25FZGdlRG91YmxlQ2xpY2siLCJvbkVkZ2VDb250ZXh0TWVudSIsIm9uRWRnZU1vdXNlRW50ZXIiLCJvbkVkZ2VNb3VzZU1vdmUiLCJvbkVkZ2VNb3VzZUxlYXZlIiwiYW5pbWF0ZWQiLCJpbmFjdGl2ZSIsInVwZGF0aW5nIiwic291cmNlSGFuZGxlSWQiLCJ0YXJnZXRIYW5kbGVJZCIsIkVkZ2VXcmFwcGVyJDEiLCJzZWxlY3RvciRhIiwiRWRnZVJlbmRlcmVyQ29tcG9uZW50IiwiZGVmYXVsdE1hcmtlckNvbG9yIiwiRWRnZVJlbmRlcmVyIiwic2VsZWN0b3IkOSIsIlZpZXdwb3J0IiwidXNlT25Jbml0SGFuZGxlciIsIm9uSW5pdCIsInJmSW5zdGFuY2UiLCJzZXRUaW1lb3V0Iiwic2VsZWN0b3IkOCIsInN5bmNWaWV3cG9ydCIsInVzZVZpZXdwb3J0U3luYyIsInN0b3JlU2VsZWN0b3IkMSIsInRvIiwiZ2V0U2VsZWN0b3IiLCJjb25uZWN0aW9uU2VsZWN0b3IiLCJjb21iaW5lZFNlbGVjdG9yIiwidXNlQ29ubmVjdGlvbiIsInNlbGVjdG9yJDciLCJDb25uZWN0aW9uTGluZVdyYXBwZXIiLCJjb21wb25lbnQiLCJyZW5kZXJDb25uZWN0aW9uIiwiQ29ubmVjdGlvbkxpbmUiLCJDdXN0b21Db21wb25lbnQiLCJCZXppZXIiLCJmcm9tTm9kZSIsImZyb21Qb3NpdGlvbiIsInRvTm9kZSIsInBvaW50ZXIiLCJjb25uZWN0aW9uTGluZVR5cGUiLCJjb25uZWN0aW9uTGluZVN0eWxlIiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsImNvbm5lY3Rpb25TdGF0dXMiLCJwYXRoUGFyYW1zIiwiU2ltcGxlQmV6aWVyIiwiU3RlcCIsIlNtb290aFN0ZXAiLCJlbXB0eVR5cGVzIiwidXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyIsIm5vZGVPckVkZ2VUeXBlcyIsInR5cGVzUmVmIiwicHJvY2VzcyIsInVzZWRLZXlzIiwidXNlU3R5bGVzTG9hZGVkV2FybmluZyIsImNoZWNrZWQiLCJwYW5lIiwicXVlcnlTZWxlY3RvciIsImdldENvbXB1dGVkU3R5bGUiLCJHcmFwaFZpZXdDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJHcmFwaFZpZXciLCJnZXRJbml0aWFsU3RhdGUiLCJzdG9yZUVkZ2VzIiwic3RvcmVOb2RlcyIsInN0b3JlTm9kZU9yaWdpbiIsInN0b3JlTm9kZUV4dGVudCIsIm5vZGVzSW5pdGlhbGl6ZWQiLCJlbGV2YXRlTm9kZXNPblNlbGVjdCIsImF1dG9QYW5Pbk5vZGVEcmFnIiwiZGVidWciLCJvbkVkZ2VzQ2hhbmdlTWlkZGxld2FyZU1hcCIsImNyZWF0ZVN0b3JlIiwicmVzb2x2ZUZpdFZpZXciLCJjaGVja0VxdWFsaXR5IiwidXBkYXRlZEludGVybmFscyIsImNvbnNvbGUiLCJsb2ciLCJub2RlRHJhZ0l0ZW1zIiwicGFyZW50RXhwYW5kQ2hpbGRyZW4iLCJkcmFnSXRlbSIsImV4cGFuZFBhcmVudCIsIm1heCIsInVwZGF0ZWRGcm9tIiwicmVjdCIsInBhcmVudEV4cGFuZENoYW5nZXMiLCJ1cGRhdGVkTm9kZXMiLCJ1cGRhdGVkRWRnZXMiLCJjaGFuZ2VkRWRnZXMiLCJub2Rlc1RvVW5zZWxlY3QiLCJlZGdlc1RvVW5zZWxlY3QiLCJzZXRTY2FsZUV4dGVudCIsIm5leHROb2RlRXh0ZW50IiwiZGVsdGEiLCJuZXh0Wm9vbSIsImlzIiwiUmVhY3RGbG93UHJvdmlkZXIiLCJpbml0aWFsTm9kZXMiLCJpbml0aWFsRWRnZXMiLCJpbml0aWFsTWluWm9vbSIsImluaXRpYWxNYXhab29tIiwiaW5pdGlhbEZpdFZpZXdPcHRpb25zIiwiV3JhcHBlciIsImlzV3JhcHBlZCIsIndyYXBwZXJTdHlsZSIsIlJlYWN0RmxvdyIsIm9uTm9kZURyYWdTdGFydCIsIm9uTm9kZURyYWciLCJvbk5vZGVEcmFnU3RvcCIsIm9uU2VsZWN0aW9uRHJhZ1N0YXJ0Iiwib25TZWxlY3Rpb25EcmFnIiwib25TZWxlY3Rpb25EcmFnU3RvcCIsImRlZmF1bHRWaWV3cG9ydCQxIiwiYXR0cmlidXRpb25Qb3NpdGlvbiIsIm9uU2Nyb2xsIiwiY29sb3JNb2RlQ2xhc3NOYW1lIiwid3JhcHBlck9uU2Nyb2xsIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsInNlbGVjdG9yJDYiLCJFZGdlTGFiZWxSZW5kZXJlciIsImVkZ2VMYWJlbFJlbmRlcmVyIiwic2VsZWN0b3IkNSIsIlZpZXdwb3J0UG9ydGFsIiwidmlld1BvcnRhbERpdiIsInVzZVVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVJZHMiLCJ1cGRhdGVJZCIsInRyaWdnZXJGaXRWaWV3Iiwibm9kZXNTZWxlY3RvciIsInVzZU5vZGVzIiwiZWRnZXNTZWxlY3RvciIsInVzZUVkZ2VzIiwidmlld3BvcnRTZWxlY3RvciIsInVzZVZpZXdwb3J0IiwidXNlTm9kZXNTdGF0ZSIsIm5kcyIsInVzZUVkZ2VzU3RhdGUiLCJlZHMiLCJ1c2VPblZpZXdwb3J0Q2hhbmdlIiwib25TdGFydCIsIm9uQ2hhbmdlIiwib25FbmQiLCJ1c2VPblNlbGVjdGlvbkNoYW5nZSIsIm5leHRPblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwibmV4dEhhbmRsZXJzIiwic2VsZWN0b3IkNCIsImluY2x1ZGVIaWRkZW5Ob2RlcyIsInVzZU5vZGVzSW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplZCIsInVzZUhhbmRsZUNvbm5lY3Rpb25zIiwib25EaXNjb25uZWN0Iiwid2FybiIsIl9ub2RlSWQiLCJjdXJyZW50Tm9kZUlkIiwicHJldkNvbm5lY3Rpb25zIiwiX2Nvbm5lY3Rpb25zIiwiZXJyb3IwMTQiLCJ1c2VOb2RlQ29ubmVjdGlvbnMiLCJ1c2VOb2Rlc0RhdGEiLCJub2Rlc0RhdGEiLCJpc0FycmF5T2ZJZHMiLCJfbm9kZUlkcyIsInVzZUludGVybmFsTm9kZSIsImV4cGVyaW1lbnRhbF91c2VPbk5vZGVzQ2hhbmdlTWlkZGxld2FyZSIsImV4cGVyaW1lbnRhbF91c2VPbkVkZ2VzQ2hhbmdlTWlkZGxld2FyZSIsIkxpbmVQYXR0ZXJuIiwibGluZVdpZHRoIiwidmFyaWFudCIsIkRvdFBhdHRlcm4iLCJCYWNrZ3JvdW5kVmFyaWFudCIsImRlZmF1bHRTaXplIiwiRG90cyIsIkxpbmVzIiwiQ3Jvc3MiLCJzZWxlY3RvciQzIiwicGF0dGVybklkIiwiQmFja2dyb3VuZENvbXBvbmVudCIsImdhcCIsImJnQ29sb3IiLCJwYXR0ZXJuQ2xhc3NOYW1lIiwicGF0dGVyblNpemUiLCJpc0RvdHMiLCJpc0Nyb3NzIiwiZ2FwWFkiLCJzY2FsZWRHYXAiLCJzY2FsZWRTaXplIiwib2Zmc2V0WFkiLCJwYXR0ZXJuRGltZW5zaW9ucyIsInNjYWxlZE9mZnNldCIsIl9wYXR0ZXJuSWQiLCJwYXR0ZXJuVW5pdHMiLCJwYXR0ZXJuVHJhbnNmb3JtIiwiQmFja2dyb3VuZCIsIlBsdXNJY29uIiwieG1sbnMiLCJNaW51c0ljb24iLCJGaXRWaWV3SWNvbiIsIkxvY2tJY29uIiwiVW5sb2NrSWNvbiIsIkNvbnRyb2xCdXR0b24iLCJzZWxlY3RvciQyIiwiaXNJbnRlcmFjdGl2ZSIsIm1pblpvb21SZWFjaGVkIiwibWF4Wm9vbVJlYWNoZWQiLCJDb250cm9sc0NvbXBvbmVudCIsInNob3dab29tIiwic2hvd0ZpdFZpZXciLCJzaG93SW50ZXJhY3RpdmUiLCJvblpvb21JbiIsIm9uWm9vbU91dCIsIm9uRml0VmlldyIsIm9uSW50ZXJhY3RpdmVDaGFuZ2UiLCJvcmllbnRhdGlvbiIsIm9uWm9vbUluSGFuZGxlciIsIm9uWm9vbU91dEhhbmRsZXIiLCJvbkZpdFZpZXdIYW5kbGVyIiwib25Ub2dnbGVJbnRlcmFjdGl2aXR5Iiwib3JpZW50YXRpb25DbGFzcyIsInRpdGxlIiwiQ29udHJvbHMiLCJNaW5pTWFwTm9kZUNvbXBvbmVudCIsInN0cm9rZUNvbG9yIiwic2hhcGVSZW5kZXJpbmciLCJiYWNrZ3JvdW5kIiwiYmFja2dyb3VuZENvbG9yIiwiTWluaU1hcE5vZGUiLCJzZWxlY3Rvck5vZGVJZHMiLCJnZXRBdHRyRnVuY3Rpb24iLCJmdW5jIiwiRnVuY3Rpb24iLCJNaW5pTWFwTm9kZXMiLCJub2RlU3Ryb2tlQ29sb3IiLCJub2RlQ29sb3IiLCJub2RlQ2xhc3NOYW1lIiwibm9kZUJvcmRlclJhZGl1cyIsIm5vZGVTdHJva2VXaWR0aCIsIm5vZGVDb21wb25lbnQiLCJub2RlQ29sb3JGdW5jIiwibm9kZVN0cm9rZUNvbG9yRnVuYyIsIm5vZGVDbGFzc05hbWVGdW5jIiwiY2hyb21lIiwiTm9kZUNvbXBvbmVudFdyYXBwZXIiLCJOb2RlQ29tcG9uZW50V3JhcHBlcklubmVyIiwiTWluaU1hcE5vZGVzJDEiLCJkZWZhdWx0V2lkdGgiLCJkZWZhdWx0SGVpZ2h0IiwiZmlsdGVySGlkZGVuIiwic2VsZWN0b3IkMSIsInZpZXdCQiIsImJvdW5kaW5nUmVjdCIsImZsb3dXaWR0aCIsImZsb3dIZWlnaHQiLCJBUklBX0xBQkVMX0tFWSIsIk1pbmlNYXBDb21wb25lbnQiLCJtYXNrQ29sb3IiLCJtYXNrU3Ryb2tlQ29sb3IiLCJtYXNrU3Ryb2tlV2lkdGgiLCJwYW5uYWJsZSIsInpvb21hYmxlIiwiaW52ZXJzZVBhbiIsInpvb21TdGVwIiwib2Zmc2V0U2NhbGUiLCJzdmciLCJlbGVtZW50V2lkdGgiLCJlbGVtZW50SGVpZ2h0Iiwic2NhbGVkV2lkdGgiLCJzY2FsZWRIZWlnaHQiLCJ2aWV3U2NhbGUiLCJ2aWV3V2lkdGgiLCJ2aWV3SGVpZ2h0IiwibGFiZWxsZWRCeSIsInZpZXdTY2FsZVJlZiIsIm1pbmltYXBJbnN0YW5jZSIsImdldFZpZXdTY2FsZSIsIm9uU3ZnQ2xpY2siLCJvblN2Z05vZGVDbGljayIsIl9hcmlhTGFiZWwiLCJmaWxsUnVsZSIsIk1pbmlNYXAiLCJzY2FsZVNlbGVjdG9yIiwiY2FsY3VsYXRlU2NhbGUiLCJkZWZhdWx0UG9zaXRpb25zIiwiTGluZSIsIlJlc2l6ZUNvbnRyb2wiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwibWF4SGVpZ2h0Iiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplRGlyZWN0aW9uIiwiYXV0b1NjYWxlIiwic2hvdWxkUmVzaXplIiwib25SZXNpemVTdGFydCIsIm9uUmVzaXplIiwib25SZXNpemVFbmQiLCJjb250ZXh0Tm9kZUlkIiwicmVzaXplQ29udHJvbFJlZiIsImlzSGFuZGxlQ29udHJvbCIsInNjYWxlIiwicmVzaXplciIsImNvbnRyb2xQb3NpdGlvbiIsInBhbmVEb21Ob2RlIiwiY2hpbGRDaGFuZ2VzIiwib3JpZ2luIiwiY2hpbGQiLCJwb3NpdGlvbkNoYW5nZSIsImRpbWVuc2lvbkNoYW5nZSIsImNoaWxkQ2hhbmdlIiwiYm91bmRhcmllcyIsInBvc2l0aW9uQ2xhc3NOYW1lcyIsIk5vZGVSZXNpemVDb250cm9sIiwiTm9kZVJlc2l6ZXIiLCJpc1Zpc2libGUiLCJoYW5kbGVDbGFzc05hbWUiLCJoYW5kbGVTdHlsZSIsImxpbmVDbGFzc05hbWUiLCJsaW5lU3R5bGUiLCJOb2RlVG9vbGJhclBvcnRhbCIsIndyYXBwZXJSZWYiLCJub2RlRXF1YWxpdHlGbiIsIm5vZGVzRXF1YWxpdHlGbiIsInN0b3JlU2VsZWN0b3IiLCJzZWxlY3RlZE5vZGVzQ291bnQiLCJOb2RlVG9vbGJhciIsImFsaWduIiwiaW50ZXJuYWxOb2RlcyIsIm5vZGVzQXJyYXkiLCJhY2MiLCJ0cmltIiwiem9vbVNlbGVjdG9yIiwiRWRnZVRvb2xiYXIiLCJhbGlnblgiLCJhbGlnblkiLCJlZGdlU2VsZWN0b3IiLCJ0cmFuc2Zvcm1PcmlnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   defaultAriaLabelConfig: () => (/* binding */ defaultAriaLabelConfig),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitViewport: () => (/* binding */ fitViewport),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgeId: () => (/* binding */ getEdgeId),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getEdgeToolbarTransform: () => (/* binding */ getEdgeToolbarTransform),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isManualZIndexMode: () => (/* binding */ isManualZIndexMode),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   mergeAriaLabelConfig: () => (/* binding */ mergeAriaLabelConfig),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals),\n/* harmony export */   withResolvers: () => (/* binding */ withResolvers)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/value.js\");\n/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ \"(ssr)/./node_modules/d3-interpolate/src/zoom.js\");\n\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\nconst defaultAriaLabelConfig = {\n    'node.a11yDescription.default': 'Press enter or space to select a node. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.keyboardDisabled': 'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',\n    'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }) => `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,\n    'edge.a11yDescription.default': 'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',\n    // Control elements\n    'controls.ariaLabel': 'Control Panel',\n    'controls.zoomIn.ariaLabel': 'Zoom In',\n    'controls.zoomOut.ariaLabel': 'Zoom Out',\n    'controls.fitView.ariaLabel': 'Fit View',\n    'controls.interactive.ariaLabel': 'Toggle Interactivity',\n    // Mini map\n    'minimap.ariaLabel': 'Mini Map',\n    // Handle\n    'handle.ariaLabel': 'Handle',\n};\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n    pointer: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is usable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is usable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the source is the given node.\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from.\n * @param nodes - The array of all nodes.\n * @param edges - The array of all edges.\n * @returns An array of nodes that are connected over edges where the target is the given node.\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for.\n * @returns Bounding box enclosing all nodes.\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0] }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    let hasVisibleNodes = false;\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            box = getBoundsOfBoxes(box, nodeToBox(node));\n            hasVisibleNodes = true;\n        }\n    });\n    return hasVisibleNodes ? boxToRect(box) : { x: 0, y: 0, width: 0, height: 0 };\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for.\n * @param edges - All edges.\n * @returns Array of edges that connect any of the given nodes with each other.\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitViewport({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(true);\n    }\n    const nodesToFit = getFitViewNodes(nodes, options);\n    const bounds = getInternalNodesBounds(nodesToFit);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, {\n        duration: options?.duration,\n        ease: options?.ease,\n        interpolate: options?.interpolate,\n    });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = node.extent || nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Parses a single padding value to a number\n * @internal\n * @param padding - Padding to parse\n * @param viewport - Width or height of the viewport\n * @returns The padding in pixels\n */\nfunction parsePadding(padding, viewport) {\n    if (typeof padding === 'number') {\n        return Math.floor((viewport - viewport / (1 + padding)) * 0.5);\n    }\n    if (typeof padding === 'string' && padding.endsWith('px')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(paddingValue);\n        }\n    }\n    if (typeof padding === 'string' && padding.endsWith('%')) {\n        const paddingValue = parseFloat(padding);\n        if (!Number.isNaN(paddingValue)) {\n            return Math.floor(viewport * paddingValue * 0.01);\n        }\n    }\n    console.error(`[React Flow] The padding value \"${padding}\" is invalid. Please provide a number or a string with a valid unit (px or %).`);\n    return 0;\n}\n/**\n * Parses the paddings to an object with top, right, bottom, left, x and y paddings\n * @internal\n * @param padding - Padding to parse\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the paddings in pixels\n */\nfunction parsePaddings(padding, width, height) {\n    if (typeof padding === 'string' || typeof padding === 'number') {\n        const paddingY = parsePadding(padding, height);\n        const paddingX = parsePadding(padding, width);\n        return {\n            top: paddingY,\n            right: paddingX,\n            bottom: paddingY,\n            left: paddingX,\n            x: paddingX * 2,\n            y: paddingY * 2,\n        };\n    }\n    if (typeof padding === 'object') {\n        const top = parsePadding(padding.top ?? padding.y ?? 0, height);\n        const bottom = parsePadding(padding.bottom ?? padding.y ?? 0, height);\n        const left = parsePadding(padding.left ?? padding.x ?? 0, width);\n        const right = parsePadding(padding.right ?? padding.x ?? 0, width);\n        return { top, right, bottom, left, x: left + right, y: top + bottom };\n    }\n    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };\n}\n/**\n * Calculates the resulting paddings if the new viewport is applied\n * @internal\n * @param bounds - Bounds to fit inside viewport\n * @param x - X position of the viewport\n * @param y - Y position of the viewport\n * @param zoom - Zoom level of the viewport\n * @param width - Width of the viewport\n * @param height - Height of the viewport\n * @returns An object with the minimum padding required to fit the bounds inside the viewport\n */\nfunction calculateAppliedPaddings(bounds, x, y, zoom, width, height) {\n    const { x: left, y: top } = rendererPointToPoint(bounds, [x, y, zoom]);\n    const { x: boundRight, y: boundBottom } = rendererPointToPoint({ x: bounds.x + bounds.width, y: bounds.y + bounds.height }, [x, y, zoom]);\n    const right = width - boundRight;\n    const bottom = height - boundBottom;\n    return {\n        left: Math.floor(left),\n        top: Math.floor(top),\n        right: Math.floor(right),\n        bottom: Math.floor(bottom),\n    };\n}\n/**\n * Returns a viewport that encloses the given bounds with padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport.\n * @param width - Width of the viewport.\n * @param height  - Height of the viewport.\n * @param minZoom - Minimum zoom level of the resulting viewport.\n * @param maxZoom - Maximum zoom level of the resulting viewport.\n * @param padding - Padding around the bounds.\n * @returns A transformed {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}.\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n * { x: 0, y: 0, width: 100, height: 100},\n * 1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    // First we resolve all the paddings to actual pixel values\n    const p = parsePaddings(padding, width, height);\n    const xZoom = (width - p.x) / bounds.width;\n    const yZoom = (height - p.y) / bounds.height;\n    // We calculate the new x, y, zoom for a centered view\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    // Then we calculate the minimum padding, to respect asymmetric paddings\n    const newPadding = calculateAppliedPaddings(bounds, x, y, clampedZoom, width, height);\n    // We only want to have an offset if the newPadding is smaller than the required padding\n    const offset = {\n        left: Math.min(newPadding.left - p.left, 0),\n        top: Math.min(newPadding.top - p.top, 0),\n        right: Math.min(newPadding.right - p.right, 0),\n        bottom: Math.min(newPadding.bottom - p.bottom, 0),\n    };\n    return {\n        x: x - offset.left + offset.right,\n        y: y - offset.top + offset.bottom,\n        zoom: clampedZoom,\n    };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== null && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Polyfill for Promise.withResolvers until we can use it in all browsers\n * @internal\n */\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\nfunction mergeAriaLabelConfig(partial) {\n    return { ...defaultAriaLabelConfig, ...(partial || {}) };\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\n/**\n * Returns the z-index for an edge based on the node it connects and whether it is selected.\n * By default, edges are rendered below nodes. This behaviour is different for edges that are\n * connected to nodes with a parent, as they are rendered above the parent node.\n */\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false, zIndexMode = 'basic', }) {\n    if (zIndexMode === 'manual') {\n        return zIndex;\n    }\n    const edgeZ = elevateOnSelect && selected ? zIndex + 1000 : zIndex;\n    const nodeZ = Math.max(sourceNode.parentId || (elevateOnSelect && sourceNode.selected) ? sourceNode.internals.z : 0, targetNode.parentId || (elevateOnSelect && targetNode.selected) ? targetNode.internals.z : 0);\n    return edgeZ + nodeZ;\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\n/**\n * The default edge ID generator function. Generates an ID based on the source, target, and handles.\n * @public\n * @param params - The connection or edge to generate an ID for.\n * @returns The generated edge ID.\n */\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an `Edge` or a `Connection` you want to add.\n * @param edges - The array of all current edges.\n * @param options - Optional configuration object.\n * @returns A new array of edges with the new edge added.\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges, options = {}) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const edgeIdGenerator = options.getEdgeId || getEdgeId;\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: edgeIdGenerator(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update.\n * @param newConnection - The new connection you want to update the edge with.\n * @param edges - The array of all current edges.\n * @returns The updated edges array.\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    const edgeIdGenerator = options.getEdgeId || getEdgeId;\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? edgeIdGenerator(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * With this function we try to mimic an orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing, but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, stepPosition, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [, , defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        if (dirAccessor === 'x') {\n            // Primary direction is horizontal, so stepPosition affects X coordinate\n            centerX = center.x ?? (sourceGapped.x + (targetGapped.x - sourceGapped.x) * stepPosition);\n            centerY = center.y ?? (sourceGapped.y + targetGapped.y) / 2;\n        }\n        else {\n            // Primary direction is vertical, so stepPosition affects Y coordinate  \n            centerX = center.x ?? (sourceGapped.x + targetGapped.x) / 2;\n            centerY = center.y ?? (sourceGapped.y + (targetGapped.y - sourceGapped.y) * stepPosition);\n        }\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n * between two nodes. The `borderRadius` property can be used to choose how rounded\n * the corners of those steps are.\n * @public\n * @returns A path string you can use in an SVG, the `labelX` and `labelY` position (center of path)\n * and `offsetX`, `offsetY` between source handle and label.\n *\n * - `path`: the path to use in an SVG `<path>` element.\n * - `labelX`: the `x` position you can use to render a label for this edge.\n * - `labelY`: the `y` position you can use to render a label for this edge.\n * - `offsetX`: the absolute difference between the source `x` position and the `x` position of the\n * middle of this path.\n * - `offsetY`: the absolute difference between the source `y` position and the `y` position of the\n * middle of this path.\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, stepPosition = 0.5, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n        stepPosition,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst alignXToPercent = {\n    left: 0,\n    center: 50,\n    right: 100,\n};\nconst alignYToPercent = {\n    top: 0,\n    center: 50,\n    bottom: 100,\n};\nfunction getEdgeToolbarTransform(x, y, zoom, alignX = 'center', alignY = 'center') {\n    return `translate(${x}px, ${y}px) scale(${1 / zoom}) translate(${-(alignXToPercent[alignX] ?? 50)}%, ${-(alignYToPercent[alignY] ?? 50)}%)`;\n}\n\nconst SELECTED_NODE_Z = 1000;\nconst ROOT_PARENT_Z_INCREMENT = 10;\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    zIndexMode: 'basic',\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction parseHandles(userNode, internalNode) {\n    if (!userNode.handles) {\n        return !userNode.measured ? undefined : internalNode?.internals.handleBounds;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of userNode.handles) {\n        const handleBounds = {\n            id: handle.id,\n            width: handle.width ?? 1,\n            height: handle.height ?? 1,\n            nodeId: userNode.id,\n            x: handle.x,\n            y: handle.y,\n            position: handle.position,\n            type: handle.type,\n        };\n        if (handle.type === 'source') {\n            source.push(handleBounds);\n        }\n        else if (handle.type === 'target') {\n            target.push(handleBounds);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction isManualZIndexMode(zIndexMode) {\n    return zIndexMode === 'manual';\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options = {}) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    const rootParentIndex = { i: 0 };\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect && !isManualZIndexMode(_options.zIndexMode) ? SELECTED_NODE_Z : 0;\n    let nodesInitialized = nodes.length > 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: parseHandles(userNode, internalNode),\n                    z: calculateZ(userNode, selectedNodeZ, _options.zIndexMode),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if ((internalNode.measured === undefined ||\n            internalNode.measured.width === undefined ||\n            internalNode.measured.height === undefined) &&\n            !internalNode.hidden) {\n            nodesInitialized = false;\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options, rootParentIndex);\n        }\n    }\n    return nodesInitialized;\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options, rootParentIndex) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent, zIndexMode } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    // We just want to set the rootParentIndex for the first child\n    if (rootParentIndex &&\n        !parentNode.parentId &&\n        parentNode.internals.rootParentIndex === undefined &&\n        zIndexMode === 'auto') {\n        parentNode.internals.rootParentIndex = ++rootParentIndex.i;\n        parentNode.internals.z = parentNode.internals.z + rootParentIndex.i * ROOT_PARENT_Z_INCREMENT;\n    }\n    // But we need to update rootParentIndex.i also when parent has not been updated\n    if (rootParentIndex && parentNode.internals.rootParentIndex !== undefined) {\n        rootParentIndex.i = parentNode.internals.rootParentIndex;\n    }\n    const selectedNodeZ = elevateNodesOnSelect && !isManualZIndexMode(zIndexMode) ? SELECTED_NODE_Z : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ, zIndexMode) {\n    const zIndex = isNumeric(node.zIndex) ? node.zIndex : 0;\n    if (isManualZIndexMode(zIndexMode)) {\n        return zIndex;\n    }\n    return zIndex + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ, zIndexMode) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ, zIndexMode);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ >= childZ ? parentZ + 1 : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent, zIndexMode) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin, zIndexMode });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n/**\n * If a selection is being dragged we want to apply the same snap offset to all nodes in the selection.\n * This function calculates the snap offset based on the first node in the selection.\n */\nfunction calculateSnapOffset({ dragItems, snapGrid, x, y, }) {\n    const refDragItem = dragItems.values().next().value;\n    if (!refDragItem) {\n        return null;\n    }\n    const refPos = {\n        x: x - refDragItem.distance.x,\n        y: y - refDragItem.distance.y,\n    };\n    const refPosSnapped = snapPosition(refPos, snapGrid);\n    return {\n        x: refPosSnapped.x - refPos.x,\n        y: refPosSnapped.y - refPos.y,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    let nodePositionsChanged = false;\n    // we store the last drag event to be able to use it in the update function\n    let dragEvent = null;\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            const isMultiDrag = dragItems.size > 1;\n            const nodesBox = isMultiDrag && nodeExtent ? rectToBox(getInternalNodesBounds(dragItems)) : null;\n            const multiDragSnapOffset = isMultiDrag && snapToGrid\n                ? calculateSnapOffset({\n                    dragItems,\n                    snapGrid,\n                    x,\n                    y,\n                })\n                : null;\n            for (const [id, dragItem] of dragItems) {\n                /*\n                 * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                 */\n                if (!nodeLookup.has(id)) {\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = multiDragSnapOffset\n                        ? {\n                            x: Math.round(nextPosition.x + multiDragSnapOffset.x),\n                            y: Math.round(nextPosition.y + multiDragSnapOffset.y),\n                        }\n                        : snapPosition(nextPosition, snapGrid);\n                }\n                let adjustedNodeExtent = null;\n                if (isMultiDrag && nodeExtent && !dragItem.extent && nodesBox) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent ? adjustedNodeExtent : nodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            nodePositionsChanged = nodePositionsChanged || hasChange;\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            nodePositionsChanged = false;\n            dragEvent = event.sourceEvent;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            dragEvent = event.sourceEvent;\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                // Calculate distance in client coordinates for consistent drag threshold behavior across zoom levels\n                const currentMousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                const x = currentMousePosition.x - mousePosition.x;\n                const y = currentMousePosition.y - mousePosition.y;\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                if (nodePositionsChanged) {\n                    updateNodePositions(dragItems, false);\n                    nodePositionsChanged = false;\n                }\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, dragThreshold = 1, handleDomNode, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const handleType = getHandleType(edgeUpdaterType, handleDomNode);\n    const containerBounds = domNode?.getBoundingClientRect();\n    let connectionStarted = false;\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let resultHandleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromInternalNode = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromInternalNode, fromHandle, Position.Left, true);\n    let previousConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromInternalNode,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n        pointer: position,\n    };\n    function startConnection() {\n        connectionStarted = true;\n        updateConnection(previousConnection);\n        onConnectStart?.(event, { nodeId, handleId, handleType });\n    }\n    if (dragThreshold === 0) {\n        startConnection();\n    }\n    function onPointerMove(event) {\n        if (!connectionStarted) {\n            const { x: evtX, y: evtY } = getEventPosition(event);\n            const dx = evtX - x;\n            const dy = evtY - y;\n            const nextConnectionStarted = dx * dx + dy * dy > dragThreshold * dragThreshold;\n            if (!nextConnectionStarted) {\n                return;\n            }\n            startConnection();\n        }\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        resultHandleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const fromInternalNode = nodeLookup.get(nodeId);\n        const from = fromInternalNode\n            ? getHandlePosition(fromInternalNode, fromHandle, Position.Left, true)\n            : previousConnection.from;\n        const newConnection = {\n            ...previousConnection,\n            from,\n            isValid,\n            to: result.toHandle && isValid\n                ? rendererPointToPoint({ x: result.toHandle.x, y: result.toHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n            pointer: position,\n        };\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        // Prevent multi-touch aborting connection\n        if ('touches' in event && event.touches.length > 0) {\n            return;\n        }\n        if (connectionStarted) {\n            if ((closestHandle || resultHandleDomNode) && connection && isValid) {\n                onConnect?.(connection);\n            }\n            /*\n             * it's important to get a fresh reference from the store here\n             * in order to get the latest state of onConnectEnd\n             */\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const { inProgress, ...connectionState } = previousConnection;\n            const finalConnectionState = {\n                ...connectionState,\n                toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n            };\n            onConnectEnd?.(event, finalConnectionState);\n            if (edgeUpdaterType) {\n                onReconnectEnd?.(event, finalConnectionState);\n            }\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        resultHandleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, true);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 1, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const transform = getTransform();\n            const factor = event.sourceEvent.ctrlKey && isMacOs() ? 10 : 1;\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta * factor);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\n// taken from d3-ease: https://github.com/d3/d3-ease/blob/main/src/cubic.js\nconst defaultEase = (t) => ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;\nconst getD3Transition = (selection, duration = 0, ease = defaultEase, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).ease(ease).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            if (event.ctrlKey) {\n                event.preventDefault(); // stop native page zoom for pinch zooming\n            }\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        else {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        const isWheel = event.type === 'wheel';\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && isWheel && !event.ctrlKey;\n        const hasNoWheelClass = isWrappedWithClass(event, noWheelClassName);\n        // if user is pinch zooming above a nowheel element, we don't want the browser to zoom\n        if (event.ctrlKey && isWheel && hasNoWheelClass) {\n            event.preventDefault();\n        }\n        if (preventZoom || hasNoWheelClass) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, connectionInProgress, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        const isWheelEvent = event.type === 'wheel';\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // we want to disable pinch-zooming while making a connection\n        if (connectionInProgress && !isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && isWheelEvent) {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (!isWheelEvent || (panOnScroll && isWheelEvent && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && isWheelEvent) {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && isWheelEvent) {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || isWheelEvent) && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).transform(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, connectionInProgress, paneClickDistance, selectionOnDrag, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        d3ZoomInstance.clickDistance(selectionOnDrag ? Infinity : !isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance);\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n            connectionInProgress,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleTo(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.interpolate(options?.interpolate === 'linear' ? d3_interpolate__WEBPACK_IMPORTED_MODULE_4__[\"default\"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_5__[\"default\"]).scaleBy(getD3Transition(d3Selection, options?.duration, options?.ease, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    let params = {\n        controlDirection: getControlDirection('bottom-right'),\n        boundaries: {\n            minWidth: 0,\n            minHeight: 0,\n            maxWidth: Number.MAX_VALUE,\n            maxHeight: Number.MAX_VALUE,\n        },\n        resizeDirection: undefined,\n        keepAspectRatio: false,\n    };\n    function update({ controlPosition, boundaries, keepAspectRatio, resizeDirection, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        params = {\n            boundaries,\n            resizeDirection,\n            keepAspectRatio,\n            controlDirection: getControlDirection(controlPosition),\n        };\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        // we only want to trigger onResizeEnd if onResize was actually called\n        let resizeDetected = false;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, params.controlDirection, pointerPosition, params.boundaries, params.keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width =\n                    isWidthChange && (!params.resizeDirection || params.resizeDirection === 'horizontal')\n                        ? width\n                        : prevValues.width;\n                change.height =\n                    isHeightChange && (!params.resizeDirection || params.resizeDirection === 'vertical')\n                        ? height\n                        : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: params.controlDirection.affectsX,\n                affectsY: params.controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            resizeDetected = true;\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            if (!resizeDetected) {\n                return;\n            }\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.({ ...prevValues });\n            resizeDetected = false;\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2dCO0FBQ2E7QUFDRTs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQiw0QkFBNEIsVUFBVSxxQkFBcUIsRUFBRSxPQUFPLEVBQUU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQixZQUFZLDJCQUEyQjtBQUN2QztBQUNBLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksMkNBQTJDO0FBQ3ZELFlBQVksNEVBQTRFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFpRDtBQUN0RSxzQkFBc0Isd0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9IQUFvSDtBQUMxSSwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtREFBSTtBQUNoQztBQUNBLG9CQUFvQix1RUFBdUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLCtEQUErRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUEyRDtBQUMvRTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQsc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1rRCIsInNvdXJjZXMiOlsid2VicGFjazovL2ludmVuZS1vcmNoZXN0cmF0b3IvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanM/NzgzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkcmFnIH0gZnJvbSAnZDMtZHJhZyc7XG5pbXBvcnQgeyBzZWxlY3QsIHBvaW50ZXIgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgem9vbSwgem9vbUlkZW50aXR5LCB6b29tVHJhbnNmb3JtIH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZVpvb20sIGludGVycG9sYXRlIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIGVycm9yMDAxOiAoKSA9PiAnW1JlYWN0IEZsb3ddOiBTZWVtcyBsaWtlIHlvdSBoYXZlIG5vdCB1c2VkIHp1c3RhbmQgcHJvdmlkZXIgYXMgYW4gYW5jZXN0b3IuIEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMwMDEnLFxuICAgIGVycm9yMDAyOiAoKSA9PiBcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGNyZWF0ZWQgYSBuZXcgbm9kZVR5cGVzIG9yIGVkZ2VUeXBlcyBvYmplY3QuIElmIHRoaXMgd2Fzbid0IG9uIHB1cnBvc2UgcGxlYXNlIGRlZmluZSB0aGUgbm9kZVR5cGVzL2VkZ2VUeXBlcyBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgb3IgbWVtb2l6ZSB0aGVtLlwiLFxuICAgIGVycm9yMDAzOiAobm9kZVR5cGUpID0+IGBOb2RlIHR5cGUgXCIke25vZGVUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDA0OiAoKSA9PiAnVGhlIFJlYWN0IEZsb3cgcGFyZW50IGNvbnRhaW5lciBuZWVkcyBhIHdpZHRoIGFuZCBhIGhlaWdodCB0byByZW5kZXIgdGhlIGdyYXBoLicsXG4gICAgZXJyb3IwMDU6ICgpID0+ICdPbmx5IGNoaWxkIG5vZGVzIGNhbiB1c2UgYSBwYXJlbnQgZXh0ZW50LicsXG4gICAgZXJyb3IwMDY6ICgpID0+IFwiQ2FuJ3QgY3JlYXRlIGVkZ2UuIEFuIGVkZ2UgbmVlZHMgYSBzb3VyY2UgYW5kIGEgdGFyZ2V0LlwiLFxuICAgIGVycm9yMDA3OiAoaWQpID0+IGBUaGUgb2xkIGVkZ2Ugd2l0aCBpZD0ke2lkfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgIGVycm9yMDA5OiAodHlwZSkgPT4gYE1hcmtlciB0eXBlIFwiJHt0eXBlfVwiIGRvZXNuJ3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwODogKGhhbmRsZVR5cGUsIHsgaWQsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH0pID0+IGBDb3VsZG4ndCBjcmVhdGUgZWRnZSBmb3IgJHtoYW5kbGVUeXBlfSBoYW5kbGUgaWQ6IFwiJHtoYW5kbGVUeXBlID09PSAnc291cmNlJyA/IHNvdXJjZUhhbmRsZSA6IHRhcmdldEhhbmRsZX1cIiwgZWRnZSBpZDogJHtpZH0uYCxcbiAgICBlcnJvcjAxMDogKCkgPT4gJ0hhbmRsZTogTm8gbm9kZSBpZCBmb3VuZC4gTWFrZSBzdXJlIHRvIG9ubHkgdXNlIGEgSGFuZGxlIGluc2lkZSBhIGN1c3RvbSBOb2RlLicsXG4gICAgZXJyb3IwMTE6IChlZGdlVHlwZSkgPT4gYEVkZ2UgdHlwZSBcIiR7ZWRnZVR5cGV9XCIgbm90IGZvdW5kLiBVc2luZyBmYWxsYmFjayB0eXBlIFwiZGVmYXVsdFwiLmAsXG4gICAgZXJyb3IwMTI6IChpZCkgPT4gYE5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgZG9lcyBub3QgZXhpc3QsIGl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBub2RlIGlzIGRlbGV0ZWQgYmVmb3JlIHRoZSBcIm9uTm9kZUNsaWNrXCIgaGFuZGxlciBpcyBjYWxsZWQuYCxcbiAgICBlcnJvcjAxMzogKGxpYiA9ICdyZWFjdCcpID0+IGBJdCBzZWVtcyB0aGF0IHlvdSBoYXZlbid0IGxvYWRlZCB0aGUgc3R5bGVzLiBQbGVhc2UgaW1wb3J0ICdAeHlmbG93LyR7bGlifS9kaXN0L3N0eWxlLmNzcycgb3IgYmFzZS5jc3MgdG8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgaXMgd29ya2luZyBwcm9wZXJseS5gLFxuICAgIGVycm9yMDE0OiAoKSA9PiAndXNlTm9kZUNvbm5lY3Rpb25zOiBObyBub2RlIElEIGZvdW5kLiBDYWxsIHVzZU5vZGVDb25uZWN0aW9ucyBpbnNpZGUgYSBjdXN0b20gTm9kZSBvciBwcm92aWRlIGEgbm9kZSBJRC4nLFxuICAgIGVycm9yMDE1OiAoKSA9PiAnSXQgc2VlbXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBkcmFnIGEgbm9kZSB0aGF0IGlzIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIHVzZSBvbk5vZGVzQ2hhbmdlIGFzIGV4cGxhaW5lZCBpbiB0aGUgZG9jcy4nLFxufTtcbmNvbnN0IGluZmluaXRlRXh0ZW50ID0gW1xuICAgIFtOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXG4gICAgW051bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSxcbl07XG5jb25zdCBlbGVtZW50U2VsZWN0aW9uS2V5cyA9IFsnRW50ZXInLCAnICcsICdFc2NhcGUnXTtcbmNvbnN0IGRlZmF1bHRBcmlhTGFiZWxDb25maWcgPSB7XG4gICAgJ25vZGUuYTExeURlc2NyaXB0aW9uLmRlZmF1bHQnOiAnUHJlc3MgZW50ZXIgb3Igc3BhY2UgdG8gc2VsZWN0IGEgbm9kZS4gUHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBhbmQgZXNjYXBlIHRvIGNhbmNlbC4nLFxuICAgICdub2RlLmExMXlEZXNjcmlwdGlvbi5rZXlib2FyZERpc2FibGVkJzogJ1ByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhIG5vZGUuIFlvdSBjYW4gdGhlbiB1c2UgdGhlIGFycm93IGtleXMgdG8gbW92ZSB0aGUgbm9kZSBhcm91bmQuIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuJyxcbiAgICAnbm9kZS5hMTF5RGVzY3JpcHRpb24uYXJpYUxpdmVNZXNzYWdlJzogKHsgZGlyZWN0aW9uLCB4LCB5IH0pID0+IGBNb3ZlZCBzZWxlY3RlZCBub2RlICR7ZGlyZWN0aW9ufS4gTmV3IHBvc2l0aW9uLCB4OiAke3h9LCB5OiAke3l9YCxcbiAgICAnZWRnZS5hMTF5RGVzY3JpcHRpb24uZGVmYXVsdCc6ICdQcmVzcyBlbnRlciBvciBzcGFjZSB0byBzZWxlY3QgYW4gZWRnZS4gWW91IGNhbiB0aGVuIHByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgb3IgZXNjYXBlIHRvIGNhbmNlbC4nLFxuICAgIC8vIENvbnRyb2wgZWxlbWVudHNcbiAgICAnY29udHJvbHMuYXJpYUxhYmVsJzogJ0NvbnRyb2wgUGFuZWwnLFxuICAgICdjb250cm9scy56b29tSW4uYXJpYUxhYmVsJzogJ1pvb20gSW4nLFxuICAgICdjb250cm9scy56b29tT3V0LmFyaWFMYWJlbCc6ICdab29tIE91dCcsXG4gICAgJ2NvbnRyb2xzLmZpdFZpZXcuYXJpYUxhYmVsJzogJ0ZpdCBWaWV3JyxcbiAgICAnY29udHJvbHMuaW50ZXJhY3RpdmUuYXJpYUxhYmVsJzogJ1RvZ2dsZSBJbnRlcmFjdGl2aXR5JyxcbiAgICAvLyBNaW5pIG1hcFxuICAgICdtaW5pbWFwLmFyaWFMYWJlbCc6ICdNaW5pIE1hcCcsXG4gICAgLy8gSGFuZGxlXG4gICAgJ2hhbmRsZS5hcmlhTGFiZWwnOiAnSGFuZGxlJyxcbn07XG5cbi8qKlxuICogVGhlIGBDb25uZWN0aW9uTW9kZWAgaXMgdXNlZCB0byBzZXQgdGhlIG1vZGUgb2YgY29ubmVjdGlvbiBiZXR3ZWVuIG5vZGVzLlxuICogVGhlIGBTdHJpY3RgIG1vZGUgaXMgdGhlIGRlZmF1bHQgb25lIGFuZCBvbmx5IGFsbG93cyBzb3VyY2UgdG8gdGFyZ2V0IGVkZ2VzLlxuICogYExvb3NlYCBtb2RlIGFsbG93cyBzb3VyY2UgdG8gc291cmNlIGFuZCB0YXJnZXQgdG8gdGFyZ2V0IGVkZ2VzIGFzIHdlbGwuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgQ29ubmVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25Nb2RlKSB7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJTdHJpY3RcIl0gPSBcInN0cmljdFwiO1xuICAgIENvbm5lY3Rpb25Nb2RlW1wiTG9vc2VcIl0gPSBcImxvb3NlXCI7XG59KShDb25uZWN0aW9uTW9kZSB8fCAoQ29ubmVjdGlvbk1vZGUgPSB7fSkpO1xuLyoqXG4gKiBUaGlzIGVudW0gaXMgdXNlZCB0byBzZXQgdGhlIGRpZmZlcmVudCBtb2RlcyBvZiBwYW5uaW5nIHRoZSB2aWV3cG9ydCB3aGVuIHRoZVxuICogdXNlciBzY3JvbGxzLiBUaGUgYEZyZWVgIG1vZGUgYWxsb3dzIHRoZSB1c2VyIHRvIHBhbiBpbiBhbnkgZGlyZWN0aW9uIGJ5IHNjcm9sbGluZ1xuICogd2l0aCBhIGRldmljZSBsaWtlIGEgdHJhY2twYWQuIFRoZSBgVmVydGljYWxgIGFuZCBgSG9yaXpvbnRhbGAgbW9kZXMgcmVzdHJpY3RcbiAqIHNjcm9sbCBwYW5uaW5nIHRvIG9ubHkgdGhlIHZlcnRpY2FsIG9yIGhvcml6b250YWwgYXhpcywgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFBhbk9uU2Nyb2xsTW9kZTtcbihmdW5jdGlvbiAoUGFuT25TY3JvbGxNb2RlKSB7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiRnJlZVwiXSA9IFwiZnJlZVwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIlZlcnRpY2FsXCJdID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIFBhbk9uU2Nyb2xsTW9kZVtcIkhvcml6b250YWxcIl0gPSBcImhvcml6b250YWxcIjtcbn0pKFBhbk9uU2Nyb2xsTW9kZSB8fCAoUGFuT25TY3JvbGxNb2RlID0ge30pKTtcbnZhciBTZWxlY3Rpb25Nb2RlO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25Nb2RlKSB7XG4gICAgU2VsZWN0aW9uTW9kZVtcIlBhcnRpYWxcIl0gPSBcInBhcnRpYWxcIjtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiRnVsbFwiXSA9IFwiZnVsbFwiO1xufSkoU2VsZWN0aW9uTW9kZSB8fCAoU2VsZWN0aW9uTW9kZSA9IHt9KSk7XG5jb25zdCBpbml0aWFsQ29ubmVjdGlvbiA9IHtcbiAgICBpblByb2dyZXNzOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBudWxsLFxuICAgIGZyb206IG51bGwsXG4gICAgZnJvbUhhbmRsZTogbnVsbCxcbiAgICBmcm9tUG9zaXRpb246IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG86IG51bGwsXG4gICAgdG9IYW5kbGU6IG51bGwsXG4gICAgdG9Qb3NpdGlvbjogbnVsbCxcbiAgICB0b05vZGU6IG51bGwsXG4gICAgcG9pbnRlcjogbnVsbCxcbn07XG5cbi8qKlxuICogSWYgeW91IHNldCB0aGUgYGNvbm5lY3Rpb25MaW5lVHlwZWAgcHJvcCBvbiB5b3VyIFtgPFJlYWN0RmxvdyAvPmBdKC9hcGktcmVmZXJlbmNlL3JlYWN0LWZsb3cjY29ubmVjdGlvbi1jb25uZWN0aW9uTGluZVR5cGUpXG4gKmNvbXBvbmVudCwgaXQgd2lsbCBkaWN0YXRlIHRoZSBzdHlsZSBvZiBjb25uZWN0aW9uIGxpbmUgcmVuZGVyZWQgd2hlbiBjcmVhdGluZ1xuICpuZXcgZWRnZXMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEByZW1hcmtzIElmIHlvdSBjaG9vc2UgdG8gcmVuZGVyIGEgY3VzdG9tIGNvbm5lY3Rpb24gbGluZSBjb21wb25lbnQsIHRoaXMgdmFsdWUgd2lsbCBiZVxuICpwYXNzZWQgdG8geW91ciBjb21wb25lbnQgYXMgcGFydCBvZiBpdHMgW2BDb25uZWN0aW9uTGluZUNvbXBvbmVudFByb3BzYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvY29ubmVjdGlvbi1saW5lLWNvbXBvbmVudC1wcm9wcykuXG4gKi9cbnZhciBDb25uZWN0aW9uTGluZVR5cGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25MaW5lVHlwZSkge1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIkJlemllclwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0cmFpZ2h0XCJdID0gXCJzdHJhaWdodFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0ZXBcIl0gPSBcInN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTbW9vdGhTdGVwXCJdID0gXCJzbW9vdGhzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU2ltcGxlQmV6aWVyXCJdID0gXCJzaW1wbGViZXppZXJcIjtcbn0pKENvbm5lY3Rpb25MaW5lVHlwZSB8fCAoQ29ubmVjdGlvbkxpbmVUeXBlID0ge30pKTtcbi8qKlxuICogRWRnZXMgbWF5IG9wdGlvbmFsbHkgaGF2ZSBhIG1hcmtlciBvbiBlaXRoZXIgZW5kLiBUaGUgTWFya2VyVHlwZSB0eXBlIGVudW1lcmF0ZXNcbiAqIHRoZSBvcHRpb25zIGF2YWlsYWJsZSB0byB5b3Ugd2hlbiBjb25maWd1cmluZyBhIGdpdmVuIG1hcmtlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNYXJrZXJUeXBlO1xuKGZ1bmN0aW9uIChNYXJrZXJUeXBlKSB7XG4gICAgTWFya2VyVHlwZVtcIkFycm93XCJdID0gXCJhcnJvd1wiO1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd0Nsb3NlZFwiXSA9IFwiYXJyb3djbG9zZWRcIjtcbn0pKE1hcmtlclR5cGUgfHwgKE1hcmtlclR5cGUgPSB7fSkpO1xuXG4vKipcbiAqIFdoaWxlIFtgUGFuZWxQb3NpdGlvbmBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL3BhbmVsLXBvc2l0aW9uKSBjYW4gYmUgdXNlZCB0byBwbGFjZSBhXG4gKiBjb21wb25lbnQgaW4gdGhlIGNvcm5lcnMgb2YgYSBjb250YWluZXIsIHRoZSBgUG9zaXRpb25gIGVudW0gaXMgbGVzcyBwcmVjaXNlIGFuZCB1c2VkXG4gKiBwcmltYXJpbHkgaW4gcmVsYXRpb24gdG8gZWRnZXMgYW5kIGhhbmRsZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgUG9zaXRpb25bXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgUG9zaXRpb25bXCJUb3BcIl0gPSBcInRvcFwiO1xuICAgIFBvc2l0aW9uW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgUG9zaXRpb25bXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbmNvbnN0IG9wcG9zaXRlUG9zaXRpb24gPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiBQb3NpdGlvbi5SaWdodCxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiBQb3NpdGlvbi5MZWZ0LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiBQb3NpdGlvbi5Cb3R0b20sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IFBvc2l0aW9uLlRvcCxcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwoYSwgYikge1xuICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhIHx8ICFiIHx8IGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhLnNpemUgJiYgIWIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdlIGNhbGwgdGhlIGNhbGxiYWNrIGZvciBhbGwgY29ubmVjdGlvbnMgaW4gYSB0aGF0IGFyZSBub3QgaW4gYlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKGEsIGIsIGNiKSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBbXTtcbiAgICBhLmZvckVhY2goKGNvbm5lY3Rpb24sIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWI/LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBkaWZmLnB1c2goY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlmZi5sZW5ndGgpIHtcbiAgICAgICAgY2IoZGlmZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQgPT09IG51bGwgPyBudWxsIDogaXNWYWxpZCA/ICd2YWxpZCcgOiAnaW52YWxpZCc7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2FibGUgYXMgYW4gRWRnZVxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIEVkZ2UgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYW4gRWRnZVxuICovXG5jb25zdCBpc0VkZ2VCYXNlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAnc291cmNlJyBpbiBlbGVtZW50ICYmICd0YXJnZXQnIGluIGVsZW1lbnQ7XG4vKipcbiAqIFRlc3Qgd2hldGhlciBhbiBvYmplY3QgaXMgdXNhYmxlIGFzIGEgTm9kZVxuICogQHB1YmxpY1xuICogQHJlbWFya3MgSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvIE5vZGUgaWYgaXQgcmV0dXJucyB0cnVlXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHRlc3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYW4gTm9kZVxuICovXG5jb25zdCBpc05vZGVCYXNlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAncG9zaXRpb24nIGluIGVsZW1lbnQgJiYgISgnc291cmNlJyBpbiBlbGVtZW50KSAmJiAhKCd0YXJnZXQnIGluIGVsZW1lbnQpO1xuY29uc3QgaXNJbnRlcm5hbE5vZGVCYXNlID0gKGVsZW1lbnQpID0+ICdpZCcgaW4gZWxlbWVudCAmJiAnaW50ZXJuYWxzJyBpbiBlbGVtZW50ICYmICEoJ3NvdXJjZScgaW4gZWxlbWVudCkgJiYgISgndGFyZ2V0JyBpbiBlbGVtZW50KTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gdGVsbCB5b3Ugd2hhdCBub2RlcywgaWYgYW55LCBhcmUgY29ubmVjdGVkIHRvIHRoZSBnaXZlbiBub2RlXG4gKiBhcyB0aGUgX3RhcmdldF8gb2YgYW4gZWRnZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgbm9kZXMgZnJvbS5cbiAqIEBwYXJhbSBub2RlcyAtIFRoZSBhcnJheSBvZiBhbGwgbm9kZXMuXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGVkZ2VzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCBhcmUgY29ubmVjdGVkIG92ZXIgZWRnZXMgd2hlcmUgdGhlIHNvdXJjZSBpcyB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqaW1wb3J0IHsgZ2V0T3V0Z29lcnMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW107XG4gKmNvbnN0IGVkZ2VzID0gW107XG4gKlxuICpjb25zdCBvdXRnb2VycyA9IGdldE91dGdvZXJzKFxuICogIHsgaWQ6ICcxJywgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LCBkYXRhOiB7IGxhYmVsOiAnbm9kZScgfSB9LFxuICogIG5vZGVzLFxuICogIGVkZ2VzLFxuICopO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0T3V0Z29lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFub2RlLmlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgb3V0Z29lcklkcyA9IG5ldyBTZXQoKTtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIGlmIChlZGdlLnNvdXJjZSA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgb3V0Z29lcklkcy5hZGQoZWRnZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gb3V0Z29lcklkcy5oYXMobi5pZCkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gdGVsbCB5b3Ugd2hhdCBub2RlcywgaWYgYW55LCBhcmUgY29ubmVjdGVkIHRvIHRoZSBnaXZlbiBub2RlXG4gKiBhcyB0aGUgX3NvdXJjZV8gb2YgYW4gZWRnZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgbm9kZXMgZnJvbS5cbiAqIEBwYXJhbSBub2RlcyAtIFRoZSBhcnJheSBvZiBhbGwgbm9kZXMuXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGVkZ2VzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCBhcmUgY29ubmVjdGVkIG92ZXIgZWRnZXMgd2hlcmUgdGhlIHRhcmdldCBpcyB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqaW1wb3J0IHsgZ2V0SW5jb21lcnMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW107XG4gKmNvbnN0IGVkZ2VzID0gW107XG4gKlxuICpjb25zdCBpbmNvbWVycyA9IGdldEluY29tZXJzKFxuICogIHsgaWQ6ICcxJywgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LCBkYXRhOiB7IGxhYmVsOiAnbm9kZScgfSB9LFxuICogIG5vZGVzLFxuICogIGVkZ2VzLFxuICopO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0SW5jb21lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFub2RlLmlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgaW5jb21lcnNJZHMgPSBuZXcgU2V0KCk7XG4gICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS50YXJnZXQgPT09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgIGluY29tZXJzSWRzLmFkZChlZGdlLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChuKSA9PiBpbmNvbWVyc0lkcy5oYXMobi5pZCkpO1xufTtcbmNvbnN0IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4gPSAobm9kZSwgbm9kZU9yaWdpbiA9IFswLCAwXSkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0Tm9kZURpbWVuc2lvbnMobm9kZSk7XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICBjb25zdCBvZmZzZXRYID0gd2lkdGggKiBvcmlnaW5bMF07XG4gICAgY29uc3Qgb2Zmc2V0WSA9IGhlaWdodCAqIG9yaWdpblsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBub2RlLnBvc2l0aW9uLnggLSBvZmZzZXRYLFxuICAgICAgICB5OiBub2RlLnBvc2l0aW9uLnkgLSBvZmZzZXRZLFxuICAgIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbGwgdGhlIGdpdmVuIG5vZGVzIGluIGFuIGFycmF5LiBUaGlzIGNhblxuICogYmUgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBbYGdldFZpZXdwb3J0Rm9yQm91bmRzYF0oL2FwaS1yZWZlcmVuY2UvdXRpbHMvZ2V0LXZpZXdwb3J0LWZvci1ib3VuZHMpXG4gKiB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZXMgaW4gYSB2aWV3cG9ydC5cbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIFVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGgge0BsaW5rIGdldFZpZXdwb3J0Rm9yQm91bmRzfSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHRvIGZpdCB0aGUgZ2l2ZW4gbm9kZXMgaW4gYSB2aWV3cG9ydC5cbiAqIEBwYXJhbSBub2RlcyAtIE5vZGVzIHRvIGNhbGN1bGF0ZSB0aGUgYm91bmRzIGZvci5cbiAqIEByZXR1cm5zIEJvdW5kaW5nIGJveCBlbmNsb3NpbmcgYWxsIG5vZGVzLlxuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkIGBnZXRSZWN0T2ZOb2Rlc2BcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgZ2V0Tm9kZXNCb3VuZHMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW1xuICogIHtcbiAqICAgIGlkOiAnYScsXG4gKiAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gKiAgICBkYXRhOiB7IGxhYmVsOiAnYScgfSxcbiAqICAgIHdpZHRoOiA1MCxcbiAqICAgIGhlaWdodDogMjUsXG4gKiAgfSxcbiAqICB7XG4gKiAgICBpZDogJ2InLFxuICogICAgcG9zaXRpb246IHsgeDogMTAwLCB5OiAxMDAgfSxcbiAqICAgIGRhdGE6IHsgbGFiZWw6ICdiJyB9LFxuICogICAgd2lkdGg6IDUwLFxuICogICAgaGVpZ2h0OiAyNSxcbiAqICB9LFxuICpdO1xuICpcbiAqY29uc3QgYm91bmRzID0gZ2V0Tm9kZXNCb3VuZHMobm9kZXMpO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0Tm9kZXNCb3VuZHMgPSAobm9kZXMsIHBhcmFtcyA9IHsgbm9kZU9yaWdpbjogWzAsIDBdIH0pID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIXBhcmFtcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIHVzZSBgZ2V0Tm9kZXNCb3VuZHNgIGZyb20gYHVzZVJlYWN0Rmxvd2AvYHVzZVN2ZWx0ZUZsb3dgIGhvb2sgdG8gZW5zdXJlIGNvcnJlY3QgdmFsdWVzIGZvciBzdWIgZmxvd3MuIElmIG5vdCBwb3NzaWJsZSwgeW91IGhhdmUgdG8gcHJvdmlkZSBhIG5vZGVMb29rdXAgdG8gc3VwcG9ydCBzdWIgZmxvd3MuJyk7XG4gICAgfVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIH1cbiAgICBjb25zdCBib3ggPSBub2Rlcy5yZWR1Y2UoKGN1cnJCb3gsIG5vZGVPcklkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzSWQgPSB0eXBlb2Ygbm9kZU9ySWQgPT09ICdzdHJpbmcnO1xuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSAhcGFyYW1zLm5vZGVMb29rdXAgJiYgIWlzSWQgPyBub2RlT3JJZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBhcmFtcy5ub2RlTG9va3VwKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGlzSWRcbiAgICAgICAgICAgICAgICA/IHBhcmFtcy5ub2RlTG9va3VwLmdldChub2RlT3JJZClcbiAgICAgICAgICAgICAgICA6ICFpc0ludGVybmFsTm9kZUJhc2Uobm9kZU9ySWQpXG4gICAgICAgICAgICAgICAgICAgID8gcGFyYW1zLm5vZGVMb29rdXAuZ2V0KG5vZGVPcklkLmlkKVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGVPcklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVCb3ggPSBjdXJyZW50Tm9kZSA/IG5vZGVUb0JveChjdXJyZW50Tm9kZSwgcGFyYW1zLm5vZGVPcmlnaW4pIDogeyB4OiAwLCB5OiAwLCB4MjogMCwgeTI6IDAgfTtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kc09mQm94ZXMoY3VyckJveCwgbm9kZUJveCk7XG4gICAgfSwgeyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfSk7XG4gICAgcmV0dXJuIGJveFRvUmVjdChib3gpO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyBhIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGFsbCBnaXZlbiBub2RlcyBpbiBhbiBhcnJheVxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGdldEludGVybmFsTm9kZXNCb3VuZHMgPSAobm9kZUxvb2t1cCwgcGFyYW1zID0ge30pID0+IHtcbiAgICBsZXQgYm94ID0geyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfTtcbiAgICBsZXQgaGFzVmlzaWJsZU5vZGVzID0gZmFsc2U7XG4gICAgbm9kZUxvb2t1cC5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbXMuZmlsdGVyID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmZpbHRlcihub2RlKSkge1xuICAgICAgICAgICAgYm94ID0gZ2V0Qm91bmRzT2ZCb3hlcyhib3gsIG5vZGVUb0JveChub2RlKSk7XG4gICAgICAgICAgICBoYXNWaXNpYmxlTm9kZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhhc1Zpc2libGVOb2RlcyA/IGJveFRvUmVjdChib3gpIDogeyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG59O1xuY29uc3QgZ2V0Tm9kZXNJbnNpZGUgPSAobm9kZXMsIHJlY3QsIFt0eCwgdHksIHRTY2FsZV0gPSBbMCwgMCwgMV0sIHBhcnRpYWxseSA9IGZhbHNlLCBcbi8vIHNldCBleGNsdWRlTm9uU2VsZWN0YWJsZU5vZGVzIGlmIHlvdSB3YW50IHRvIHBheSBhdHRlbnRpb24gdG8gdGhlIG5vZGVzIFwic2VsZWN0YWJsZVwiIGF0dHJpYnV0ZVxuZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgcGFuZVJlY3QgPSB7XG4gICAgICAgIC4uLnBvaW50VG9SZW5kZXJlclBvaW50KHJlY3QsIFt0eCwgdHksIHRTY2FsZV0pLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIHRTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHRTY2FsZSxcbiAgICB9O1xuICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB7IG1lYXN1cmVkLCBzZWxlY3RhYmxlID0gdHJ1ZSwgaGlkZGVuID0gZmFsc2UgfSA9IG5vZGU7XG4gICAgICAgIGlmICgoZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyAmJiAhc2VsZWN0YWJsZSkgfHwgaGlkZGVuKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVkLndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gbnVsbDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0ID8/IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyBudWxsO1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEocGFuZVJlY3QsIG5vZGVUb1JlY3Qobm9kZSkpO1xuICAgICAgICBjb25zdCBhcmVhID0gKHdpZHRoID8/IDApICogKGhlaWdodCA/PyAwKTtcbiAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICBjb25zdCBmb3JjZUluaXRpYWxSZW5kZXIgPSAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBmb3JjZUluaXRpYWxSZW5kZXIgfHwgcGFydGlhbGx5VmlzaWJsZSB8fCBvdmVybGFwcGluZ0FyZWEgPj0gYXJlYTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCBub2RlLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZU5vZGVzO1xufTtcbi8qKlxuICogVGhpcyB1dGlsaXR5IGZpbHRlcnMgYW4gYXJyYXkgb2YgZWRnZXMsIGtlZXBpbmcgb25seSB0aG9zZSB3aGVyZSBlaXRoZXIgdGhlIHNvdXJjZSBvciB0YXJnZXRcbiAqIG5vZGUgaXMgcHJlc2VudCBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB5b3Ugd2FudCB0byBnZXQgdGhlIGNvbm5lY3RlZCBlZGdlcyBmb3IuXG4gKiBAcGFyYW0gZWRnZXMgLSBBbGwgZWRnZXMuXG4gKiBAcmV0dXJucyBBcnJheSBvZiBlZGdlcyB0aGF0IGNvbm5lY3QgYW55IG9mIHRoZSBnaXZlbiBub2RlcyB3aXRoIGVhY2ggb3RoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGdldENvbm5lY3RlZEVkZ2VzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtcbiAqICB7IGlkOiAnYScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSB9LFxuICogIHsgaWQ6ICdiJywgcG9zaXRpb246IHsgeDogMTAwLCB5OiAwIH0gfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGVkZ2VzID0gW1xuICogIHsgaWQ6ICdhLT5jJywgc291cmNlOiAnYScsIHRhcmdldDogJ2MnIH0sXG4gKiAgeyBpZDogJ2MtPmQnLCBzb3VyY2U6ICdjJywgdGFyZ2V0OiAnZCcgfSxcbiAqXTtcbiAqXG4gKmNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobm9kZXMsIGVkZ2VzKTtcbiAqIC8vID0+IFt7IGlkOiAnYS0+YycsIHNvdXJjZTogJ2EnLCB0YXJnZXQ6ICdjJyB9XVxuICpgYGBcbiAqL1xuY29uc3QgZ2V0Q29ubmVjdGVkRWRnZXMgPSAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQoKTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIG5vZGVJZHMuYWRkKG5vZGUuaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IG5vZGVJZHMuaGFzKGVkZ2Uuc291cmNlKSB8fCBub2RlSWRzLmhhcyhlZGdlLnRhcmdldCkpO1xufTtcbmZ1bmN0aW9uIGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZml0Vmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9wdGlvbk5vZGVJZHMgPSBvcHRpb25zPy5ub2RlcyA/IG5ldyBTZXQob3B0aW9ucy5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKSA6IG51bGw7XG4gICAgbm9kZUxvb2t1cC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IG4ubWVhc3VyZWQud2lkdGggJiYgbi5tZWFzdXJlZC5oZWlnaHQgJiYgKG9wdGlvbnM/LmluY2x1ZGVIaWRkZW5Ob2RlcyB8fCAhbi5oaWRkZW4pO1xuICAgICAgICBpZiAoaXNWaXNpYmxlICYmICghb3B0aW9uTm9kZUlkcyB8fCBvcHRpb25Ob2RlSWRzLmhhcyhuLmlkKSkpIHtcbiAgICAgICAgICAgIGZpdFZpZXdOb2Rlcy5zZXQobi5pZCwgbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZml0Vmlld05vZGVzO1xufVxuYXN5bmMgZnVuY3Rpb24gZml0Vmlld3BvcnQoeyBub2Rlcywgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgbWluWm9vbSwgbWF4Wm9vbSB9LCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXNUb0ZpdCA9IGdldEZpdFZpZXdOb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgYm91bmRzID0gZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyhub2Rlc1RvRml0KTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucz8ubWluWm9vbSA/PyBtaW5ab29tLCBvcHRpb25zPy5tYXhab29tID8/IG1heFpvb20sIG9wdGlvbnM/LnBhZGRpbmcgPz8gMC4xKTtcbiAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHZpZXdwb3J0LCB7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbixcbiAgICAgICAgZWFzZTogb3B0aW9ucz8uZWFzZSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IG9wdGlvbnM/LmludGVycG9sYXRlLFxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgbmV4dCBwb3NpdGlvbiBvZiBhIG5vZGUsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIG5vZGUncyBleHRlbnQsIHBhcmVudCBub2RlLCBhbmQgb3JpZ2luLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGVcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHsgbm9kZUlkLCBuZXh0UG9zaXRpb24sIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0sIG5vZGVFeHRlbnQsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRJZCA/IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgOiB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgIGxldCBleHRlbnQgPSBub2RlLmV4dGVudCB8fCBub2RlRXh0ZW50O1xuICAgIGlmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgJiYgIW5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnROb2RlLm1lYXN1cmVkLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SGVpZ2h0ID0gcGFyZW50Tm9kZS5tZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocGFyZW50V2lkdGggJiYgcGFyZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Tm9kZSAmJiBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpKSB7XG4gICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgZXh0ZW50LCBub2RlLm1lYXN1cmVkKVxuICAgICAgICA6IG5leHRQb3NpdGlvbjtcbiAgICBpZiAobm9kZS5tZWFzdXJlZC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxNSddKCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zaXRpb25BYnNvbHV0ZS54IC0gcGFyZW50WCArIChub2RlLm1lYXN1cmVkLndpZHRoID8/IDApICogb3JpZ2luWzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb25BYnNvbHV0ZS55IC0gcGFyZW50WSArIChub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwKSAqIG9yaWdpblsxXSxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYXNzIGluIG5vZGVzICYgZWRnZXMgdG8gZGVsZXRlLCBnZXQgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcyB0aGF0IGFjdHVhbGx5IGNhbiBiZSBkZWxldGVkXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYXJhbS5ub2Rlc1RvUmVtb3ZlIC0gVGhlIG5vZGVzIHRvIHJlbW92ZVxuICogQHBhcmFtIHBhcmFtLmVkZ2VzVG9SZW1vdmUgLSBUaGUgZWRnZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcGFyYW0ubm9kZXMgLSBBbGwgbm9kZXNcbiAqIEBwYXJhbSBwYXJhbS5lZGdlcyAtIEFsbCBlZGdlc1xuICogQHBhcmFtIHBhcmFtLm9uQmVmb3JlRGVsZXRlIC0gQ2FsbGJhY2sgdG8gY2hlY2sgd2hpY2ggbm9kZXMgYW5kIGVkZ2VzIGNhbiBiZSBkZWxldGVkXG4gKiBAcmV0dXJucyBub2Rlczogbm9kZXMgdGhhdCBjYW4gYmUgZGVsZXRlZCwgZWRnZXM6IGVkZ2VzIHRoYXQgY2FuIGJlIGRlbGV0ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudHNUb1JlbW92ZSh7IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXNUb1JlbW92ZSA9IFtdLCBub2RlcywgZWRnZXMsIG9uQmVmb3JlRGVsZXRlLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQobm9kZXNUb1JlbW92ZS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAgICBjb25zdCBtYXRjaGluZ05vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLmRlbGV0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBub2RlSWRzLmhhcyhub2RlLmlkKTtcbiAgICAgICAgY29uc3QgcGFyZW50SGl0ID0gIWlzSW5jbHVkZWQgJiYgbm9kZS5wYXJlbnRJZCAmJiBtYXRjaGluZ05vZGVzLmZpbmQoKG4pID0+IG4uaWQgPT09IG5vZGUucGFyZW50SWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCB8fCBwYXJlbnRIaXQpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGdlSWRzID0gbmV3IFNldChlZGdlc1RvUmVtb3ZlLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCkpO1xuICAgIGNvbnN0IGRlbGV0YWJsZUVkZ2VzID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLmRlbGV0YWJsZSAhPT0gZmFsc2UpO1xuICAgIGNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobWF0Y2hpbmdOb2RlcywgZGVsZXRhYmxlRWRnZXMpO1xuICAgIGNvbnN0IG1hdGNoaW5nRWRnZXMgPSBjb25uZWN0ZWRFZGdlcztcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZGVsZXRhYmxlRWRnZXMpIHtcbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IGVkZ2VJZHMuaGFzKGVkZ2UuaWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCAmJiAhbWF0Y2hpbmdFZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBlZGdlLmlkKSkge1xuICAgICAgICAgICAgbWF0Y2hpbmdFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb25CZWZvcmVEZWxldGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLFxuICAgICAgICAgICAgbm9kZXM6IG1hdGNoaW5nTm9kZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9uQmVmb3JlRGVsZXRlUmVzdWx0ID0gYXdhaXQgb25CZWZvcmVEZWxldGUoe1xuICAgICAgICBub2RlczogbWF0Y2hpbmdOb2RlcyxcbiAgICAgICAgZWRnZXM6IG1hdGNoaW5nRWRnZXMsXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA/IHsgZWRnZXM6IG1hdGNoaW5nRWRnZXMsIG5vZGVzOiBtYXRjaGluZ05vZGVzIH0gOiB7IGVkZ2VzOiBbXSwgbm9kZXM6IFtdIH07XG4gICAgfVxuICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdDtcbn1cblxuY29uc3QgY2xhbXAgPSAodmFsLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG5jb25zdCBjbGFtcFBvc2l0aW9uID0gKHBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH0sIGV4dGVudCwgZGltZW5zaW9ucykgPT4gKHtcbiAgICB4OiBjbGFtcChwb3NpdGlvbi54LCBleHRlbnRbMF1bMF0sIGV4dGVudFsxXVswXSAtIChkaW1lbnNpb25zPy53aWR0aCA/PyAwKSksXG4gICAgeTogY2xhbXAocG9zaXRpb24ueSwgZXh0ZW50WzBdWzFdLCBleHRlbnRbMV1bMV0gLSAoZGltZW5zaW9ucz8uaGVpZ2h0ID8/IDApKSxcbn0pO1xuZnVuY3Rpb24gY2xhbXBQb3NpdGlvblRvUGFyZW50KGNoaWxkUG9zaXRpb24sIGNoaWxkRGltZW5zaW9ucywgcGFyZW50KSB7XG4gICAgY29uc3QgeyB3aWR0aDogcGFyZW50V2lkdGgsIGhlaWdodDogcGFyZW50SGVpZ2h0IH0gPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIHJldHVybiBjbGFtcFBvc2l0aW9uKGNoaWxkUG9zaXRpb24sIFtcbiAgICAgICAgW3BhcmVudFgsIHBhcmVudFldLFxuICAgICAgICBbcGFyZW50WCArIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcGFyZW50SGVpZ2h0XSxcbiAgICBdLCBjaGlsZERpbWVuc2lvbnMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB2ZWxvY2l0eSBvZiBwYW5uaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXNcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZhbHVlIC0gT25lIGRpbWVuc2lvbmFsIHBvaXRpb24gb2YgdGhlIG1vdXNlICh4IG9yIHkpXG4gKiBAcGFyYW0gbWluIC0gTWluaW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcGFyYW0gbWF4IC0gTWF4aW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcmV0dXJucyAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB0aGF0IHJlcHJlc2VudHMgdGhlIHZlbG9jaXR5IG9mIHBhbm5pbmdcbiAqL1xuY29uc3QgY2FsY0F1dG9QYW5WZWxvY2l0eSA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWluKSwgMSwgbWluKSAvIG1pbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIC1jbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1heCksIDEsIG1pbikgLyBtaW47XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IGNhbGNBdXRvUGFuID0gKHBvcywgYm91bmRzLCBzcGVlZCA9IDE1LCBkaXN0YW5jZSA9IDQwKSA9PiB7XG4gICAgY29uc3QgeE1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueCwgZGlzdGFuY2UsIGJvdW5kcy53aWR0aCAtIGRpc3RhbmNlKSAqIHNwZWVkO1xuICAgIGNvbnN0IHlNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLnksIGRpc3RhbmNlLCBib3VuZHMuaGVpZ2h0IC0gZGlzdGFuY2UpICogc3BlZWQ7XG4gICAgcmV0dXJuIFt4TW92ZW1lbnQsIHlNb3ZlbWVudF07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZCb3hlcyA9IChib3gxLCBib3gyKSA9PiAoe1xuICAgIHg6IE1hdGgubWluKGJveDEueCwgYm94Mi54KSxcbiAgICB5OiBNYXRoLm1pbihib3gxLnksIGJveDIueSksXG4gICAgeDI6IE1hdGgubWF4KGJveDEueDIsIGJveDIueDIpLFxuICAgIHkyOiBNYXRoLm1heChib3gxLnkyLCBib3gyLnkyKSxcbn0pO1xuY29uc3QgcmVjdFRvQm94ID0gKHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB4MjogeCArIHdpZHRoLFxuICAgIHkyOiB5ICsgaGVpZ2h0LFxufSk7XG5jb25zdCBib3hUb1JlY3QgPSAoeyB4LCB5LCB4MiwgeTIgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHgyIC0geCxcbiAgICBoZWlnaHQ6IHkyIC0geSxcbn0pO1xuY29uc3Qgbm9kZVRvUmVjdCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCxcbiAgICB9O1xufTtcbmNvbnN0IG5vZGVUb0JveCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB4MjogeCArIChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDApLFxuICAgICAgICB5MjogeSArIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDApLFxuICAgIH07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZSZWN0cyA9IChyZWN0MSwgcmVjdDIpID0+IGJveFRvUmVjdChnZXRCb3VuZHNPZkJveGVzKHJlY3RUb0JveChyZWN0MSksIHJlY3RUb0JveChyZWN0MikpKTtcbmNvbnN0IGdldE92ZXJsYXBwaW5nQXJlYSA9IChyZWN0QSwgcmVjdEIpID0+IHtcbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnggKyByZWN0QS53aWR0aCwgcmVjdEIueCArIHJlY3RCLndpZHRoKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnkgKyByZWN0QS5oZWlnaHQsIHJlY3RCLnkgKyByZWN0Qi5oZWlnaHQpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSkpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoeE92ZXJsYXAgKiB5T3ZlcmxhcCk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGlzUmVjdE9iamVjdCA9IChvYmopID0+IGlzTnVtZXJpYyhvYmoud2lkdGgpICYmIGlzTnVtZXJpYyhvYmouaGVpZ2h0KSAmJiBpc051bWVyaWMob2JqLngpICYmIGlzTnVtZXJpYyhvYmoueSk7XG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgaXNOdW1lcmljID0gKG4pID0+ICFpc05hTihuKSAmJiBpc0Zpbml0ZShuKTtcbi8vIHVzZWQgZm9yIGExMXkga2V5IGJvYXJkIGNvbnRyb2xzIGZvciBub2RlcyBhbmQgZWRnZXNcbmNvbnN0IGRldldhcm4gPSAoaWQsIG1lc3NhZ2UpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbUmVhY3QgRmxvd106ICR7bWVzc2FnZX0gSGVscDogaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2Vycm9yIyR7aWR9YCk7XG4gICAgfVxufTtcbmNvbnN0IHNuYXBQb3NpdGlvbiA9IChwb3NpdGlvbiwgc25hcEdyaWQgPSBbMSwgMV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQocG9zaXRpb24ueCAvIHNuYXBHcmlkWzBdKSxcbiAgICAgICAgeTogc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnkgLyBzbmFwR3JpZFsxXSksXG4gICAgfTtcbn07XG5jb25zdCBwb2ludFRvUmVuZGVyZXJQb2ludCA9ICh7IHgsIHkgfSwgW3R4LCB0eSwgdFNjYWxlXSwgc25hcFRvR3JpZCA9IGZhbHNlLCBzbmFwR3JpZCA9IFsxLCAxXSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICB4OiAoeCAtIHR4KSAvIHRTY2FsZSxcbiAgICAgICAgeTogKHkgLSB0eSkgLyB0U2NhbGUsXG4gICAgfTtcbiAgICByZXR1cm4gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb3NpdGlvbiwgc25hcEdyaWQpIDogcG9zaXRpb247XG59O1xuY29uc3QgcmVuZGVyZXJQb2ludFRvUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICogdFNjYWxlICsgdHgsXG4gICAgICAgIHk6IHkgKiB0U2NhbGUgKyB0eSxcbiAgICB9O1xufTtcbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIHBhZGRpbmcgdmFsdWUgdG8gYSBudW1iZXJcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBhZGRpbmcgLSBQYWRkaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0gdmlld3BvcnQgLSBXaWR0aCBvciBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0XG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZGRpbmcsIHZpZXdwb3J0KSB7XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigodmlld3BvcnQgLSB2aWV3cG9ydCAvICgxICsgcGFkZGluZykpICogMC41KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyAmJiBwYWRkaW5nLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdWYWx1ZSA9IHBhcnNlRmxvYXQocGFkZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhZGRpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHBhZGRpbmdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyAmJiBwYWRkaW5nLmVuZHNXaXRoKCclJykpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ZhbHVlID0gcGFyc2VGbG9hdChwYWRkaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFkZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3Iodmlld3BvcnQgKiBwYWRkaW5nVmFsdWUgKiAwLjAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKGBbUmVhY3QgRmxvd10gVGhlIHBhZGRpbmcgdmFsdWUgXCIke3BhZGRpbmd9XCIgaXMgaW52YWxpZC4gUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb3IgYSBzdHJpbmcgd2l0aCBhIHZhbGlkIHVuaXQgKHB4IG9yICUpLmApO1xuICAgIHJldHVybiAwO1xufVxuLyoqXG4gKiBQYXJzZXMgdGhlIHBhZGRpbmdzIHRvIGFuIG9iamVjdCB3aXRoIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgeCBhbmQgeSBwYWRkaW5nc1xuICogQGludGVybmFsXG4gKiBAcGFyYW0gcGFkZGluZyAtIFBhZGRpbmcgdG8gcGFyc2VcbiAqIEBwYXJhbSB3aWR0aCAtIFdpZHRoIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIGhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHRoZSBwYWRkaW5ncyBpbiBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gcGFyc2VQYWRkaW5ncyhwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZ1kgPSBwYXJzZVBhZGRpbmcocGFkZGluZywgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcGFkZGluZ1ggPSBwYXJzZVBhZGRpbmcocGFkZGluZywgd2lkdGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBwYWRkaW5nWSxcbiAgICAgICAgICAgIHJpZ2h0OiBwYWRkaW5nWCxcbiAgICAgICAgICAgIGJvdHRvbTogcGFkZGluZ1ksXG4gICAgICAgICAgICBsZWZ0OiBwYWRkaW5nWCxcbiAgICAgICAgICAgIHg6IHBhZGRpbmdYICogMixcbiAgICAgICAgICAgIHk6IHBhZGRpbmdZICogMixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYWRkaW5nID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCB0b3AgPSBwYXJzZVBhZGRpbmcocGFkZGluZy50b3AgPz8gcGFkZGluZy55ID8/IDAsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLmJvdHRvbSA/PyBwYWRkaW5nLnkgPz8gMCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgbGVmdCA9IHBhcnNlUGFkZGluZyhwYWRkaW5nLmxlZnQgPz8gcGFkZGluZy54ID8/IDAsIHdpZHRoKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZVBhZGRpbmcocGFkZGluZy5yaWdodCA/PyBwYWRkaW5nLnggPz8gMCwgd2lkdGgpO1xuICAgICAgICByZXR1cm4geyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHg6IGxlZnQgKyByaWdodCwgeTogdG9wICsgYm90dG9tIH07XG4gICAgfVxuICAgIHJldHVybiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgeDogMCwgeTogMCB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSByZXN1bHRpbmcgcGFkZGluZ3MgaWYgdGhlIG5ldyB2aWV3cG9ydCBpcyBhcHBsaWVkXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBib3VuZHMgLSBCb3VuZHMgdG8gZml0IGluc2lkZSB2aWV3cG9ydFxuICogQHBhcmFtIHggLSBYIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHkgLSBZIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHpvb20gLSBab29tIGxldmVsIG9mIHRoZSB2aWV3cG9ydFxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIG1pbmltdW0gcGFkZGluZyByZXF1aXJlZCB0byBmaXQgdGhlIGJvdW5kcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUFwcGxpZWRQYWRkaW5ncyhib3VuZHMsIHgsIHksIHpvb20sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7IHg6IGxlZnQsIHk6IHRvcCB9ID0gcmVuZGVyZXJQb2ludFRvUG9pbnQoYm91bmRzLCBbeCwgeSwgem9vbV0pO1xuICAgIGNvbnN0IHsgeDogYm91bmRSaWdodCwgeTogYm91bmRCb3R0b20gfSA9IHJlbmRlcmVyUG9pbnRUb1BvaW50KHsgeDogYm91bmRzLnggKyBib3VuZHMud2lkdGgsIHk6IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCB9LCBbeCwgeSwgem9vbV0pO1xuICAgIGNvbnN0IHJpZ2h0ID0gd2lkdGggLSBib3VuZFJpZ2h0O1xuICAgIGNvbnN0IGJvdHRvbSA9IGhlaWdodCAtIGJvdW5kQm90dG9tO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IE1hdGguZmxvb3IobGVmdCksXG4gICAgICAgIHRvcDogTWF0aC5mbG9vcih0b3ApLFxuICAgICAgICByaWdodDogTWF0aC5mbG9vcihyaWdodCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5mbG9vcihib3R0b20pLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgYSB2aWV3cG9ydCB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2l0aCBwYWRkaW5nLlxuICogQHB1YmxpY1xuICogQHJlbWFya3MgWW91IGNhbiBkZXRlcm1pbmUgYm91bmRzIG9mIG5vZGVzIHdpdGgge0BsaW5rIGdldE5vZGVzQm91bmRzfSBhbmQge0BsaW5rIGdldEJvdW5kc09mUmVjdHN9XG4gKiBAcGFyYW0gYm91bmRzIC0gQm91bmRzIHRvIGZpdCBpbnNpZGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gaGVpZ2h0ICAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnQuXG4gKiBAcGFyYW0gbWluWm9vbSAtIE1pbmltdW0gem9vbSBsZXZlbCBvZiB0aGUgcmVzdWx0aW5nIHZpZXdwb3J0LlxuICogQHBhcmFtIG1heFpvb20gLSBNYXhpbXVtIHpvb20gbGV2ZWwgb2YgdGhlIHJlc3VsdGluZyB2aWV3cG9ydC5cbiAqIEBwYXJhbSBwYWRkaW5nIC0gUGFkZGluZyBhcm91bmQgdGhlIGJvdW5kcy5cbiAqIEByZXR1cm5zIEEgdHJhbnNmb3JtZWQge0BsaW5rIFZpZXdwb3J0fSB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBib3VuZHMgd2hpY2ggeW91IGNhbiBwYXNzIHRvIGUuZy4ge0BsaW5rIHNldFZpZXdwb3J0fS5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKFxuICogeyB4OiAwLCB5OiAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH0sXG4gKiAxMjAwLCA4MDAsIDAuNSwgMik7XG4gKi9cbmNvbnN0IGdldFZpZXdwb3J0Rm9yQm91bmRzID0gKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFkZGluZykgPT4ge1xuICAgIC8vIEZpcnN0IHdlIHJlc29sdmUgYWxsIHRoZSBwYWRkaW5ncyB0byBhY3R1YWwgcGl4ZWwgdmFsdWVzXG4gICAgY29uc3QgcCA9IHBhcnNlUGFkZGluZ3MocGFkZGluZywgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgeFpvb20gPSAod2lkdGggLSBwLngpIC8gYm91bmRzLndpZHRoO1xuICAgIGNvbnN0IHlab29tID0gKGhlaWdodCAtIHAueSkgLyBib3VuZHMuaGVpZ2h0O1xuICAgIC8vIFdlIGNhbGN1bGF0ZSB0aGUgbmV3IHgsIHksIHpvb20gZm9yIGEgY2VudGVyZWQgdmlld1xuICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih4Wm9vbSwgeVpvb20pO1xuICAgIGNvbnN0IGNsYW1wZWRab29tID0gY2xhbXAoem9vbSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgY29uc3QgYm91bmRzQ2VudGVyWCA9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoIC8gMjtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJZID0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCB4ID0gd2lkdGggLyAyIC0gYm91bmRzQ2VudGVyWCAqIGNsYW1wZWRab29tO1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLyAyIC0gYm91bmRzQ2VudGVyWSAqIGNsYW1wZWRab29tO1xuICAgIC8vIFRoZW4gd2UgY2FsY3VsYXRlIHRoZSBtaW5pbXVtIHBhZGRpbmcsIHRvIHJlc3BlY3QgYXN5bW1ldHJpYyBwYWRkaW5nc1xuICAgIGNvbnN0IG5ld1BhZGRpbmcgPSBjYWxjdWxhdGVBcHBsaWVkUGFkZGluZ3MoYm91bmRzLCB4LCB5LCBjbGFtcGVkWm9vbSwgd2lkdGgsIGhlaWdodCk7XG4gICAgLy8gV2Ugb25seSB3YW50IHRvIGhhdmUgYW4gb2Zmc2V0IGlmIHRoZSBuZXdQYWRkaW5nIGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVxdWlyZWQgcGFkZGluZ1xuICAgIGNvbnN0IG9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4obmV3UGFkZGluZy5sZWZ0IC0gcC5sZWZ0LCAwKSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihuZXdQYWRkaW5nLnRvcCAtIHAudG9wLCAwKSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKG5ld1BhZGRpbmcucmlnaHQgLSBwLnJpZ2h0LCAwKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihuZXdQYWRkaW5nLmJvdHRvbSAtIHAuYm90dG9tLCAwKSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBvZmZzZXQubGVmdCArIG9mZnNldC5yaWdodCxcbiAgICAgICAgeTogeSAtIG9mZnNldC50b3AgKyBvZmZzZXQuYm90dG9tLFxuICAgICAgICB6b29tOiBjbGFtcGVkWm9vbSxcbiAgICB9O1xufTtcbmNvbnN0IGlzTWFjT3MgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5kZXhPZignTWFjJykgPj0gMDtcbmZ1bmN0aW9uIGlzQ29vcmRpbmF0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gZXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgZXh0ZW50ICE9PSBudWxsICYmIGV4dGVudCAhPT0gJ3BhcmVudCc7XG59XG5mdW5jdGlvbiBnZXROb2RlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0KSAhPT0gdW5kZWZpbmVkKTtcbn1cbi8qKlxuICogQ29udmVydCBjaGlsZCBwb3NpdGlvbiB0byBhYm9zbHV0ZSBwb3NpdGlvblxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBvc2l0aW9uXG4gKiBAcGFyYW0gcGFyZW50SWRcbiAqIEBwYXJhbSBub2RlTG9va3VwXG4gKiBAcGFyYW0gbm9kZU9yaWdpblxuICogQHJldHVybnMgYW4gaW50ZXJuYWwgbm9kZSB3aXRoIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihwb3NpdGlvbiwgZGltZW5zaW9ucyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCBwYXJlbnRJZCwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSB7IC4uLnBvc2l0aW9uIH07XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQocGFyZW50SWQpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiB8fCBub2RlT3JpZ2luO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlLnggKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggLSAoZGltZW5zaW9ucy53aWR0aCA/PyAwKSAqIG9yaWdpblswXTtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZS55ICs9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IC0gKGRpbWVuc2lvbnMuaGVpZ2h0ID8/IDApICogb3JpZ2luWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25BYnNvbHV0ZTtcbn1cbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgUHJvbWlzZS53aXRoUmVzb2x2ZXJzIHVudGlsIHdlIGNhbiB1c2UgaXQgaW4gYWxsIGJyb3dzZXJzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcbiAgICBsZXQgcmVzb2x2ZTtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuZnVuY3Rpb24gbWVyZ2VBcmlhTGFiZWxDb25maWcocGFydGlhbCkge1xuICAgIHJldHVybiB7IC4uLmRlZmF1bHRBcmlhTGFiZWxDb25maWcsIC4uLihwYXJ0aWFsIHx8IHt9KSB9O1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQsIHsgc25hcEdyaWQgPSBbMCwgMF0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgdHJhbnNmb3JtLCBjb250YWluZXJCb3VuZHMgfSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgcG9pbnRlclBvcyA9IHBvaW50VG9SZW5kZXJlclBvaW50KHsgeDogeCAtIChjb250YWluZXJCb3VuZHM/LmxlZnQgPz8gMCksIHk6IHkgLSAoY29udGFpbmVyQm91bmRzPy50b3AgPz8gMCkgfSwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCB7IHg6IHhTbmFwcGVkLCB5OiB5U25hcHBlZCB9ID0gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb2ludGVyUG9zLCBzbmFwR3JpZCkgOiBwb2ludGVyUG9zO1xuICAgIC8vIHdlIG5lZWQgdGhlIHNuYXBwZWQgcG9zaXRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBza2lwIHVubmVjZXNzYXJ5IGRyYWcgZXZlbnRzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeFNuYXBwZWQsXG4gICAgICAgIHlTbmFwcGVkLFxuICAgICAgICAuLi5wb2ludGVyUG9zLFxuICAgIH07XG59XG5jb25zdCBnZXREaW1lbnNpb25zID0gKG5vZGUpID0+ICh7XG4gICAgd2lkdGg6IG5vZGUub2Zmc2V0V2lkdGgsXG4gICAgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodCxcbn0pO1xuY29uc3QgZ2V0SG9zdEZvckVsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudD8uZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBpbnB1dFRhZ3MgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuZnVuY3Rpb24gaXNJbnB1dERPTU5vZGUoZXZlbnQpIHtcbiAgICAvLyB1c2luZyBjb21wb3NlZCBwYXRoIGZvciBoYW5kbGluZyBzaGFkb3cgZG9tXG4gICAgY29uc3QgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkUGF0aD8uKCk/LlswXSB8fCBldmVudC50YXJnZXQpO1xuICAgIGlmICh0YXJnZXQ/Lm5vZGVUeXBlICE9PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNJbnB1dCA9IGlucHV0VGFncy5pbmNsdWRlcyh0YXJnZXQubm9kZU5hbWUpIHx8IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIC8vIHdoZW4gYW4gaW5wdXQgZmllbGQgaXMgZm9jdXNlZCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgZGVsZXRpb24gb3IgbW92ZW1lbnQgb2Ygbm9kZXNcbiAgICByZXR1cm4gaXNJbnB1dCB8fCAhIXRhcmdldC5jbG9zZXN0KCcubm9rZXknKTtcbn1cbmNvbnN0IGlzTW91c2VFdmVudCA9IChldmVudCkgPT4gJ2NsaWVudFgnIGluIGV2ZW50O1xuY29uc3QgZ2V0RXZlbnRQb3NpdGlvbiA9IChldmVudCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZSA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZ0WCA9IGlzTW91c2UgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFg7XG4gICAgY29uc3QgZXZ0WSA9IGlzTW91c2UgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZ0WCAtIChib3VuZHM/LmxlZnQgPz8gMCksXG4gICAgICAgIHk6IGV2dFkgLSAoYm91bmRzPy50b3AgPz8gMCksXG4gICAgfTtcbn07XG4vKlxuICogVGhlIGhhbmRsZSBib3VuZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudC5cbiAqIFdlIHN0b3JlIHRoZW0gaW4gdGhlIGludGVybmFscyBvYmplY3Qgb2YgdGhlIG5vZGUgaW4gb3JkZXIgdG8gYXZvaWRcbiAqIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuICovXG5jb25zdCBnZXRIYW5kbGVCb3VuZHMgPSAodHlwZSwgbm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGVJZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXMgPSBub2RlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0eXBlfWApO1xuICAgIGlmICghaGFuZGxlcyB8fCAhaGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZXMpLm1hcCgoaGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJvdW5kcyA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgcG9zaXRpb246IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlcG9zJyksXG4gICAgICAgICAgICB4OiAoaGFuZGxlQm91bmRzLmxlZnQgLSBub2RlQm91bmRzLmxlZnQpIC8gem9vbSxcbiAgICAgICAgICAgIHk6IChoYW5kbGVCb3VuZHMudG9wIC0gbm9kZUJvdW5kcy50b3ApIC8gem9vbSxcbiAgICAgICAgICAgIC4uLmdldERpbWVuc2lvbnMoaGFuZGxlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldEJlemllckVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFksIHRhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWSwgfSkge1xuICAgIC8qXG4gICAgICogY3ViaWMgYmV6aWVyIHQ9MC41IG1pZCBwb2ludCwgbm90IHRoZSBhY3R1YWwgbWlkIHBvaW50LCBidXQgZWFzeSB0byBjYWxjdWxhdGVcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzUxNjEwMS9ob3ctdG8tZmluZC1kaXN0YW5jZS1taWQtcG9pbnQtb2YtYmV6aWVyLWN1cnZlXG4gICAgICovXG4gICAgY29uc3QgY2VudGVyWCA9IHNvdXJjZVggKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0WCAqIDAuMTI1O1xuICAgIGNvbnN0IGNlbnRlclkgPSBzb3VyY2VZICogMC4xMjUgKyBzb3VyY2VDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFkgKiAwLjM3NSArIHRhcmdldFkgKiAwLjEyNTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5hYnMoY2VudGVyWCAtIHNvdXJjZVgpO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmFicyhjZW50ZXJZIC0gc291cmNlWSk7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoZGlzdGFuY2UsIGN1cnZhdHVyZSkge1xuICAgIGlmIChkaXN0YW5jZSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBkaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZhdHVyZSAqIDI1ICogTWF0aC5zcXJ0KC1kaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7IHBvcywgeDEsIHkxLCB4MiwgeTIsIGMgfSkge1xuICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgxIC0geDIsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4gW3gxICsgY2FsY3VsYXRlQ29udHJvbE9mZnNldCh4MiAtIHgxLCBjKSwgeTFdO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxIC0gY2FsY3VsYXRlQ29udHJvbE9mZnNldCh5MSAtIHkyLCBjKV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkyIC0geTEsIGMpXTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBgZ2V0QmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgYmV6aWVyIGVkZ2VcbiAqYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGBsYWJlbFhgIGFuZCBgbGFiZWxZYCBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpXG4gKiBhbmQgYG9mZnNldFhgLCBgb2Zmc2V0WWAgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbC5cbiAqIC0gYHBhdGhgOiB0aGUgcGF0aCB0byB1c2UgaW4gYW4gU1ZHIGA8cGF0aD5gIGVsZW1lbnQuXG4gKiAtIGBsYWJlbFhgOiB0aGUgYHhgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBsYWJlbFlgOiB0aGUgYHlgIHBvc2l0aW9uIHlvdSBjYW4gdXNlIHRvIHJlbmRlciBhIGxhYmVsIGZvciB0aGlzIGVkZ2UuXG4gKiAtIGBvZmZzZXRYYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB4YCBwb3NpdGlvbiBhbmQgdGhlIGB4YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiAtIGBvZmZzZXRZYDogdGhlIGFic29sdXRlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgc291cmNlIGB5YCBwb3NpdGlvbiBhbmQgdGhlIGB5YCBwb3NpdGlvbiBvZiB0aGVcbiAqIG1pZGRsZSBvZiB0aGlzIHBhdGguXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICp9KTtcbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvXG4gKndvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldEJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGN1cnZhdHVyZSA9IDAuMjUsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgeDE6IHNvdXJjZVgsXG4gICAgICAgIHkxOiBzb3VyY2VZLFxuICAgICAgICB4MjogdGFyZ2V0WCxcbiAgICAgICAgeTI6IHRhcmdldFksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2xXaXRoQ3VydmF0dXJlKHtcbiAgICAgICAgcG9zOiB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgeDE6IHRhcmdldFgsXG4gICAgICAgIHkxOiB0YXJnZXRZLFxuICAgICAgICB4Mjogc291cmNlWCxcbiAgICAgICAgeTI6IHNvdXJjZVksXG4gICAgICAgIGM6IGN1cnZhdHVyZSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuXG4vLyB0aGlzIGlzIHVzZWQgZm9yIHN0cmFpZ2h0IGVkZ2VzIGFuZCBzaW1wbGUgc21vb3Roc3RlcCBlZGdlcyAoTFRSLCBSVEwsIEJUVCwgVFRCKVxuZnVuY3Rpb24gZ2V0RWRnZUNlbnRlcih7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIH0pIHtcbiAgICBjb25zdCB4T2Zmc2V0ID0gTWF0aC5hYnModGFyZ2V0WCAtIHNvdXJjZVgpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJYID0gdGFyZ2V0WCA8IHNvdXJjZVggPyB0YXJnZXRYICsgeE9mZnNldCA6IHRhcmdldFggLSB4T2Zmc2V0O1xuICAgIGNvbnN0IHlPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRZIC0gc291cmNlWSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSB0YXJnZXRZIDwgc291cmNlWSA/IHRhcmdldFkgKyB5T2Zmc2V0IDogdGFyZ2V0WSAtIHlPZmZzZXQ7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCB4T2Zmc2V0LCB5T2Zmc2V0XTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgei1pbmRleCBmb3IgYW4gZWRnZSBiYXNlZCBvbiB0aGUgbm9kZSBpdCBjb25uZWN0cyBhbmQgd2hldGhlciBpdCBpcyBzZWxlY3RlZC5cbiAqIEJ5IGRlZmF1bHQsIGVkZ2VzIGFyZSByZW5kZXJlZCBiZWxvdyBub2Rlcy4gVGhpcyBiZWhhdmlvdXIgaXMgZGlmZmVyZW50IGZvciBlZGdlcyB0aGF0IGFyZVxuICogY29ubmVjdGVkIHRvIG5vZGVzIHdpdGggYSBwYXJlbnQsIGFzIHRoZXkgYXJlIHJlbmRlcmVkIGFib3ZlIHRoZSBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgc2VsZWN0ZWQgPSBmYWxzZSwgekluZGV4ID0gMCwgZWxldmF0ZU9uU2VsZWN0ID0gZmFsc2UsIHpJbmRleE1vZGUgPSAnYmFzaWMnLCB9KSB7XG4gICAgaWYgKHpJbmRleE1vZGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgIHJldHVybiB6SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VaID0gZWxldmF0ZU9uU2VsZWN0ICYmIHNlbGVjdGVkID8gekluZGV4ICsgMTAwMCA6IHpJbmRleDtcbiAgICBjb25zdCBub2RlWiA9IE1hdGgubWF4KHNvdXJjZU5vZGUucGFyZW50SWQgfHwgKGVsZXZhdGVPblNlbGVjdCAmJiBzb3VyY2VOb2RlLnNlbGVjdGVkKSA/IHNvdXJjZU5vZGUuaW50ZXJuYWxzLnogOiAwLCB0YXJnZXROb2RlLnBhcmVudElkIHx8IChlbGV2YXRlT25TZWxlY3QgJiYgdGFyZ2V0Tm9kZS5zZWxlY3RlZCkgPyB0YXJnZXROb2RlLmludGVybmFscy56IDogMCk7XG4gICAgcmV0dXJuIGVkZ2VaICsgbm9kZVo7XG59XG5mdW5jdGlvbiBpc0VkZ2VWaXNpYmxlKHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgd2lkdGgsIGhlaWdodCwgdHJhbnNmb3JtIH0pIHtcbiAgICBjb25zdCBlZGdlQm94ID0gZ2V0Qm91bmRzT2ZCb3hlcyhub2RlVG9Cb3goc291cmNlTm9kZSksIG5vZGVUb0JveCh0YXJnZXROb2RlKSk7XG4gICAgaWYgKGVkZ2VCb3gueCA9PT0gZWRnZUJveC54Mikge1xuICAgICAgICBlZGdlQm94LngyICs9IDE7XG4gICAgfVxuICAgIGlmIChlZGdlQm94LnkgPT09IGVkZ2VCb3gueTIpIHtcbiAgICAgICAgZWRnZUJveC55MiArPSAxO1xuICAgIH1cbiAgICBjb25zdCB2aWV3UmVjdCA9IHtcbiAgICAgICAgeDogLXRyYW5zZm9ybVswXSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXRyYW5zZm9ybVsxXSAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgd2lkdGg6IHdpZHRoIC8gdHJhbnNmb3JtWzJdLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIHRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiBnZXRPdmVybGFwcGluZ0FyZWEodmlld1JlY3QsIGJveFRvUmVjdChlZGdlQm94KSkgPiAwO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlZGdlIElEIGdlbmVyYXRvciBmdW5jdGlvbi4gR2VuZXJhdGVzIGFuIElEIGJhc2VkIG9uIHRoZSBzb3VyY2UsIHRhcmdldCwgYW5kIGhhbmRsZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcGFyYW1zIC0gVGhlIGNvbm5lY3Rpb24gb3IgZWRnZSB0byBnZW5lcmF0ZSBhbiBJRCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGVkZ2UgSUQuXG4gKi9cbmNvbnN0IGdldEVkZ2VJZCA9ICh7IHNvdXJjZSwgc291cmNlSGFuZGxlLCB0YXJnZXQsIHRhcmdldEhhbmRsZSB9KSA9PiBgeHktZWRnZV9fJHtzb3VyY2V9JHtzb3VyY2VIYW5kbGUgfHwgJyd9LSR7dGFyZ2V0fSR7dGFyZ2V0SGFuZGxlIHx8ICcnfWA7XG5jb25zdCBjb25uZWN0aW9uRXhpc3RzID0gKGVkZ2UsIGVkZ2VzKSA9PiB7XG4gICAgcmV0dXJuIGVkZ2VzLnNvbWUoKGVsKSA9PiBlbC5zb3VyY2UgPT09IGVkZ2Uuc291cmNlICYmXG4gICAgICAgIGVsLnRhcmdldCA9PT0gZWRnZS50YXJnZXQgJiZcbiAgICAgICAgKGVsLnNvdXJjZUhhbmRsZSA9PT0gZWRnZS5zb3VyY2VIYW5kbGUgfHwgKCFlbC5zb3VyY2VIYW5kbGUgJiYgIWVkZ2Uuc291cmNlSGFuZGxlKSkgJiZcbiAgICAgICAgKGVsLnRhcmdldEhhbmRsZSA9PT0gZWRnZS50YXJnZXRIYW5kbGUgfHwgKCFlbC50YXJnZXRIYW5kbGUgJiYgIWVkZ2UudGFyZ2V0SGFuZGxlKSkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYWRkIGEgbmV3IEVkZ2UgdG8gYW4gYXJyYXkgb2YgZWRnZXMuIEl0IGFsc28gcGVyZm9ybXMgc29tZSB2YWxpZGF0aW9uIHRvIG1ha2Ugc3VyZSB5b3UgZG9uJ3QgYWRkIGFuIGludmFsaWQgZWRnZSBvciBkdXBsaWNhdGUgYW4gZXhpc3Rpbmcgb25lLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGVkZ2VQYXJhbXMgLSBFaXRoZXIgYW4gYEVkZ2VgIG9yIGEgYENvbm5lY3Rpb25gIHlvdSB3YW50IHRvIGFkZC5cbiAqIEBwYXJhbSBlZGdlcyAtIFRoZSBhcnJheSBvZiBhbGwgY3VycmVudCBlZGdlcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyBBIG5ldyBhcnJheSBvZiBlZGdlcyB3aXRoIHRoZSBuZXcgZWRnZSBhZGRlZC5cbiAqXG4gKiBAcmVtYXJrcyBJZiBhbiBlZGdlIHdpdGggdGhlIHNhbWUgYHRhcmdldGAgYW5kIGBzb3VyY2VgIGFscmVhZHkgZXhpc3RzIChhbmQgdGhlIHNhbWVcbiAqYHRhcmdldEhhbmRsZWAgYW5kIGBzb3VyY2VIYW5kbGVgIGlmIHRob3NlIGFyZSBzZXQpLCB0aGVuIHRoaXMgdXRpbCB3b24ndCBhZGRcbiAqYSBuZXcgZWRnZSBldmVuIGlmIHRoZSBgaWRgIHByb3BlcnR5IGlzIGRpZmZlcmVudC5cbiAqXG4gKi9cbmNvbnN0IGFkZEVkZ2UgPSAoZWRnZVBhcmFtcywgZWRnZXMsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICghZWRnZVBhcmFtcy5zb3VyY2UgfHwgIWVkZ2VQYXJhbXMudGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZWRnZUlkR2VuZXJhdG9yID0gb3B0aW9ucy5nZXRFZGdlSWQgfHwgZ2V0RWRnZUlkO1xuICAgIGxldCBlZGdlO1xuICAgIGlmIChpc0VkZ2VCYXNlKGVkZ2VQYXJhbXMpKSB7XG4gICAgICAgIGVkZ2UgPSB7IC4uLmVkZ2VQYXJhbXMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2UgPSB7XG4gICAgICAgICAgICAuLi5lZGdlUGFyYW1zLFxuICAgICAgICAgICAgaWQ6IGVkZ2VJZEdlbmVyYXRvcihlZGdlUGFyYW1zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25FeGlzdHMoZWRnZSwgZWRnZXMpKSB7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlSGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnNvdXJjZUhhbmRsZTtcbiAgICB9XG4gICAgaWYgKGVkZ2UudGFyZ2V0SGFuZGxlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBlZGdlLnRhcmdldEhhbmRsZTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzLmNvbmNhdChlZGdlKTtcbn07XG4vKipcbiAqIEEgaGFuZHkgdXRpbGl0eSB0byB1cGRhdGUgYW4gZXhpc3RpbmcgW2BFZGdlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZSkgd2l0aCBuZXcgcHJvcGVydGllcy5cbiAqVGhpcyBzZWFyY2hlcyB5b3VyIGVkZ2UgYXJyYXkgZm9yIGFuIGVkZ2Ugd2l0aCBhIG1hdGNoaW5nIGBpZGAgYW5kIHVwZGF0ZXMgaXRzXG4gKnByb3BlcnRpZXMgd2l0aCB0aGUgY29ubmVjdGlvbiB5b3UgcHJvdmlkZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvbGRFZGdlIC0gVGhlIGVkZ2UgeW91IHdhbnQgdG8gdXBkYXRlLlxuICogQHBhcmFtIG5ld0Nvbm5lY3Rpb24gLSBUaGUgbmV3IGNvbm5lY3Rpb24geW91IHdhbnQgdG8gdXBkYXRlIHRoZSBlZGdlIHdpdGguXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXMuXG4gKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBlZGdlcyBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqY29uc3Qgb25SZWNvbm5lY3QgPSB1c2VDYWxsYmFjayhcbiAqICAob2xkRWRnZTogRWRnZSwgbmV3Q29ubmVjdGlvbjogQ29ubmVjdGlvbikgPT4gc2V0RWRnZXMoKGVscykgPT4gcmVjb25uZWN0RWRnZShvbGRFZGdlLCBuZXdDb25uZWN0aW9uLCBlbHMpKSxbXSk7XG4gKmBgYFxuICovXG5jb25zdCByZWNvbm5lY3RFZGdlID0gKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVkZ2VzLCBvcHRpb25zID0geyBzaG91bGRSZXBsYWNlSWQ6IHRydWUgfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQ6IG9sZEVkZ2VJZCwgLi4ucmVzdCB9ID0gb2xkRWRnZTtcbiAgICBpZiAoIW5ld0Nvbm5lY3Rpb24uc291cmNlIHx8ICFuZXdDb25uZWN0aW9uLnRhcmdldCkge1xuICAgICAgICBkZXZXYXJuKCcwMDYnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNiddKCkpO1xuICAgICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kRWRnZSA9IGVkZ2VzLmZpbmQoKGUpID0+IGUuaWQgPT09IG9sZEVkZ2UuaWQpO1xuICAgIGlmICghZm91bmRFZGdlKSB7XG4gICAgICAgIGRldldhcm4oJzAwNycsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA3J10ob2xkRWRnZUlkKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZWRnZUlkR2VuZXJhdG9yID0gb3B0aW9ucy5nZXRFZGdlSWQgfHwgZ2V0RWRnZUlkO1xuICAgIC8vIFJlbW92ZSBvbGQgZWRnZSBhbmQgY3JlYXRlIHRoZSBuZXcgZWRnZSB3aXRoIHBhcmFtZXRlcnMgb2Ygb2xkIGVkZ2UuXG4gICAgY29uc3QgZWRnZSA9IHtcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgaWQ6IG9wdGlvbnMuc2hvdWxkUmVwbGFjZUlkID8gZWRnZUlkR2VuZXJhdG9yKG5ld0Nvbm5lY3Rpb24pIDogb2xkRWRnZUlkLFxuICAgICAgICBzb3VyY2U6IG5ld0Nvbm5lY3Rpb24uc291cmNlLFxuICAgICAgICB0YXJnZXQ6IG5ld0Nvbm5lY3Rpb24udGFyZ2V0LFxuICAgICAgICBzb3VyY2VIYW5kbGU6IG5ld0Nvbm5lY3Rpb24uc291cmNlSGFuZGxlLFxuICAgICAgICB0YXJnZXRIYW5kbGU6IG5ld0Nvbm5lY3Rpb24udGFyZ2V0SGFuZGxlLFxuICAgIH07XG4gICAgcmV0dXJuIGVkZ2VzLmZpbHRlcigoZSkgPT4gZS5pZCAhPT0gb2xkRWRnZUlkKS5jb25jYXQoZWRnZSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHN0cmFpZ2h0IGxpbmUgcGF0aCBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGBsYWJlbFhgIGFuZCBgbGFiZWxZYCBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpXG4gKiBhbmQgYG9mZnNldFhgLCBgb2Zmc2V0WWAgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbC5cbiAqXG4gKiAtIGBwYXRoYDogdGhlIHBhdGggdG8gdXNlIGluIGFuIFNWRyBgPHBhdGg+YCBlbGVtZW50LlxuICogLSBgbGFiZWxYYDogdGhlIGB4YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgbGFiZWxZYDogdGhlIGB5YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgb2Zmc2V0WGA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeGAgcG9zaXRpb24gYW5kIHRoZSBgeGAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogLSBgb2Zmc2V0WWA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeWAgcG9zaXRpb24gYW5kIHRoZSBgeWAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAgY29uc3Qgc291cmNlID0geyB4OiAwLCB5OiAyMCB9O1xuICogIGNvbnN0IHRhcmdldCA9IHsgeDogMTUwLCB5OiAxMDAgfTtcbiAqXG4gKiAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFN0cmFpZ2h0UGF0aCh7XG4gKiAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAqICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICogICAgc291cmNlUG9zaXRpb246IFBvc2l0aW9uLlJpZ2h0LFxuICogICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gKiAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAqICAgIHRhcmdldFBvc2l0aW9uOiBQb3NpdGlvbi5MZWZ0LFxuICogIH0pO1xuICogYGBgXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyYWlnaHRQYXRoKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICB9KTtcbiAgICByZXR1cm4gW2BNICR7c291cmNlWH0sJHtzb3VyY2VZfUwgJHt0YXJnZXRYfSwke3RhcmdldFl9YCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldO1xufVxuXG5jb25zdCBoYW5kbGVEaXJlY3Rpb25zID0ge1xuICAgIFtQb3NpdGlvbi5MZWZ0XTogeyB4OiAtMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5SaWdodF06IHsgeDogMSwgeTogMCB9LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IHsgeDogMCwgeTogMSB9LFxufTtcbmNvbnN0IGdldERpcmVjdGlvbiA9ICh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgfSkgPT4ge1xuICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uTGVmdCB8fCBzb3VyY2VQb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS54IDwgdGFyZ2V0LnggPyB7IHg6IDEsIHk6IDAgfSA6IHsgeDogLTEsIHk6IDAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZS55IDwgdGFyZ2V0LnkgPyB7IHg6IDAsIHk6IDEgfSA6IHsgeDogMCwgeTogLTEgfTtcbn07XG5jb25zdCBkaXN0YW5jZSA9IChhLCBiKSA9PiBNYXRoLnNxcnQoTWF0aC5wb3coYi54IC0gYS54LCAyKSArIE1hdGgucG93KGIueSAtIGEueSwgMikpO1xuLypcbiAqIFdpdGggdGhpcyBmdW5jdGlvbiB3ZSB0cnkgdG8gbWltaWMgYW4gb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcgYmVoYXZpb3VyXG4gKiBJdCdzIG5vdCBhcyBnb29kIGFzIGEgcmVhbCBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZywgYnV0IGl0J3MgZmFzdGVyIGFuZCBnb29kIGVub3VnaCBhcyBhIGRlZmF1bHQgZm9yIHN0ZXAgYW5kIHNtb290aCBzdGVwIGVkZ2VzXG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50cyh7IHNvdXJjZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldCwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGNlbnRlciwgb2Zmc2V0LCBzdGVwUG9zaXRpb24sIH0pIHtcbiAgICBjb25zdCBzb3VyY2VEaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3NvdXJjZVBvc2l0aW9uXTtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3RhcmdldFBvc2l0aW9uXTtcbiAgICBjb25zdCBzb3VyY2VHYXBwZWQgPSB7IHg6IHNvdXJjZS54ICsgc291cmNlRGlyLnggKiBvZmZzZXQsIHk6IHNvdXJjZS55ICsgc291cmNlRGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBwZWQgPSB7IHg6IHRhcmdldC54ICsgdGFyZ2V0RGlyLnggKiBvZmZzZXQsIHk6IHRhcmdldC55ICsgdGFyZ2V0RGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCBkaXIgPSBnZXREaXJlY3Rpb24oe1xuICAgICAgICBzb3VyY2U6IHNvdXJjZUdhcHBlZCxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldDogdGFyZ2V0R2FwcGVkLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpckFjY2Vzc29yID0gZGlyLnggIT09IDAgPyAneCcgOiAneSc7XG4gICAgY29uc3QgY3VyckRpciA9IGRpcltkaXJBY2Nlc3Nvcl07XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGxldCBjZW50ZXJYLCBjZW50ZXJZO1xuICAgIGNvbnN0IHNvdXJjZUdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IHRhcmdldEdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IFssICwgZGVmYXVsdE9mZnNldFgsIGRlZmF1bHRPZmZzZXRZXSA9IGdldEVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICB9KTtcbiAgICAvLyBvcHBvc2l0ZSBoYW5kbGUgcG9zaXRpb25zLCBkZWZhdWx0IGNhc2VcbiAgICBpZiAoc291cmNlRGlyW2RpckFjY2Vzc29yXSAqIHRhcmdldERpcltkaXJBY2Nlc3Nvcl0gPT09IC0xKSB7XG4gICAgICAgIGlmIChkaXJBY2Nlc3NvciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICAvLyBQcmltYXJ5IGRpcmVjdGlvbiBpcyBob3Jpem9udGFsLCBzbyBzdGVwUG9zaXRpb24gYWZmZWN0cyBYIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIGNlbnRlclggPSBjZW50ZXIueCA/PyAoc291cmNlR2FwcGVkLnggKyAodGFyZ2V0R2FwcGVkLnggLSBzb3VyY2VHYXBwZWQueCkgKiBzdGVwUG9zaXRpb24pO1xuICAgICAgICAgICAgY2VudGVyWSA9IGNlbnRlci55ID8/IChzb3VyY2VHYXBwZWQueSArIHRhcmdldEdhcHBlZC55KSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBQcmltYXJ5IGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbCwgc28gc3RlcFBvc2l0aW9uIGFmZmVjdHMgWSBjb29yZGluYXRlICBcbiAgICAgICAgICAgIGNlbnRlclggPSBjZW50ZXIueCA/PyAoc291cmNlR2FwcGVkLnggKyB0YXJnZXRHYXBwZWQueCkgLyAyO1xuICAgICAgICAgICAgY2VudGVyWSA9IGNlbnRlci55ID8/IChzb3VyY2VHYXBwZWQueSArICh0YXJnZXRHYXBwZWQueSAtIHNvdXJjZUdhcHBlZC55KSAqIHN0ZXBQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogICAgLS0tPlxuICAgICAgICAgKiAgICB8XG4gICAgICAgICAqID4tLS1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHNvdXJjZUdhcHBlZC55IH0sXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHRhcmdldEdhcHBlZC55IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qXG4gICAgICAgICAqICAgIHxcbiAgICAgICAgICogIC0tLVxuICAgICAgICAgKiAgfFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbFNwbGl0ID0gW1xuICAgICAgICAgICAgeyB4OiBzb3VyY2VHYXBwZWQueCwgeTogY2VudGVyWSB9LFxuICAgICAgICAgICAgeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogY2VudGVyWSB9LFxuICAgICAgICBdO1xuICAgICAgICBpZiAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gY3VyckRpcikge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHZlcnRpY2FsU3BsaXQgOiBob3Jpem9udGFsU3BsaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gaG9yaXpvbnRhbFNwbGl0IDogdmVydGljYWxTcGxpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc291cmNlVGFyZ2V0IG1lYW5zIHdlIHRha2UgeCBmcm9tIHNvdXJjZSBhbmQgeSBmcm9tIHRhcmdldCwgdGFyZ2V0U291cmNlIGlzIHRoZSBvcHBvc2l0ZVxuICAgICAgICBjb25zdCBzb3VyY2VUYXJnZXQgPSBbeyB4OiBzb3VyY2VHYXBwZWQueCwgeTogdGFyZ2V0R2FwcGVkLnkgfV07XG4gICAgICAgIGNvbnN0IHRhcmdldFNvdXJjZSA9IFt7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBzb3VyY2VHYXBwZWQueSB9XTtcbiAgICAgICAgLy8gdGhpcyBoYW5kbGVzIGVkZ2VzIHdpdGggc2FtZSBoYW5kbGUgcG9zaXRpb25zXG4gICAgICAgIGlmIChkaXJBY2Nlc3NvciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueCA9PT0gY3VyckRpciA/IHRhcmdldFNvdXJjZSA6IHNvdXJjZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci55ID09PSBjdXJyRGlyID8gc291cmNlVGFyZ2V0IDogdGFyZ2V0U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhzb3VyY2VbZGlyQWNjZXNzb3JdIC0gdGFyZ2V0W2RpckFjY2Vzc29yXSk7XG4gICAgICAgICAgICAvLyBpZiBhbiBlZGdlIGdvZXMgZnJvbSByaWdodCB0byByaWdodCBmb3IgZXhhbXBsZSAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSBhbmQgdGhlIGRpc3RhbmNlIGJldHdlZW4gc291cmNlLnggYW5kIHRhcmdldC54IGlzIGxlc3MgdGhhbiB0aGUgb2Zmc2V0LCB0aGUgYWRkZWQgcG9pbnQgYW5kIHRoZSBnYXBwZWQgc291cmNlL3RhcmdldCB3aWxsIG92ZXJsYXAuIFRoaXMgbGVhZHMgdG8gYSB3ZWlyZCBlZGdlIHBhdGguIFRvIGF2b2lkIHRoaXMgd2UgYWRkIGEgZ2FwT2Zmc2V0IHRvIHRoZSBzb3VyY2UvdGFyZ2V0XG4gICAgICAgICAgICBpZiAoZGlmZiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXBPZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQgLSAxLCBvZmZzZXQgLSBkaWZmKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gY3VyckRpcikge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiBzb3VyY2VbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAodGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yXSA+IHRhcmdldFtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBhcmUgY29uZGl0aW9ucyBmb3IgaGFuZGxpbmcgbWl4ZWQgaGFuZGxlIHBvc2l0aW9ucyBsaWtlIFJpZ2h0IC0+IEJvdHRvbSBmb3IgZXhhbXBsZVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gIT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJBY2Nlc3Nvck9wcG9zaXRlID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgIGNvbnN0IGlzU2FtZURpciA9IHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IHRhcmdldERpcltkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUd0VGFyZ2V0T3BwbyA9IHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXSA+IHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUx0VGFyZ2V0T3BwbyA9IHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXSA8IHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsaXBTb3VyY2VUYXJnZXQgPSAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlR3RUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykpKSB8fFxuICAgICAgICAgICAgICAgIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICE9PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlR3RUYXJnZXRPcHBvKSkpO1xuICAgICAgICAgICAgaWYgKGZsaXBTb3VyY2VUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gc291cmNlVGFyZ2V0IDogdGFyZ2V0U291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZUdhcFBvaW50ID0geyB4OiBzb3VyY2VHYXBwZWQueCArIHNvdXJjZUdhcE9mZnNldC54LCB5OiBzb3VyY2VHYXBwZWQueSArIHNvdXJjZUdhcE9mZnNldC55IH07XG4gICAgICAgIGNvbnN0IHRhcmdldEdhcFBvaW50ID0geyB4OiB0YXJnZXRHYXBwZWQueCArIHRhcmdldEdhcE9mZnNldC54LCB5OiB0YXJnZXRHYXBwZWQueSArIHRhcmdldEdhcE9mZnNldC55IH07XG4gICAgICAgIGNvbnN0IG1heFhEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnggLSBwb2ludHNbMF0ueCksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnggLSBwb2ludHNbMF0ueCkpO1xuICAgICAgICBjb25zdCBtYXhZRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC55IC0gcG9pbnRzWzBdLnkpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC55IC0gcG9pbnRzWzBdLnkpKTtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBwbGFjZSB0aGUgbGFiZWwgb24gdGhlIGxvbmdlc3Qgc2VnbWVudCBvZiB0aGUgZWRnZVxuICAgICAgICBpZiAobWF4WERpc3RhbmNlID49IG1heFlEaXN0YW5jZSkge1xuICAgICAgICAgICAgY2VudGVyWCA9IChzb3VyY2VHYXBQb2ludC54ICsgdGFyZ2V0R2FwUG9pbnQueCkgLyAyO1xuICAgICAgICAgICAgY2VudGVyWSA9IHBvaW50c1swXS55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2VudGVyWCA9IHBvaW50c1swXS54O1xuICAgICAgICAgICAgY2VudGVyWSA9IChzb3VyY2VHYXBQb2ludC55ICsgdGFyZ2V0R2FwUG9pbnQueSkgLyAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhdGhQb2ludHMgPSBbXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgeyB4OiBzb3VyY2VHYXBwZWQueCArIHNvdXJjZUdhcE9mZnNldC54LCB5OiBzb3VyY2VHYXBwZWQueSArIHNvdXJjZUdhcE9mZnNldC55IH0sXG4gICAgICAgIC4uLnBvaW50cyxcbiAgICAgICAgeyB4OiB0YXJnZXRHYXBwZWQueCArIHRhcmdldEdhcE9mZnNldC54LCB5OiB0YXJnZXRHYXBwZWQueSArIHRhcmdldEdhcE9mZnNldC55IH0sXG4gICAgICAgIHRhcmdldCxcbiAgICBdO1xuICAgIHJldHVybiBbcGF0aFBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgZGVmYXVsdE9mZnNldFgsIGRlZmF1bHRPZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGdldEJlbmQoYSwgYiwgYywgc2l6ZSkge1xuICAgIGNvbnN0IGJlbmRTaXplID0gTWF0aC5taW4oZGlzdGFuY2UoYSwgYikgLyAyLCBkaXN0YW5jZShiLCBjKSAvIDIsIHNpemUpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYjtcbiAgICAvLyBubyBiZW5kXG4gICAgaWYgKChhLnggPT09IHggJiYgeCA9PT0gYy54KSB8fCAoYS55ID09PSB5ICYmIHkgPT09IGMueSkpIHtcbiAgICAgICAgcmV0dXJuIGBMJHt4fSAke3l9YDtcbiAgICB9XG4gICAgLy8gZmlyc3Qgc2VnbWVudCBpcyBob3Jpem9udGFsXG4gICAgaWYgKGEueSA9PT0geSkge1xuICAgICAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gLTEgOiAxO1xuICAgICAgICBjb25zdCB5RGlyID0gYS55IDwgYy55ID8gMSA6IC0xO1xuICAgICAgICByZXR1cm4gYEwgJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9USAke3h9LCR7eX0gJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9YDtcbiAgICB9XG4gICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IDEgOiAtMTtcbiAgICBjb25zdCB5RGlyID0gYS55IDwgYy55ID8gLTEgOiAxO1xuICAgIHJldHVybiBgTCAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1RICR7eH0sJHt5fSAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1gO1xufVxuLyoqXG4gKiBUaGUgYGdldFNtb290aFN0ZXBQYXRoYCB1dGlsIHJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byByZW5kZXIgYSBzdGVwcGVkIHBhdGhcbiAqIGJldHdlZW4gdHdvIG5vZGVzLiBUaGUgYGJvcmRlclJhZGl1c2AgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gY2hvb3NlIGhvdyByb3VuZGVkXG4gKiB0aGUgY29ybmVycyBvZiB0aG9zZSBzdGVwcyBhcmUuXG4gKiBAcHVibGljXG4gKiBAcmV0dXJucyBBIHBhdGggc3RyaW5nIHlvdSBjYW4gdXNlIGluIGFuIFNWRywgdGhlIGBsYWJlbFhgIGFuZCBgbGFiZWxZYCBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpXG4gKiBhbmQgYG9mZnNldFhgLCBgb2Zmc2V0WWAgYmV0d2VlbiBzb3VyY2UgaGFuZGxlIGFuZCBsYWJlbC5cbiAqXG4gKiAtIGBwYXRoYDogdGhlIHBhdGggdG8gdXNlIGluIGFuIFNWRyBgPHBhdGg+YCBlbGVtZW50LlxuICogLSBgbGFiZWxYYDogdGhlIGB4YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgbGFiZWxZYDogdGhlIGB5YCBwb3NpdGlvbiB5b3UgY2FuIHVzZSB0byByZW5kZXIgYSBsYWJlbCBmb3IgdGhpcyBlZGdlLlxuICogLSBgb2Zmc2V0WGA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeGAgcG9zaXRpb24gYW5kIHRoZSBgeGAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogLSBgb2Zmc2V0WWA6IHRoZSBhYnNvbHV0ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNvdXJjZSBgeWAgcG9zaXRpb24gYW5kIHRoZSBgeWAgcG9zaXRpb24gb2YgdGhlXG4gKiBtaWRkbGUgb2YgdGhpcyBwYXRoLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAgY29uc3Qgc291cmNlID0geyB4OiAwLCB5OiAyMCB9O1xuICogIGNvbnN0IHRhcmdldCA9IHsgeDogMTUwLCB5OiAxMDAgfTtcbiAqXG4gKiAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKiAgfSk7XG4gKiBgYGBcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHR1cGxlIChha2EgYSBmaXhlZC1zaXplIGFycmF5KSB0byBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggbXVsdGlwbGUgZWRnZSBwYXRocyBhdCBvbmNlLlxuICovXG5mdW5jdGlvbiBnZXRTbW9vdGhTdGVwUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgYm9yZGVyUmFkaXVzID0gNSwgY2VudGVyWCwgY2VudGVyWSwgb2Zmc2V0ID0gMjAsIHN0ZXBQb3NpdGlvbiA9IDAuNSwgfSkge1xuICAgIGNvbnN0IFtwb2ludHMsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFBvaW50cyh7XG4gICAgICAgIHNvdXJjZTogeyB4OiBzb3VyY2VYLCB5OiBzb3VyY2VZIH0sXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHsgeDogdGFyZ2V0WCwgeTogdGFyZ2V0WSB9LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgY2VudGVyOiB7IHg6IGNlbnRlclgsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBzdGVwUG9zaXRpb24sXG4gICAgfSk7XG4gICAgY29uc3QgcGF0aCA9IHBvaW50cy5yZWR1Y2UoKHJlcywgcCwgaSkgPT4ge1xuICAgICAgICBsZXQgc2VnbWVudCA9ICcnO1xuICAgICAgICBpZiAoaSA+IDAgJiYgaSA8IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gZ2V0QmVuZChwb2ludHNbaSAtIDFdLCBwLCBwb2ludHNbaSArIDFdLCBib3JkZXJSYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudCA9IGAke2kgPT09IDAgPyAnTScgOiAnTCd9JHtwLnh9ICR7cC55fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzICs9IHNlZ21lbnQ7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldO1xufVxuXG5mdW5jdGlvbiBpc05vZGVJbml0aWFsaXplZChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICYmXG4gICAgICAgICEhKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyB8fCBub2RlLmhhbmRsZXM/Lmxlbmd0aCkgJiZcbiAgICAgICAgISEobm9kZS5tZWFzdXJlZC53aWR0aCB8fCBub2RlLndpZHRoIHx8IG5vZGUuaW5pdGlhbFdpZHRoKSk7XG59XG5mdW5jdGlvbiBnZXRFZGdlUG9zaXRpb24ocGFyYW1zKSB7XG4gICAgY29uc3QgeyBzb3VyY2VOb2RlLCB0YXJnZXROb2RlIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFpc05vZGVJbml0aWFsaXplZChzb3VyY2VOb2RlKSB8fCAhaXNOb2RlSW5pdGlhbGl6ZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZUhhbmRsZUJvdW5kcyA9IHNvdXJjZU5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyB8fCB0b0hhbmRsZUJvdW5kcyhzb3VyY2VOb2RlLmhhbmRsZXMpO1xuICAgIGNvbnN0IHRhcmdldEhhbmRsZUJvdW5kcyA9IHRhcmdldE5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyB8fCB0b0hhbmRsZUJvdW5kcyh0YXJnZXROb2RlLmhhbmRsZXMpO1xuICAgIGNvbnN0IHNvdXJjZUhhbmRsZSA9IGdldEhhbmRsZSQxKHNvdXJjZUhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdLCBwYXJhbXMuc291cmNlSGFuZGxlKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGUgPSBnZXRIYW5kbGUkMShcbiAgICAvLyB3aGVuIGNvbm5lY3Rpb24gdHlwZSBpcyBsb29zZSB3ZSBjYW4gZGVmaW5lIGFsbCBoYW5kbGVzIGFzIHNvdXJjZXMgYW5kIGNvbm5lY3Qgc291cmNlIC0+IHNvdXJjZVxuICAgIHBhcmFtcy5jb25uZWN0aW9uTW9kZSA9PT0gQ29ubmVjdGlvbk1vZGUuU3RyaWN0XG4gICAgICAgID8gdGFyZ2V0SGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW11cbiAgICAgICAgOiAodGFyZ2V0SGFuZGxlQm91bmRzPy50YXJnZXQgPz8gW10pLmNvbmNhdCh0YXJnZXRIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSksIHBhcmFtcy50YXJnZXRIYW5kbGUpO1xuICAgIGlmICghc291cmNlSGFuZGxlIHx8ICF0YXJnZXRIYW5kbGUpIHtcbiAgICAgICAgcGFyYW1zLm9uRXJyb3I/LignMDA4JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDgnXSghc291cmNlSGFuZGxlID8gJ3NvdXJjZScgOiAndGFyZ2V0Jywge1xuICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZCxcbiAgICAgICAgICAgIHNvdXJjZUhhbmRsZTogcGFyYW1zLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogcGFyYW1zLnRhcmdldEhhbmRsZSxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBzb3VyY2VIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLkJvdHRvbTtcbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHRhcmdldEhhbmRsZT8ucG9zaXRpb24gfHwgUG9zaXRpb24uVG9wO1xuICAgIGNvbnN0IHNvdXJjZSA9IGdldEhhbmRsZVBvc2l0aW9uKHNvdXJjZU5vZGUsIHNvdXJjZUhhbmRsZSwgc291cmNlUG9zaXRpb24pO1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEhhbmRsZVBvc2l0aW9uKHRhcmdldE5vZGUsIHRhcmdldEhhbmRsZSwgdGFyZ2V0UG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICAgICAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAgICAgICAgdGFyZ2V0WDogdGFyZ2V0LngsXG4gICAgICAgIHRhcmdldFk6IHRhcmdldC55LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvSGFuZGxlQm91bmRzKGhhbmRsZXMpIHtcbiAgICBpZiAoIWhhbmRsZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IFtdO1xuICAgIGNvbnN0IHRhcmdldCA9IFtdO1xuICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGhhbmRsZXMpIHtcbiAgICAgICAgaGFuZGxlLndpZHRoID0gaGFuZGxlLndpZHRoID8/IDE7XG4gICAgICAgIGhhbmRsZS5oZWlnaHQgPSBoYW5kbGUuaGVpZ2h0ID8/IDE7XG4gICAgICAgIGlmIChoYW5kbGUudHlwZSA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICAgIHNvdXJjZS5wdXNoKGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFuZGxlLnR5cGUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGZhbGxiYWNrUG9zaXRpb24gPSBQb3NpdGlvbi5MZWZ0LCBjZW50ZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHggPSAoaGFuZGxlPy54ID8/IDApICsgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54O1xuICAgIGNvbnN0IHkgPSAoaGFuZGxlPy55ID8/IDApICsgbm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55O1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaGFuZGxlID8/IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCAvIDIgfTtcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb24gPSBoYW5kbGU/LnBvc2l0aW9uID8/IGZhbGxiYWNrUG9zaXRpb247XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHkgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCwgeTogeSArIGhlaWdodCAvIDIgfTtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5OiB5ICsgaGVpZ2h0IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SGFuZGxlJDEoYm91bmRzLCBoYW5kbGVJZCkge1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBpZiBubyBoYW5kbGVJZCBpcyBnaXZlbiwgd2UgdXNlIHRoZSBmaXJzdCBoYW5kbGUsIG90aGVyd2lzZSB3ZSBjaGVjayBmb3IgdGhlIGlkXG4gICAgcmV0dXJuICghaGFuZGxlSWQgPyBib3VuZHNbMF0gOiBib3VuZHMuZmluZCgoZCkgPT4gZC5pZCA9PT0gaGFuZGxlSWQpKSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNYXJrZXJJZChtYXJrZXIsIGlkKSB7XG4gICAgaWYgKCFtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hcmtlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICB9XG4gICAgY29uc3QgaWRQcmVmaXggPSBpZCA/IGAke2lkfV9fYCA6ICcnO1xuICAgIHJldHVybiBgJHtpZFByZWZpeH0ke09iamVjdC5rZXlzKG1hcmtlcilcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAubWFwKChrZXkpID0+IGAke2tleX09JHttYXJrZXJba2V5XX1gKVxuICAgICAgICAuam9pbignJicpfWA7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXJrZXJJZHMoZWRnZXMsIHsgaWQsIGRlZmF1bHRDb2xvciwgZGVmYXVsdE1hcmtlclN0YXJ0LCBkZWZhdWx0TWFya2VyRW5kLCB9KSB7XG4gICAgY29uc3QgaWRzID0gbmV3IFNldCgpO1xuICAgIHJldHVybiBlZGdlc1xuICAgICAgICAucmVkdWNlKChtYXJrZXJzLCBlZGdlKSA9PiB7XG4gICAgICAgIFtlZGdlLm1hcmtlclN0YXJ0IHx8IGRlZmF1bHRNYXJrZXJTdGFydCwgZWRnZS5tYXJrZXJFbmQgfHwgZGVmYXVsdE1hcmtlckVuZF0uZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICAgICAgICBpZiAobWFya2VyICYmIHR5cGVvZiBtYXJrZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya2VySWQgPSBnZXRNYXJrZXJJZChtYXJrZXIsIGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkcy5oYXMobWFya2VySWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcnMucHVzaCh7IGlkOiBtYXJrZXJJZCwgY29sb3I6IG1hcmtlci5jb2xvciB8fCBkZWZhdWx0Q29sb3IsIC4uLm1hcmtlciB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLmFkZChtYXJrZXJJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfSwgW10pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmlkLmxvY2FsZUNvbXBhcmUoYi5pZCkpO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlVG9vbGJhclRyYW5zZm9ybShub2RlUmVjdCwgdmlld3BvcnQsIHBvc2l0aW9uLCBvZmZzZXQsIGFsaWduKSB7XG4gICAgbGV0IGFsaWdubWVudE9mZnNldCA9IDAuNTtcbiAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgYWxpZ25tZW50T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDE7XG4gICAgfVxuICAgIC8qXG4gICAgICogcG9zaXRpb24gPT09IFBvc2l0aW9uLlRvcFxuICAgICAqIHdlIHNldCB0aGUgeCBhbnkgeSBwb3NpdGlvbiBvZiB0aGUgdG9vbGJhciBiYXNlZCBvbiB0aGUgbm9kZXMgcG9zaXRpb25cbiAgICAgKi9cbiAgICBsZXQgcG9zID0gW1xuICAgICAgICAobm9kZVJlY3QueCArIG5vZGVSZWN0LndpZHRoICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54LFxuICAgICAgICBub2RlUmVjdC55ICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnkgLSBvZmZzZXQsXG4gICAgXTtcbiAgICAvLyBhbmQgdGhhbiBzaGlmdCBpdCBiYXNlZCBvbiB0aGUgYWxpZ25tZW50LiBUaGUgc2hpZnQgdmFsdWVzIGFyZSBpbiAlLlxuICAgIGxldCBzaGlmdCA9IFstMTAwICogYWxpZ25tZW50T2Zmc2V0LCAtMTAwXTtcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICBwb3MgPSBbXG4gICAgICAgICAgICAgICAgKG5vZGVSZWN0LnggKyBub2RlUmVjdC53aWR0aCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCArIG9mZnNldCxcbiAgICAgICAgICAgICAgICAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBzaGlmdCA9IFswLCAtMTAwICogYWxpZ25tZW50T2Zmc2V0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkJvdHRvbTpcbiAgICAgICAgICAgIHBvc1sxXSA9IChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55ICsgb2Zmc2V0O1xuICAgICAgICAgICAgc2hpZnRbMV0gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHBvcyA9IFtcbiAgICAgICAgICAgICAgICBub2RlUmVjdC54ICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnggLSBvZmZzZXQsXG4gICAgICAgICAgICAgICAgKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQgKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc2hpZnQgPSBbLTEwMCwgLTEwMCAqIGFsaWdubWVudE9mZnNldF07XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtwb3NbMF19cHgsICR7cG9zWzFdfXB4KSB0cmFuc2xhdGUoJHtzaGlmdFswXX0lLCAke3NoaWZ0WzFdfSUpYDtcbn1cblxuY29uc3QgYWxpZ25YVG9QZXJjZW50ID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgY2VudGVyOiA1MCxcbiAgICByaWdodDogMTAwLFxufTtcbmNvbnN0IGFsaWduWVRvUGVyY2VudCA9IHtcbiAgICB0b3A6IDAsXG4gICAgY2VudGVyOiA1MCxcbiAgICBib3R0b206IDEwMCxcbn07XG5mdW5jdGlvbiBnZXRFZGdlVG9vbGJhclRyYW5zZm9ybSh4LCB5LCB6b29tLCBhbGlnblggPSAnY2VudGVyJywgYWxpZ25ZID0gJ2NlbnRlcicpIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9cHgsICR7eX1weCkgc2NhbGUoJHsxIC8gem9vbX0pIHRyYW5zbGF0ZSgkey0oYWxpZ25YVG9QZXJjZW50W2FsaWduWF0gPz8gNTApfSUsICR7LShhbGlnbllUb1BlcmNlbnRbYWxpZ25ZXSA/PyA1MCl9JSlgO1xufVxuXG5jb25zdCBTRUxFQ1RFRF9OT0RFX1ogPSAxMDAwO1xuY29uc3QgUk9PVF9QQVJFTlRfWl9JTkNSRU1FTlQgPSAxMDtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG5vZGVPcmlnaW46IFswLCAwXSxcbiAgICBub2RlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogdHJ1ZSxcbiAgICB6SW5kZXhNb2RlOiAnYmFzaWMnLFxuICAgIGRlZmF1bHRzOiB7fSxcbn07XG5jb25zdCBhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIGNoZWNrRXF1YWxpdHk6IHRydWUsXG59O1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKGJhc2UsIGluY29taW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5iYXNlIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5jb21pbmcpIHtcbiAgICAgICAgaWYgKGluY29taW5nW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdHlwZWNhc3QgaXMgc2FmZSBoZXJlLCBiZWNhdXNlIHdlIGNoZWNrIGZvciB1bmRlZmluZWRcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaW5jb21pbmdba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMobm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zKSB7XG4gICAgY29uc3QgX29wdGlvbnMgPSBtZXJnZU9iamVjdHMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTG9va3VwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICB1cGRhdGVDaGlsZE5vZGUobm9kZSwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBfb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKG5vZGUsIF9vcHRpb25zLm5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gaXNDb29yZGluYXRlRXh0ZW50KG5vZGUuZXh0ZW50KSA/IG5vZGUuZXh0ZW50IDogX29wdGlvbnMubm9kZUV4dGVudDtcbiAgICAgICAgICAgIGNvbnN0IGNsYW1wZWRQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb24ocG9zaXRpb25XaXRoT3JpZ2luLCBleHRlbnQsIGdldE5vZGVEaW1lbnNpb25zKG5vZGUpKTtcbiAgICAgICAgICAgIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcGVkUG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUhhbmRsZXModXNlck5vZGUsIGludGVybmFsTm9kZSkge1xuICAgIGlmICghdXNlck5vZGUuaGFuZGxlcykge1xuICAgICAgICByZXR1cm4gIXVzZXJOb2RlLm1lYXN1cmVkID8gdW5kZWZpbmVkIDogaW50ZXJuYWxOb2RlPy5pbnRlcm5hbHMuaGFuZGxlQm91bmRzO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiB1c2VyTm9kZS5oYW5kbGVzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJvdW5kcyA9IHtcbiAgICAgICAgICAgIGlkOiBoYW5kbGUuaWQsXG4gICAgICAgICAgICB3aWR0aDogaGFuZGxlLndpZHRoID8/IDEsXG4gICAgICAgICAgICBoZWlnaHQ6IGhhbmRsZS5oZWlnaHQgPz8gMSxcbiAgICAgICAgICAgIG5vZGVJZDogdXNlck5vZGUuaWQsXG4gICAgICAgICAgICB4OiBoYW5kbGUueCxcbiAgICAgICAgICAgIHk6IGhhbmRsZS55LFxuICAgICAgICAgICAgcG9zaXRpb246IGhhbmRsZS5wb3NpdGlvbixcbiAgICAgICAgICAgIHR5cGU6IGhhbmRsZS50eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGVCb3VuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlQm91bmRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNNYW51YWxaSW5kZXhNb2RlKHpJbmRleE1vZGUpIHtcbiAgICByZXR1cm4gekluZGV4TW9kZSA9PT0gJ21hbnVhbCc7XG59XG5mdW5jdGlvbiBhZG9wdFVzZXJOb2Rlcyhub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBfb3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhhZG9wdFVzZXJOb2Rlc0RlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCByb290UGFyZW50SW5kZXggPSB7IGk6IDAgfTtcbiAgICBjb25zdCB0bXBMb29rdXAgPSBuZXcgTWFwKG5vZGVMb29rdXApO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZVogPSBfb3B0aW9ucz8uZWxldmF0ZU5vZGVzT25TZWxlY3QgJiYgIWlzTWFudWFsWkluZGV4TW9kZShfb3B0aW9ucy56SW5kZXhNb2RlKSA/IFNFTEVDVEVEX05PREVfWiA6IDA7XG4gICAgbGV0IG5vZGVzSW5pdGlhbGl6ZWQgPSBub2Rlcy5sZW5ndGggPiAwO1xuICAgIG5vZGVMb29rdXAuY2xlYXIoKTtcbiAgICBwYXJlbnRMb29rdXAuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHVzZXJOb2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGxldCBpbnRlcm5hbE5vZGUgPSB0bXBMb29rdXAuZ2V0KHVzZXJOb2RlLmlkKTtcbiAgICAgICAgaWYgKF9vcHRpb25zLmNoZWNrRXF1YWxpdHkgJiYgdXNlck5vZGUgPT09IGludGVybmFsTm9kZT8uaW50ZXJuYWxzLnVzZXJOb2RlKSB7XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldCh1c2VyTm9kZS5pZCwgaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4odXNlck5vZGUsIF9vcHRpb25zLm5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gaXNDb29yZGluYXRlRXh0ZW50KHVzZXJOb2RlLmV4dGVudCkgPyB1c2VyTm9kZS5leHRlbnQgOiBfb3B0aW9ucy5ub2RlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGV4dGVudCwgZ2V0Tm9kZURpbWVuc2lvbnModXNlck5vZGUpKTtcbiAgICAgICAgICAgIGludGVybmFsTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5fb3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAuLi51c2VyTm9kZSxcbiAgICAgICAgICAgICAgICBtZWFzdXJlZDoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdXNlck5vZGUubWVhc3VyZWQ/LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHVzZXJOb2RlLm1lYXN1cmVkPy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogY2xhbXBlZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIHJlLWluaXRpYWxpemVzIHRoZSBub2RlIG9yIHJlbW92ZXMgYG1lYXN1cmVkYCBmb3Igd2hhdGV2ZXIgcmVhc29uLCB3ZSByZXNldCB0aGUgaGFuZGxlQm91bmRzIHNvIHRoYXQgdGhlIG5vZGUgZ2V0cyByZS1tZWFzdXJlZFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHBhcnNlSGFuZGxlcyh1c2VyTm9kZSwgaW50ZXJuYWxOb2RlKSxcbiAgICAgICAgICAgICAgICAgICAgejogY2FsY3VsYXRlWih1c2VyTm9kZSwgc2VsZWN0ZWROb2RlWiwgX29wdGlvbnMuekluZGV4TW9kZSksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJOb2RlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQodXNlck5vZGUuaWQsIGludGVybmFsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbnRlcm5hbE5vZGUubWVhc3VyZWQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgaW50ZXJuYWxOb2RlLm1lYXN1cmVkLndpZHRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGludGVybmFsTm9kZS5tZWFzdXJlZC5oZWlnaHQgPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICFpbnRlcm5hbE5vZGUuaGlkZGVuKSB7XG4gICAgICAgICAgICBub2Rlc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJOb2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICB1cGRhdGVDaGlsZE5vZGUoaW50ZXJuYWxOb2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMsIHJvb3RQYXJlbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzSW5pdGlhbGl6ZWQ7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKSB7XG4gICAgaWYgKCFub2RlLnBhcmVudElkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IHBhcmVudExvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXJlbnRMb29rdXAuc2V0KG5vZGUucGFyZW50SWQsIG5ldyBNYXAoW1tub2RlLmlkLCBub2RlXV0pKTtcbiAgICB9XG59XG4vKipcbiAqIFVwZGF0ZXMgcG9zaXRpb25BYnNvbHV0ZSBhbmQgekluZGV4IG9mIGEgY2hpbGQgbm9kZSBhbmQgdGhlIHBhcmVudExvb2t1cC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucywgcm9vdFBhcmVudEluZGV4KSB7XG4gICAgY29uc3QgeyBlbGV2YXRlTm9kZXNPblNlbGVjdCwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgekluZGV4TW9kZSB9ID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KHBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQYXJlbnQgbm9kZSAke3BhcmVudElkfSBub3QgZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdCBwYXJlbnQgbm9kZXMgYXJlIGluIGZyb250IG9mIHRoZWlyIGNoaWxkIG5vZGVzIGluIHRoZSBub2RlcyBhcnJheS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVQYXJlbnRMb29rdXAobm9kZSwgcGFyZW50TG9va3VwKTtcbiAgICAvLyBXZSBqdXN0IHdhbnQgdG8gc2V0IHRoZSByb290UGFyZW50SW5kZXggZm9yIHRoZSBmaXJzdCBjaGlsZFxuICAgIGlmIChyb290UGFyZW50SW5kZXggJiZcbiAgICAgICAgIXBhcmVudE5vZGUucGFyZW50SWQgJiZcbiAgICAgICAgcGFyZW50Tm9kZS5pbnRlcm5hbHMucm9vdFBhcmVudEluZGV4ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgekluZGV4TW9kZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHBhcmVudE5vZGUuaW50ZXJuYWxzLnJvb3RQYXJlbnRJbmRleCA9ICsrcm9vdFBhcmVudEluZGV4Lmk7XG4gICAgICAgIHBhcmVudE5vZGUuaW50ZXJuYWxzLnogPSBwYXJlbnROb2RlLmludGVybmFscy56ICsgcm9vdFBhcmVudEluZGV4LmkgKiBST09UX1BBUkVOVF9aX0lOQ1JFTUVOVDtcbiAgICB9XG4gICAgLy8gQnV0IHdlIG5lZWQgdG8gdXBkYXRlIHJvb3RQYXJlbnRJbmRleC5pIGFsc28gd2hlbiBwYXJlbnQgaGFzIG5vdCBiZWVuIHVwZGF0ZWRcbiAgICBpZiAocm9vdFBhcmVudEluZGV4ICYmIHBhcmVudE5vZGUuaW50ZXJuYWxzLnJvb3RQYXJlbnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvb3RQYXJlbnRJbmRleC5pID0gcGFyZW50Tm9kZS5pbnRlcm5hbHMucm9vdFBhcmVudEluZGV4O1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZE5vZGVaID0gZWxldmF0ZU5vZGVzT25TZWxlY3QgJiYgIWlzTWFudWFsWkluZGV4TW9kZSh6SW5kZXhNb2RlKSA/IFNFTEVDVEVEX05PREVfWiA6IDA7XG4gICAgY29uc3QgeyB4LCB5LCB6IH0gPSBjYWxjdWxhdGVDaGlsZFhZWihub2RlLCBwYXJlbnROb2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBzZWxlY3RlZE5vZGVaLCB6SW5kZXhNb2RlKTtcbiAgICBjb25zdCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IG5vZGUuaW50ZXJuYWxzO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHggIT09IHBvc2l0aW9uQWJzb2x1dGUueCB8fCB5ICE9PSBwb3NpdGlvbkFic29sdXRlLnk7XG4gICAgaWYgKHBvc2l0aW9uQ2hhbmdlZCB8fCB6ICE9PSBub2RlLmludGVybmFscy56KSB7XG4gICAgICAgIC8vIHdlIGNyZWF0ZSBhIG5ldyBvYmplY3QgdG8gbWFyayB0aGUgbm9kZSBhcyB1cGRhdGVkXG4gICAgICAgIG5vZGVMb29rdXAuc2V0KG5vZGUuaWQsIHtcbiAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBwb3NpdGlvbkNoYW5nZWQgPyB7IHgsIHkgfSA6IHBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVoobm9kZSwgc2VsZWN0ZWROb2RlWiwgekluZGV4TW9kZSkge1xuICAgIGNvbnN0IHpJbmRleCA9IGlzTnVtZXJpYyhub2RlLnpJbmRleCkgPyBub2RlLnpJbmRleCA6IDA7XG4gICAgaWYgKGlzTWFudWFsWkluZGV4TW9kZSh6SW5kZXhNb2RlKSkge1xuICAgICAgICByZXR1cm4gekluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gekluZGV4ICsgKG5vZGUuc2VsZWN0ZWQgPyBzZWxlY3RlZE5vZGVaIDogMCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDaGlsZFhZWihjaGlsZE5vZGUsIHBhcmVudE5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHNlbGVjdGVkTm9kZVosIHpJbmRleE1vZGUpIHtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgY29uc3QgY2hpbGREaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMoY2hpbGROb2RlKTtcbiAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKGNoaWxkTm9kZSwgbm9kZU9yaWdpbik7XG4gICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gaXNDb29yZGluYXRlRXh0ZW50KGNoaWxkTm9kZS5leHRlbnQpXG4gICAgICAgID8gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGNoaWxkTm9kZS5leHRlbnQsIGNoaWxkRGltZW5zaW9ucylcbiAgICAgICAgOiBwb3NpdGlvbldpdGhPcmlnaW47XG4gICAgbGV0IGFic29sdXRlUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHsgeDogcGFyZW50WCArIGNsYW1wZWRQb3NpdGlvbi54LCB5OiBwYXJlbnRZICsgY2xhbXBlZFBvc2l0aW9uLnkgfSwgbm9kZUV4dGVudCwgY2hpbGREaW1lbnNpb25zKTtcbiAgICBpZiAoY2hpbGROb2RlLmV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgYWJzb2x1dGVQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb25Ub1BhcmVudChhYnNvbHV0ZVBvc2l0aW9uLCBjaGlsZERpbWVuc2lvbnMsIHBhcmVudE5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZFogPSBjYWxjdWxhdGVaKGNoaWxkTm9kZSwgc2VsZWN0ZWROb2RlWiwgekluZGV4TW9kZSk7XG4gICAgY29uc3QgcGFyZW50WiA9IHBhcmVudE5vZGUuaW50ZXJuYWxzLnogPz8gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBhYnNvbHV0ZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IGFic29sdXRlUG9zaXRpb24ueSxcbiAgICAgICAgejogcGFyZW50WiA+PSBjaGlsZFogPyBwYXJlbnRaICsgMSA6IGNoaWxkWixcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlRXhwYW5kUGFyZW50KGNoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0pIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3QgcGFyZW50RXhwYW5zaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGV4cGFuZGVkIHJlY3RhbmdsZSB0aGUgY2hpbGQgbm9kZXMgd291bGQgdGFrZSBmb3IgZWFjaCBwYXJlbnRcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGVMb29rdXAuZ2V0KGNoaWxkLnBhcmVudElkKTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFJlY3QgPSBwYXJlbnRFeHBhbnNpb25zLmdldChjaGlsZC5wYXJlbnRJZCk/LmV4cGFuZGVkUmVjdCA/PyBub2RlVG9SZWN0KHBhcmVudCk7XG4gICAgICAgIGNvbnN0IGV4cGFuZGVkUmVjdCA9IGdldEJvdW5kc09mUmVjdHMocGFyZW50UmVjdCwgY2hpbGQucmVjdCk7XG4gICAgICAgIHBhcmVudEV4cGFuc2lvbnMuc2V0KGNoaWxkLnBhcmVudElkLCB7IGV4cGFuZGVkUmVjdCwgcGFyZW50IH0pO1xuICAgIH1cbiAgICBpZiAocGFyZW50RXhwYW5zaW9ucy5zaXplID4gMCkge1xuICAgICAgICBwYXJlbnRFeHBhbnNpb25zLmZvckVhY2goKHsgZXhwYW5kZWRSZWN0LCBwYXJlbnQgfSwgcGFyZW50SWQpID0+IHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgcG9zaXRpb24gJiBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSBwYXJlbnQuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMocGFyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IHBhcmVudC5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBob3cgbXVjaCB0aGUgcGFyZW50IGV4cGFuZHMgaW4gd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0gZXhwYW5kZWRSZWN0LnggPCBwb3NpdGlvbkFic29sdXRlLnggPyBNYXRoLnJvdW5kKE1hdGguYWJzKHBvc2l0aW9uQWJzb2x1dGUueCAtIGV4cGFuZGVkUmVjdC54KSkgOiAwO1xuICAgICAgICAgICAgY29uc3QgeUNoYW5nZSA9IGV4cGFuZGVkUmVjdC55IDwgcG9zaXRpb25BYnNvbHV0ZS55ID8gTWF0aC5yb3VuZChNYXRoLmFicyhwb3NpdGlvbkFic29sdXRlLnkgLSBleHBhbmRlZFJlY3QueSkpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoZGltZW5zaW9ucy53aWR0aCwgTWF0aC5yb3VuZChleHBhbmRlZFJlY3Qud2lkdGgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KGRpbWVuc2lvbnMuaGVpZ2h0LCBNYXRoLnJvdW5kKGV4cGFuZGVkUmVjdC5oZWlnaHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoQ2hhbmdlID0gKG5ld1dpZHRoIC0gZGltZW5zaW9ucy53aWR0aCkgKiBvcmlnaW5bMF07XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRDaGFuZ2UgPSAobmV3SGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQpICogb3JpZ2luWzFdO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFyZW50IG5vZGUgaWYgdGhlIG9yaWdpbiBpcyBub3QgWzAsMF1cbiAgICAgICAgICAgIGlmICh4Q2hhbmdlID4gMCB8fCB5Q2hhbmdlID4gMCB8fCB3aWR0aENoYW5nZSB8fCBoZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBwYXJlbnQucG9zaXRpb24ueCAtIHhDaGFuZ2UgKyB3aWR0aENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBhcmVudC5wb3NpdGlvbi55IC0geUNoYW5nZSArIGhlaWdodENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFdlIG1vdmUgYWxsIGNoaWxkIG5vZGVzIGluIHRoZSBvcHBzaXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAqIHNvIHRoZSB4LHkgY2hhbmdlcyBvZiB0aGUgcGFyZW50IGRvIG5vdCBtb3ZlIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHBhcmVudExvb2t1cC5nZXQocGFyZW50SWQpPy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5zb21lKChjaGlsZCkgPT4gY2hpbGQuaWQgPT09IGNoaWxkTm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkTm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoaWxkTm9kZS5wb3NpdGlvbi54ICsgeENoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgKyB5Q2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjb3JyZWN0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGUgb3JpZ2luIGlzIG5vdCBbMCwwXVxuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCBleHBhbmRlZFJlY3Qud2lkdGggfHwgZGltZW5zaW9ucy5oZWlnaHQgPCBleHBhbmRlZFJlY3QuaGVpZ2h0IHx8IHhDaGFuZ2UgfHwgeUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogbmV3V2lkdGggKyAoeENoYW5nZSA/IG9yaWdpblswXSAqIHhDaGFuZ2UgLSB3aWR0aENoYW5nZSA6IDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdIZWlnaHQgKyAoeUNoYW5nZSA/IG9yaWdpblsxXSAqIHlDaGFuZ2UgLSBoZWlnaHRDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gdXBkYXRlTm9kZUludGVybmFscyh1cGRhdGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHpJbmRleE1vZGUpIHtcbiAgICBjb25zdCB2aWV3cG9ydE5vZGUgPSBkb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcueHlmbG93X192aWV3cG9ydCcpO1xuICAgIGxldCB1cGRhdGVkSW50ZXJuYWxzID0gZmFsc2U7XG4gICAgaWYgKCF2aWV3cG9ydE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogW10sIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodmlld3BvcnROb2RlKTtcbiAgICBjb25zdCB7IG0yMjogem9vbSB9ID0gbmV3IHdpbmRvdy5ET01NYXRyaXhSZWFkT25seShzdHlsZS50cmFuc2Zvcm0pO1xuICAgIC8vIGluIHRoaXMgYXJyYXkgd2UgY29sbGVjdCBub2RlcywgdGhhdCBtaWdodCB0cmlnZ2VyIGNoYW5nZXMgKGxpa2UgZXhwYW5kaW5nIHBhcmVudClcbiAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KHVwZGF0ZS5pZCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUJvdW5kczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnModXBkYXRlLm5vZGVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlZCA9IG5vZGUubWVhc3VyZWQud2lkdGggIT09IGRpbWVuc2lvbnMud2lkdGggfHwgbm9kZS5tZWFzdXJlZC5oZWlnaHQgIT09IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBkb1VwZGF0ZSA9ICEhKGRpbWVuc2lvbnMud2lkdGggJiZcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICYmXG4gICAgICAgICAgICAoZGltZW5zaW9uQ2hhbmdlZCB8fCAhbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzIHx8IHVwZGF0ZS5mb3JjZSkpO1xuICAgICAgICBpZiAoZG9VcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVCb3VuZHMgPSB1cGRhdGUubm9kZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBleHRlbnQgPSBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpID8gbm9kZS5leHRlbnQgOiBub2RlRXh0ZW50O1xuICAgICAgICAgICAgbGV0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gbm9kZS5pbnRlcm5hbHM7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiBub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlID0gY2xhbXBQb3NpdGlvblRvUGFyZW50KHBvc2l0aW9uQWJzb2x1dGUsIGRpbWVuc2lvbnMsIG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQWJzb2x1dGUgPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uQWJzb2x1dGUsIGV4dGVudCwgZGltZW5zaW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZ2V0SGFuZGxlQm91bmRzKCdzb3VyY2UnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnZXRIYW5kbGVCb3VuZHMoJ3RhcmdldCcsIHVwZGF0ZS5ub2RlRWxlbWVudCwgbm9kZUJvdW5kcywgem9vbSwgbm9kZS5pZCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5ld05vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgeyBub2RlT3JpZ2luLCB6SW5kZXhNb2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZEludGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGltZW5zaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZXhwYW5kUGFyZW50ICYmIG5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdDogbm9kZVRvUmVjdChuZXdOb2RlLCBub2RlT3JpZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnRFeHBhbmRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEV4cGFuZENoYW5nZXMgPSBoYW5kbGVFeHBhbmRQYXJlbnQocGFyZW50RXhwYW5kQ2hpbGRyZW4sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhbmdlcywgdXBkYXRlZEludGVybmFscyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFuQnkoeyBkZWx0YSwgcGFuWm9vbSwgdHJhbnNmb3JtLCB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIH0pIHtcbiAgICBpZiAoIXBhblpvb20gfHwgKCFkZWx0YS54ICYmICFkZWx0YS55KSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFZpZXdwb3J0ID0gYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdHJhbnNmb3JtWzBdICsgZGVsdGEueCxcbiAgICAgICAgeTogdHJhbnNmb3JtWzFdICsgZGVsdGEueSxcbiAgICAgICAgem9vbTogdHJhbnNmb3JtWzJdLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbd2lkdGgsIGhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1DaGFuZ2VkID0gISFuZXh0Vmlld3BvcnQgJiZcbiAgICAgICAgKG5leHRWaWV3cG9ydC54ICE9PSB0cmFuc2Zvcm1bMF0gfHwgbmV4dFZpZXdwb3J0LnkgIT09IHRyYW5zZm9ybVsxXSB8fCBuZXh0Vmlld3BvcnQuayAhPT0gdHJhbnNmb3JtWzJdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRyYW5zZm9ybUNoYW5nZWQpO1xufVxuLyoqXG4gKiB0aGlzIGZ1bmN0aW9uIGFkZHMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGNvbm5lY3Rpb25Mb29rdXBcbiAqIGF0IHRoZSBmb2xsb3dpbmcga2V5czogbm9kZUlkLXR5cGUtaGFuZGxlSWQsIG5vZGVJZC10eXBlIGFuZCBub2RlSWRcbiAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBjb25uZWN0aW9uIGNvbm5lY3Rpb24gdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIGxvb2t1cFxuICogQHBhcmFtIGNvbm5lY3Rpb25LZXkgYXQgd2hpY2gga2V5IHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhZGRlZFxuICogQHBhcmFtIGNvbm5lY3Rpb25Mb29rdXAgcmVmZXJlbmNlIHRvIHRoZSBjb25uZWN0aW9uIGxvb2t1cFxuICogQHBhcmFtIG5vZGVJZCBub2RlSWQgb2YgdGhlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBoYW5kbGVJZCBoYW5kbGVJZCBvZiB0aGUgY29ubmVjaXRvblxuICovXG5mdW5jdGlvbiBhZGRDb25uZWN0aW9uVG9Mb29rdXAodHlwZSwgY29ubmVjdGlvbiwgY29ubmVjdGlvbktleSwgY29ubmVjdGlvbkxvb2t1cCwgbm9kZUlkLCBoYW5kbGVJZCkge1xuICAgIC8qXG4gICAgICogV2UgYWRkIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBjb25uZWN0aW9uTG9va3VwIGF0IHRoZSBmb2xsb3dpbmcga2V5c1xuICAgICAqIDEuIG5vZGVJZCwgMi4gbm9kZUlkLXR5cGUsIDMuIG5vZGVJZC10eXBlLWhhbmRsZUlkXG4gICAgICogSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cywgd2UgYWRkIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBleGlzdGluZyBtYXBcbiAgICAgKi9cbiAgICBsZXQga2V5ID0gbm9kZUlkO1xuICAgIGNvbnN0IG5vZGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIG5vZGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICBrZXkgPSBgJHtub2RlSWR9LSR7dHlwZX1gO1xuICAgIGNvbnN0IHR5cGVNYXAgPSBjb25uZWN0aW9uTG9va3VwLmdldChrZXkpIHx8IG5ldyBNYXAoKTtcbiAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIHR5cGVNYXAuc2V0KGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb24pKTtcbiAgICBpZiAoaGFuZGxlSWQpIHtcbiAgICAgICAga2V5ID0gYCR7bm9kZUlkfS0ke3R5cGV9LSR7aGFuZGxlSWR9YDtcbiAgICAgICAgY29uc3QgaGFuZGxlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIGNvbm5lY3Rpb25Mb29rdXAuc2V0KGtleSwgaGFuZGxlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBlZGdlcykge1xuICAgIGNvbm5lY3Rpb25Mb29rdXAuY2xlYXIoKTtcbiAgICBlZGdlTG9va3VwLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlOiBzb3VyY2VOb2RlLCB0YXJnZXQ6IHRhcmdldE5vZGUsIHNvdXJjZUhhbmRsZSA9IG51bGwsIHRhcmdldEhhbmRsZSA9IG51bGwgfSA9IGVkZ2U7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7IGVkZ2VJZDogZWRnZS5pZCwgc291cmNlOiBzb3VyY2VOb2RlLCB0YXJnZXQ6IHRhcmdldE5vZGUsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH07XG4gICAgICAgIGNvbnN0IHNvdXJjZUtleSA9IGAke3NvdXJjZU5vZGV9LSR7c291cmNlSGFuZGxlfS0tJHt0YXJnZXROb2RlfS0ke3RhcmdldEhhbmRsZX1gO1xuICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSBgJHt0YXJnZXROb2RlfS0ke3RhcmdldEhhbmRsZX0tLSR7c291cmNlTm9kZX0tJHtzb3VyY2VIYW5kbGV9YDtcbiAgICAgICAgYWRkQ29ubmVjdGlvblRvTG9va3VwKCdzb3VyY2UnLCBjb25uZWN0aW9uLCB0YXJnZXRLZXksIGNvbm5lY3Rpb25Mb29rdXAsIHNvdXJjZU5vZGUsIHNvdXJjZUhhbmRsZSk7XG4gICAgICAgIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCgndGFyZ2V0JywgY29ubmVjdGlvbiwgc291cmNlS2V5LCBjb25uZWN0aW9uTG9va3VwLCB0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUpO1xuICAgICAgICBlZGdlTG9va3VwLnNldChlZGdlLmlkLCBlZGdlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dOb2RlRGF0YShhLCBiKSB7XG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IF9hID0gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XG4gICAgY29uc3QgX2IgPSBBcnJheS5pc0FycmF5KGIpID8gYiA6IFtiXTtcbiAgICBpZiAoX2EubGVuZ3RoICE9PSBfYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9hLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChfYVtpXS5pZCAhPT0gX2JbaV0uaWQgfHwgX2FbaV0udHlwZSAhPT0gX2JbaV0udHlwZSB8fCAhT2JqZWN0LmlzKF9hW2ldLmRhdGEsIF9iW2ldLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkge1xuICAgIGlmICghbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5zZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzUGFyZW50U2VsZWN0ZWQocGFyZW50Tm9kZSwgbm9kZUxvb2t1cCk7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rvcih0YXJnZXQsIHNlbGVjdG9yLCBkb21Ob2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAoY3VycmVudD8ubWF0Y2hlcz8uKHNlbGVjdG9yKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gZG9tTm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQ/LnBhcmVudEVsZW1lbnQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gbG9va3MgZm9yIGFsbCBzZWxlY3RlZCBub2RlcyBhbmQgY3JlYXRlZCBhIE5vZGVEcmFnSXRlbSBmb3IgZWFjaCBvZiB0aGVtXG5mdW5jdGlvbiBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIG1vdXNlUG9zLCBub2RlSWQpIHtcbiAgICBjb25zdCBkcmFnSXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbaWQsIG5vZGVdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKChub2RlLnNlbGVjdGVkIHx8IG5vZGUuaWQgPT09IG5vZGVJZCkgJiZcbiAgICAgICAgICAgICghbm9kZS5wYXJlbnRJZCB8fCAhaXNQYXJlbnRTZWxlY3RlZChub2RlLCBub2RlTG9va3VwKSkgJiZcbiAgICAgICAgICAgIChub2RlLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG5vZGUuZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbE5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxOb2RlKSB7XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGludGVybmFsTm9kZS5wb3NpdGlvbiB8fCB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IG1vdXNlUG9zLnggLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG1vdXNlUG9zLnkgLSBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBpbnRlcm5hbE5vZGUuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogaW50ZXJuYWxOb2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGludGVybmFsTm9kZS5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZFBhcmVudDogaW50ZXJuYWxOb2RlLmV4cGFuZFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlOiBpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lYXN1cmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW50ZXJuYWxOb2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGludGVybmFsTm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHJhZ0l0ZW1zO1xufVxuLypcbiAqIHJldHVybnMgdHdvIHBhcmFtczpcbiAqIDEuIHRoZSBkcmFnZ2VkIG5vZGUgKG9yIHRoZSBmaXJzdCBvZiB0aGUgbGlzdCwgaWYgd2UgYXJlIGRyYWdnaW5nIGEgbm9kZSBzZWxlY3Rpb24pXG4gKiAyLiBhcnJheSBvZiBzZWxlY3RlZCBub2RlcyAoZm9yIG11bHRpIHNlbGVjdGlvbnMpXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlclBhcmFtcyh7IG5vZGVJZCwgZHJhZ0l0ZW1zLCBub2RlTG9va3VwLCBkcmFnZ2luZyA9IHRydWUsIH0pIHtcbiAgICBjb25zdCBub2Rlc0Zyb21EcmFnSXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICByZXR1cm4gW25vZGVzRnJvbURyYWdJdGVtc1swXSwgbm9kZXNGcm9tRHJhZ0l0ZW1zXTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk/LmludGVybmFscy51c2VyTm9kZTtcbiAgICByZXR1cm4gW1xuICAgICAgICAhbm9kZVxuICAgICAgICAgICAgPyBub2Rlc0Zyb21EcmFnSXRlbXNbMF1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtcy5nZXQobm9kZUlkKT8ucG9zaXRpb24gfHwgbm9kZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIG5vZGVzRnJvbURyYWdJdGVtcyxcbiAgICBdO1xufVxuLyoqXG4gKiBJZiBhIHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkIHdlIHdhbnQgdG8gYXBwbHkgdGhlIHNhbWUgc25hcCBvZmZzZXQgdG8gYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNuYXAgb2Zmc2V0IGJhc2VkIG9uIHRoZSBmaXJzdCBub2RlIGluIHRoZSBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNuYXBPZmZzZXQoeyBkcmFnSXRlbXMsIHNuYXBHcmlkLCB4LCB5LCB9KSB7XG4gICAgY29uc3QgcmVmRHJhZ0l0ZW0gPSBkcmFnSXRlbXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgIGlmICghcmVmRHJhZ0l0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZlBvcyA9IHtcbiAgICAgICAgeDogeCAtIHJlZkRyYWdJdGVtLmRpc3RhbmNlLngsXG4gICAgICAgIHk6IHkgLSByZWZEcmFnSXRlbS5kaXN0YW5jZS55LFxuICAgIH07XG4gICAgY29uc3QgcmVmUG9zU25hcHBlZCA9IHNuYXBQb3NpdGlvbihyZWZQb3MsIHNuYXBHcmlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByZWZQb3NTbmFwcGVkLnggLSByZWZQb3MueCxcbiAgICAgICAgeTogcmVmUG9zU25hcHBlZC55IC0gcmVmUG9zLnksXG4gICAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIFhZRHJhZyh7IG9uTm9kZU1vdXNlRG93biwgZ2V0U3RvcmVJdGVtcywgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnU3RvcCwgfSkge1xuICAgIGxldCBsYXN0UG9zID0geyB4OiBudWxsLCB5OiBudWxsIH07XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGRyYWdJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbW91c2VQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgIGxldCBjb250YWluZXJCb3VuZHMgPSBudWxsO1xuICAgIGxldCBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBkM1NlbGVjdGlvbiA9IG51bGw7XG4gICAgbGV0IGFib3J0RHJhZyA9IGZhbHNlOyAvLyBwcmV2ZW50cyB1bmludGVudGlvbmFsIGRyYWdnaW5nIG9uIG11bHRpdG91Y2hcbiAgICBsZXQgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAvLyB3ZSBzdG9yZSB0aGUgbGFzdCBkcmFnIGV2ZW50IHRvIGJlIGFibGUgdG8gdXNlIGl0IGluIHRoZSB1cGRhdGUgZnVuY3Rpb25cbiAgICBsZXQgZHJhZ0V2ZW50ID0gbnVsbDtcbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3RvciwgZG9tTm9kZSwgaXNTZWxlY3RhYmxlLCBub2RlSWQsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgfSkge1xuICAgICAgICBkM1NlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTm9kZXMoeyB4LCB5IH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZUV4dGVudCwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW4sIG9uTm9kZURyYWcsIG9uU2VsZWN0aW9uRHJhZywgb25FcnJvciwgdXBkYXRlTm9kZVBvc2l0aW9ucywgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSB7IHgsIHkgfTtcbiAgICAgICAgICAgIGxldCBoYXNDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGlzTXVsdGlEcmFnID0gZHJhZ0l0ZW1zLnNpemUgPiAxO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXNCb3ggPSBpc011bHRpRHJhZyAmJiBub2RlRXh0ZW50ID8gcmVjdFRvQm94KGdldEludGVybmFsTm9kZXNCb3VuZHMoZHJhZ0l0ZW1zKSkgOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgbXVsdGlEcmFnU25hcE9mZnNldCA9IGlzTXVsdGlEcmFnICYmIHNuYXBUb0dyaWRcbiAgICAgICAgICAgICAgICA/IGNhbGN1bGF0ZVNuYXBPZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBkcmFnSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlmIHRoZSBub2RlIGlzIG5vdCBpbiB0aGUgbm9kZUxvb2t1cCBhbnltb3JlLCBpdCB3YXMgcHJvYmFibHkgZGVsZXRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvc2l0aW9uID0geyB4OiB4IC0gZHJhZ0l0ZW0uZGlzdGFuY2UueCwgeTogeSAtIGRyYWdJdGVtLmRpc3RhbmNlLnkgfTtcbiAgICAgICAgICAgICAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBtdWx0aURyYWdTbmFwT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi54ICsgbXVsdGlEcmFnU25hcE9mZnNldC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG5leHRQb3NpdGlvbi55ICsgbXVsdGlEcmFnU25hcE9mZnNldC55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogc25hcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgc25hcEdyaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYWRqdXN0ZWROb2RlRXh0ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aURyYWcgJiYgbm9kZUV4dGVudCAmJiAhZHJhZ0l0ZW0uZXh0ZW50ICYmIG5vZGVzQm94KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb25BYnNvbHV0ZSB9ID0gZHJhZ0l0ZW0uaW50ZXJuYWxzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MSA9IHBvc2l0aW9uQWJzb2x1dGUueCAtIG5vZGVzQm94LnggKyBub2RlRXh0ZW50WzBdWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4MiA9IHBvc2l0aW9uQWJzb2x1dGUueCArIGRyYWdJdGVtLm1lYXN1cmVkLndpZHRoIC0gbm9kZXNCb3gueDIgKyBub2RlRXh0ZW50WzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MSA9IHBvc2l0aW9uQWJzb2x1dGUueSAtIG5vZGVzQm94LnkgKyBub2RlRXh0ZW50WzBdWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHBvc2l0aW9uQWJzb2x1dGUueSArIGRyYWdJdGVtLm1lYXN1cmVkLmhlaWdodCAtIG5vZGVzQm94LnkyICsgbm9kZUV4dGVudFsxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWROb2RlRXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgW3gxLCB5MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbeDIsIHkyXSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiwgcG9zaXRpb25BYnNvbHV0ZSB9ID0gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgICAgICBub2RlRXh0ZW50OiBhZGp1c3RlZE5vZGVFeHRlbnQgPyBhZGp1c3RlZE5vZGVFeHRlbnQgOiBub2RlRXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBmaXJlIGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2UgPSBoYXNDaGFuZ2UgfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueCAhPT0gcG9zaXRpb24ueCB8fCBkcmFnSXRlbS5wb3NpdGlvbi55ICE9PSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgPSBwb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBub2RlUG9zaXRpb25zQ2hhbmdlZCB8fCBoYXNDaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIWhhc0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChkcmFnRXZlbnQgJiYgKG9uRHJhZyB8fCBvbk5vZGVEcmFnIHx8ICghbm9kZUlkICYmIG9uU2VsZWN0aW9uRHJhZykpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICBkcmFnSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25EcmFnPy4oZHJhZ0V2ZW50LCBkcmFnSXRlbXMsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIG9uTm9kZURyYWc/LihkcmFnRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZz8uKGRyYWdFdmVudCwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gYXV0b1BhbigpIHtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHBhbkJ5LCBhdXRvUGFuU3BlZWQsIGF1dG9QYW5Pbk5vZGVEcmFnIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBpZiAoIWF1dG9QYW5Pbk5vZGVEcmFnKSB7XG4gICAgICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFt4TW92ZW1lbnQsIHlNb3ZlbWVudF0gPSBjYWxjQXV0b1Bhbihtb3VzZVBvc2l0aW9uLCBjb250YWluZXJCb3VuZHMsIGF1dG9QYW5TcGVlZCk7XG4gICAgICAgICAgICBpZiAoeE1vdmVtZW50ICE9PSAwIHx8IHlNb3ZlbWVudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RQb3MueCA9IChsYXN0UG9zLnggPz8gMCkgLSB4TW92ZW1lbnQgLyB0cmFuc2Zvcm1bMl07XG4gICAgICAgICAgICAgICAgbGFzdFBvcy55ID0gKGxhc3RQb3MueSA/PyAwKSAtIHlNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXQgcGFuQnkoeyB4OiB4TW92ZW1lbnQsIHk6IHlNb3ZlbWVudCB9KSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVOb2RlcyhsYXN0UG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvUGFuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhcnREcmFnKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIG11bHRpU2VsZWN0aW9uQWN0aXZlLCBub2Rlc0RyYWdnYWJsZSwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgc2VsZWN0Tm9kZXNPbkRyYWcsIG9uTm9kZURyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RhcnQsIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGRyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgoIXNlbGVjdE5vZGVzT25EcmFnIHx8ICFpc1NlbGVjdGFibGUpICYmICFtdWx0aVNlbGVjdGlvbkFjdGl2ZSAmJiBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVMb29rdXAuZ2V0KG5vZGVJZCk/LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzZXQgc2VsZWN0ZWQgbm9kZXMgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz1mYWxzZVxuICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmIHNlbGVjdE5vZGVzT25EcmFnICYmIG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIG9uTm9kZU1vdXNlRG93bj8uKG5vZGVJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb2ludGVyUG9zO1xuICAgICAgICAgICAgZHJhZ0l0ZW1zID0gZ2V0RHJhZ0l0ZW1zKG5vZGVMb29rdXAsIG5vZGVzRHJhZ2dhYmxlLCBwb2ludGVyUG9zLCBub2RlSWQpO1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMCAmJiAob25EcmFnU3RhcnQgfHwgb25Ob2RlRHJhZ1N0YXJ0IHx8ICghbm9kZUlkICYmIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBkcmFnSXRlbXMsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIG9uTm9kZURyYWdTdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGlvbkRyYWdTdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkM0RyYWdJbnN0YW5jZSA9IGRyYWcoKVxuICAgICAgICAgICAgLmNsaWNrRGlzdGFuY2Uobm9kZUNsaWNrRGlzdGFuY2UpXG4gICAgICAgICAgICAub24oJ3N0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbU5vZGUsIG5vZGVEcmFnVGhyZXNob2xkLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB8fCBudWxsO1xuICAgICAgICAgICAgYWJvcnREcmFnID0gZmFsc2U7XG4gICAgICAgICAgICBub2RlUG9zaXRpb25zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ0V2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQ7XG4gICAgICAgICAgICBpZiAobm9kZURyYWdUaHJlc2hvbGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydERyYWcoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBjb250YWluZXJCb3VuZHMgfSk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9pbnRlclBvcztcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dG9QYW5Pbk5vZGVEcmFnLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlRHJhZ1RocmVzaG9sZCwgbm9kZUxvb2t1cCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvcyA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBjb250YWluZXJCb3VuZHMgfSk7XG4gICAgICAgICAgICBkcmFnRXZlbnQgPSBldmVudC5zb3VyY2VFdmVudDtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgZGVsZXRlcyBhIG5vZGUgd2hpbGUgZHJhZ2dpbmcsIHdlIG5lZWQgdG8gYWJvcnQgdGhlIGRyYWcgdG8gcHJldmVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAobm9kZUlkICYmICFub2RlTG9va3VwLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgICAgIGFib3J0RHJhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnREcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCAmJiBhdXRvUGFuT25Ob2RlRHJhZyAmJiBkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdXRvUGFuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGluIGNsaWVudCBjb29yZGluYXRlcyBmb3IgY29uc2lzdGVudCBkcmFnIHRocmVzaG9sZCBiZWhhdmlvciBhY3Jvc3Mgem9vbSBsZXZlbHNcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLnggLSBtb3VzZVBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGN1cnJlbnRNb3VzZVBvc2l0aW9uLnkgLSBtb3VzZVBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbm9kZURyYWdUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREcmFnKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIGV2ZW50cyB3aXRob3V0IG1vdmVtZW50XG4gICAgICAgICAgICBpZiAoKGxhc3RQb3MueCAhPT0gcG9pbnRlclBvcy54U25hcHBlZCB8fCBsYXN0UG9zLnkgIT09IHBvaW50ZXJQb3MueVNuYXBwZWQpICYmIGRyYWdJdGVtcyAmJiBkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG1vdXNlUG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKHBvaW50ZXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdlbmQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0ZWQgfHwgYWJvcnREcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdXBkYXRlTm9kZVBvc2l0aW9ucywgb25Ob2RlRHJhZ1N0b3AsIG9uU2VsZWN0aW9uRHJhZ1N0b3AgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVBvc2l0aW9uc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBvc2l0aW9uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uRHJhZ1N0b3AgfHwgb25Ob2RlRHJhZ1N0b3AgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RvcD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gIWV2ZW50LmJ1dHRvbiAmJlxuICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgZG9tTm9kZSkpICYmXG4gICAgICAgICAgICAgICAgKCFoYW5kbGVTZWxlY3RvciB8fCBoYXNTZWxlY3Rvcih0YXJnZXQsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNEcmFnZ2FibGU7XG4gICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5jYWxsKGQzRHJhZ0luc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZDNTZWxlY3Rpb24/Lm9uKCcuZHJhZycsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uLnggLSBkaXN0YW5jZSxcbiAgICAgICAgeTogcG9zaXRpb24ueSAtIGRpc3RhbmNlLFxuICAgICAgICB3aWR0aDogZGlzdGFuY2UgKiAyLFxuICAgICAgICBoZWlnaHQ6IGRpc3RhbmNlICogMixcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTG9va3VwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChnZXRPdmVybGFwcGluZ0FyZWEocmVjdCwgbm9kZVRvUmVjdChub2RlKSkgPiAwKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbi8qXG4gKiB0aGlzIGRpc3RhbmNlIGlzIHVzZWQgZm9yIHRoZSBhcmVhIGFyb3VuZCB0aGUgdXNlciBwb2ludGVyXG4gKiB3aGlsZSBkb2luZyBhIGNvbm5lY3Rpb24gZm9yIGZpbmRpbmcgdGhlIGNsb3Nlc3Qgbm9kZXNcbiAqL1xuY29uc3QgQURESVRJT05BTF9ESVNUQU5DRSA9IDI1MDtcbmZ1bmN0aW9uIGdldENsb3Nlc3RIYW5kbGUocG9zaXRpb24sIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpIHtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZXMgPSBbXTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjbG9zZU5vZGVzID0gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgY29ubmVjdGlvblJhZGl1cyArIEFERElUSU9OQUxfRElTVEFOQ0UpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjbG9zZU5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGFsbEhhbmRsZXMgPSBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGFsbEhhbmRsZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoYW5kbGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZyb21IYW5kbGUgd2Ugc2tpcCBpdFxuICAgICAgICAgICAgaWYgKGZyb21IYW5kbGUubm9kZUlkID09PSBoYW5kbGUubm9kZUlkICYmIGZyb21IYW5kbGUudHlwZSA9PT0gaGFuZGxlLnR5cGUgJiYgZnJvbUhhbmRsZS5pZCA9PT0gaGFuZGxlLmlkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZVxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyh5IC0gcG9zaXRpb24ueSwgMikpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gY29ubmVjdGlvblJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcyA9IFt7IC4uLmhhbmRsZSwgeCwgeSB9XTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBvbiB0aGUgc2FtZSBkaXN0YW5jZSB3ZSBjb2xsZWN0IGFsbCBvZiB0aGVtXG4gICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMucHVzaCh7IC4uLmhhbmRsZSwgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3RIYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIG92ZXJsYXkgZWFjaCBvdGhlciB3ZSBwcmVmZXIgdGhlIG9wcG9zaXRlIGhhbmRsZVxuICAgIGlmIChjbG9zZXN0SGFuZGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IG9wcG9zaXRlSGFuZGxlVHlwZSA9IGZyb21IYW5kbGUudHlwZSA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXMuZmluZCgoaGFuZGxlKSA9PiBoYW5kbGUudHlwZSA9PT0gb3Bwb3NpdGVIYW5kbGVUeXBlKSA/PyBjbG9zZXN0SGFuZGxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzWzBdO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlKG5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB3aXRoQWJzb2x1dGVQb3NpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVzID0gY29ubmVjdGlvbk1vZGUgPT09ICdzdHJpY3QnXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZV1cbiAgICAgICAgOiBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgY29uc3QgaGFuZGxlID0gKGhhbmRsZUlkID8gaGFuZGxlcz8uZmluZCgoaCkgPT4gaC5pZCA9PT0gaGFuZGxlSWQpIDogaGFuZGxlcz8uWzBdKSA/PyBudWxsO1xuICAgIHJldHVybiBoYW5kbGUgJiYgd2l0aEFic29sdXRlUG9zaXRpb25cbiAgICAgICAgPyB7IC4uLmhhbmRsZSwgLi4uZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBoYW5kbGUucG9zaXRpb24sIHRydWUpIH1cbiAgICAgICAgOiBoYW5kbGU7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSkge1xuICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VVcGRhdGVyVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXQnKSkge1xuICAgICAgICByZXR1cm4gJ3RhcmdldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJykpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2UnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvblZhbGlkKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cywgaXNIYW5kbGVWYWxpZCkge1xuICAgIGxldCBpc1ZhbGlkID0gbnVsbDtcbiAgICBpZiAoaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzICYmICFpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59XG5cbmNvbnN0IGFsd2F5c1ZhbGlkID0gKCkgPT4gdHJ1ZTtcbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIHsgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZUlkLCBub2RlSWQsIGVkZ2VVcGRhdGVyVHlwZSwgaXNUYXJnZXQsIGRvbU5vZGUsIG5vZGVMb29rdXAsIGxpYiwgYXV0b1Bhbk9uQ29ubmVjdCwgZmxvd0lkLCBwYW5CeSwgY2FuY2VsQ29ubmVjdGlvbiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdCwgb25Db25uZWN0RW5kLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBvblJlY29ubmVjdEVuZCwgdXBkYXRlQ29ubmVjdGlvbiwgZ2V0VHJhbnNmb3JtLCBnZXRGcm9tSGFuZGxlLCBhdXRvUGFuU3BlZWQsIGRyYWdUaHJlc2hvbGQgPSAxLCBoYW5kbGVEb21Ob2RlLCB9KSB7XG4gICAgLy8gd2hlbiB4eWZsb3cgaXMgdXNlZCBpbnNpZGUgYSBzaGFkb3cgcm9vdCB3ZSBjYW4ndCB1c2UgZG9jdW1lbnRcbiAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgIGxldCBhdXRvUGFuSWQgPSAwO1xuICAgIGxldCBjbG9zZXN0SGFuZGxlO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlVHlwZSA9IGdldEhhbmRsZVR5cGUoZWRnZVVwZGF0ZXJUeXBlLCBoYW5kbGVEb21Ob2RlKTtcbiAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgY29ubmVjdGlvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWNvbnRhaW5lckJvdW5kcyB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZyb21IYW5kbGVJbnRlcm5hbCA9IGdldEhhbmRsZShub2RlSWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBub2RlTG9va3VwLCBjb25uZWN0aW9uTW9kZSk7XG4gICAgaWYgKCFmcm9tSGFuZGxlSW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgIGxldCBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcbiAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgIGxldCByZXN1bHRIYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIG1vdmluZyB0aGUgbW91c2UgY2xvc2UgdG8gdGhlIGVkZ2Ugb2YgdGhlIGNhbnZhcyB3aGlsZSBjb25uZWN0aW5nIHdlIG1vdmUgdGhlIGNhbnZhc1xuICAgIGZ1bmN0aW9uIGF1dG9QYW4oKSB7XG4gICAgICAgIGlmICghYXV0b1Bhbk9uQ29ubmVjdCB8fCAhY29udGFpbmVyQm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3gsIHldID0gY2FsY0F1dG9QYW4ocG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgcGFuQnkoeyB4LCB5IH0pO1xuICAgICAgICBhdXRvUGFuSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYXV0b1Bhbik7XG4gICAgfVxuICAgIC8vIFN0YXlzIHRoZSBzYW1lIGZvciBhbGwgY29uc2VjdXRpdmUgcG9pbnRlcm1vdmUgZXZlbnRzXG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IHtcbiAgICAgICAgLi4uZnJvbUhhbmRsZUludGVybmFsLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIHR5cGU6IGhhbmRsZVR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiBmcm9tSGFuZGxlSW50ZXJuYWwucG9zaXRpb24sXG4gICAgfTtcbiAgICBjb25zdCBmcm9tSW50ZXJuYWxOb2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBmcm9tID0gZ2V0SGFuZGxlUG9zaXRpb24oZnJvbUludGVybmFsTm9kZSwgZnJvbUhhbmRsZSwgUG9zaXRpb24uTGVmdCwgdHJ1ZSk7XG4gICAgbGV0IHByZXZpb3VzQ29ubmVjdGlvbiA9IHtcbiAgICAgICAgaW5Qcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgaXNWYWxpZDogbnVsbCxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgZnJvbUhhbmRsZSxcbiAgICAgICAgZnJvbVBvc2l0aW9uOiBmcm9tSGFuZGxlLnBvc2l0aW9uLFxuICAgICAgICBmcm9tTm9kZTogZnJvbUludGVybmFsTm9kZSxcbiAgICAgICAgdG86IHBvc2l0aW9uLFxuICAgICAgICB0b0hhbmRsZTogbnVsbCxcbiAgICAgICAgdG9Qb3NpdGlvbjogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgdG9Ob2RlOiBudWxsLFxuICAgICAgICBwb2ludGVyOiBwb3NpdGlvbixcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN0YXJ0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgY29ubmVjdGlvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKHByZXZpb3VzQ29ubmVjdGlvbik7XG4gICAgICAgIG9uQ29ubmVjdFN0YXJ0Py4oZXZlbnQsIHsgbm9kZUlkLCBoYW5kbGVJZCwgaGFuZGxlVHlwZSB9KTtcbiAgICB9XG4gICAgaWYgKGRyYWdUaHJlc2hvbGQgPT09IDApIHtcbiAgICAgICAgc3RhcnRDb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgeyB4OiBldnRYLCB5OiBldnRZIH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gZXZ0WCAtIHg7XG4gICAgICAgICAgICBjb25zdCBkeSA9IGV2dFkgLSB5O1xuICAgICAgICAgICAgY29uc3QgbmV4dENvbm5lY3Rpb25TdGFydGVkID0gZHggKiBkeCArIGR5ICogZHkgPiBkcmFnVGhyZXNob2xkICogZHJhZ1RocmVzaG9sZDtcbiAgICAgICAgICAgIGlmICghbmV4dENvbm5lY3Rpb25TdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFnZXRGcm9tSGFuZGxlKCkgfHwgIWZyb21IYW5kbGUpIHtcbiAgICAgICAgICAgIG9uUG9pbnRlclVwKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICBjbG9zZXN0SGFuZGxlID0gZ2V0Q2xvc2VzdEhhbmRsZShwb2ludFRvUmVuZGVyZXJQb2ludChwb3NpdGlvbiwgdHJhbnNmb3JtLCBmYWxzZSwgWzEsIDFdKSwgY29ubmVjdGlvblJhZGl1cywgbm9kZUxvb2t1cCwgZnJvbUhhbmRsZSk7XG4gICAgICAgIGlmICghYXV0b1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBpc1ZhbGlkSGFuZGxlKGV2ZW50LCB7XG4gICAgICAgICAgICBoYW5kbGU6IGNsb3Nlc3RIYW5kbGUsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGZyb21Ob2RlSWQ6IG5vZGVJZCxcbiAgICAgICAgICAgIGZyb21IYW5kbGVJZDogaGFuZGxlSWQsXG4gICAgICAgICAgICBmcm9tVHlwZTogaXNUYXJnZXQgPyAndGFyZ2V0JyA6ICdzb3VyY2UnLFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0SGFuZGxlRG9tTm9kZSA9IHJlc3VsdC5oYW5kbGVEb21Ob2RlO1xuICAgICAgICBjb25uZWN0aW9uID0gcmVzdWx0LmNvbm5lY3Rpb247XG4gICAgICAgIGlzVmFsaWQgPSBpc0Nvbm5lY3Rpb25WYWxpZCghIWNsb3Nlc3RIYW5kbGUsIHJlc3VsdC5pc1ZhbGlkKTtcbiAgICAgICAgY29uc3QgZnJvbUludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgIGNvbnN0IGZyb20gPSBmcm9tSW50ZXJuYWxOb2RlXG4gICAgICAgICAgICA/IGdldEhhbmRsZVBvc2l0aW9uKGZyb21JbnRlcm5hbE5vZGUsIGZyb21IYW5kbGUsIFBvc2l0aW9uLkxlZnQsIHRydWUpXG4gICAgICAgICAgICA6IHByZXZpb3VzQ29ubmVjdGlvbi5mcm9tO1xuICAgICAgICBjb25zdCBuZXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgLi4ucHJldmlvdXNDb25uZWN0aW9uLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICB0bzogcmVzdWx0LnRvSGFuZGxlICYmIGlzVmFsaWRcbiAgICAgICAgICAgICAgICA/IHJlbmRlcmVyUG9pbnRUb1BvaW50KHsgeDogcmVzdWx0LnRvSGFuZGxlLngsIHk6IHJlc3VsdC50b0hhbmRsZS55IH0sIHRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICA6IHBvc2l0aW9uLFxuICAgICAgICAgICAgdG9IYW5kbGU6IHJlc3VsdC50b0hhbmRsZSxcbiAgICAgICAgICAgIHRvUG9zaXRpb246IGlzVmFsaWQgJiYgcmVzdWx0LnRvSGFuZGxlID8gcmVzdWx0LnRvSGFuZGxlLnBvc2l0aW9uIDogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgICAgIHRvTm9kZTogcmVzdWx0LnRvSGFuZGxlID8gbm9kZUxvb2t1cC5nZXQocmVzdWx0LnRvSGFuZGxlLm5vZGVJZCkgOiBudWxsLFxuICAgICAgICAgICAgcG9pbnRlcjogcG9zaXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24obmV3Q29ubmVjdGlvbik7XG4gICAgICAgIHByZXZpb3VzQ29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIC8vIFByZXZlbnQgbXVsdGktdG91Y2ggYWJvcnRpbmcgY29ubmVjdGlvblxuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGV2ZW50ICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgaWYgKChjbG9zZXN0SGFuZGxlIHx8IHJlc3VsdEhhbmRsZURvbU5vZGUpICYmIGNvbm5lY3Rpb24gJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIG9uQ29ubmVjdD8uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGl0J3MgaW1wb3J0YW50IHRvIGdldCBhIGZyZXNoIHJlZmVyZW5jZSBmcm9tIHRoZSBzdG9yZSBoZXJlXG4gICAgICAgICAgICAgKiBpbiBvcmRlciB0byBnZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBvbkNvbm5lY3RFbmRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgY29uc3QgeyBpblByb2dyZXNzLCAuLi5jb25uZWN0aW9uU3RhdGUgfSA9IHByZXZpb3VzQ29ubmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29ubmVjdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmNvbm5lY3Rpb25TdGF0ZSxcbiAgICAgICAgICAgICAgICB0b1Bvc2l0aW9uOiBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUgPyBwcmV2aW91c0Nvbm5lY3Rpb24udG9Qb3NpdGlvbiA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25Db25uZWN0RW5kPy4oZXZlbnQsIGZpbmFsQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBvblJlY29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbigpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICByZXN1bHRIYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xufVxuLy8gY2hlY2tzIGlmICBhbmQgcmV0dXJucyBjb25uZWN0aW9uIGluIGZvbSBvZiBhbiBvYmplY3QgeyBzb3VyY2U6IDEyMywgdGFyZ2V0OiAzMTIgfVxuZnVuY3Rpb24gaXNWYWxpZEhhbmRsZShldmVudCwgeyBoYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBmcm9tTm9kZUlkLCBmcm9tSGFuZGxlSWQsIGZyb21UeXBlLCBkb2MsIGxpYiwgZmxvd0lkLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBub2RlTG9va3VwLCB9KSB7XG4gICAgY29uc3QgaXNUYXJnZXQgPSBmcm9tVHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3QgaGFuZGxlRG9tTm9kZSA9IGhhbmRsZVxuICAgICAgICA/IGRvYy5xdWVyeVNlbGVjdG9yKGAuJHtsaWJ9LWZsb3dfX2hhbmRsZVtkYXRhLWlkPVwiJHtmbG93SWR9LSR7aGFuZGxlPy5ub2RlSWR9LSR7aGFuZGxlPy5pZH0tJHtoYW5kbGU/LnR5cGV9XCJdYClcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAvKlxuICAgICAqIHdlIGFsd2F5cyB3YW50IHRvIHByaW9yaXRpemUgdGhlIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIG92ZXIgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgaGFuZGxlLFxuICAgICAqIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB0aGUgY2VudGVyIG9mIGFub3RoZXIgaGFuZGxlIGlzIGNsb3NlciB0byB0aGUgbW91c2UgcG9pbnRlciB0aGFuIHRoZSBoYW5kbGUgYmVsb3cgdGhlIGN1cnNvclxuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZVRvQ2hlY2sgPSBoYW5kbGVCZWxvdz8uY2xhc3NMaXN0LmNvbnRhaW5zKGAke2xpYn0tZmxvd19faGFuZGxlYCkgPyBoYW5kbGVCZWxvdyA6IGhhbmRsZURvbU5vZGU7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBoYW5kbGVEb21Ob2RlOiBoYW5kbGVUb0NoZWNrLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgY29ubmVjdGlvbjogbnVsbCxcbiAgICAgICAgdG9IYW5kbGU6IG51bGwsXG4gICAgfTtcbiAgICBpZiAoaGFuZGxlVG9DaGVjaykge1xuICAgICAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZSh1bmRlZmluZWQsIGhhbmRsZVRvQ2hlY2spO1xuICAgICAgICBjb25zdCBoYW5kbGVOb2RlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZScpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZUVuZCA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZWVuZCcpO1xuICAgICAgICBpZiAoIWhhbmRsZU5vZGVJZCB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgc291cmNlOiBpc1RhcmdldCA/IGhhbmRsZU5vZGVJZCA6IGZyb21Ob2RlSWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGlzVGFyZ2V0ID8gaGFuZGxlSWQgOiBmcm9tSGFuZGxlSWQsXG4gICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0ID8gZnJvbU5vZGVJZCA6IGhhbmRsZU5vZGVJZCxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogaXNUYXJnZXQgPyBmcm9tSGFuZGxlSWQgOiBoYW5kbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGUgJiYgY29ubmVjdGFibGVFbmQ7XG4gICAgICAgIC8vIGluIHN0cmljdCBtb2RlIHdlIGRvbid0IGFsbG93IHRhcmdldCB0byB0YXJnZXQgb3Igc291cmNlIHRvIHNvdXJjZSBjb25uZWN0aW9uc1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gaXNDb25uZWN0YWJsZSAmJlxuICAgICAgICAgICAgKGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgICAgICA/IChpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAnc291cmNlJykgfHwgKCFpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAndGFyZ2V0JylcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU5vZGVJZCAhPT0gZnJvbU5vZGVJZCB8fCBoYW5kbGVJZCAhPT0gZnJvbUhhbmRsZUlkKTtcbiAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBpc1ZhbGlkICYmIGlzVmFsaWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICByZXN1bHQudG9IYW5kbGUgPSBnZXRIYW5kbGUoaGFuZGxlTm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgWFlIYW5kbGUgPSB7XG4gICAgb25Qb2ludGVyRG93bixcbiAgICBpc1ZhbGlkOiBpc1ZhbGlkSGFuZGxlLFxufTtcblxuZnVuY3Rpb24gWFlNaW5pbWFwKHsgZG9tTm9kZSwgcGFuWm9vbSwgZ2V0VHJhbnNmb3JtLCBnZXRWaWV3U2NhbGUgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyB0cmFuc2xhdGVFeHRlbnQsIHdpZHRoLCBoZWlnaHQsIHpvb21TdGVwID0gMSwgcGFubmFibGUgPSB0cnVlLCB6b29tYWJsZSA9IHRydWUsIGludmVyc2VQYW4gPSBmYWxzZSwgfSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCB6b29tSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50LnR5cGUgIT09ICd3aGVlbCcgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LnNvdXJjZUV2ZW50LmN0cmxLZXkgJiYgaXNNYWNPcygpID8gMTAgOiAxO1xuICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IC1ldmVudC5zb3VyY2VFdmVudC5kZWx0YVkgKlxuICAgICAgICAgICAgICAgIChldmVudC5zb3VyY2VFdmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqXG4gICAgICAgICAgICAgICAgem9vbVN0ZXA7XG4gICAgICAgICAgICBjb25zdCBuZXh0Wm9vbSA9IHRyYW5zZm9ybVsyXSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEgKiBmYWN0b3IpO1xuICAgICAgICAgICAgcGFuWm9vbS5zY2FsZVRvKG5leHRab29tKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBhblN0YXJ0ID0gWzAsIDBdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5TdGFydEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBwYW5TdGFydCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQuY2xpZW50WCA/PyBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHBhbkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnbW91c2Vtb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAndG91Y2htb3ZlJykgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYW5DdXJyZW50ID0gW1xuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHBhbkRlbHRhID0gW3BhbkN1cnJlbnRbMF0gLSBwYW5TdGFydFswXSwgcGFuQ3VycmVudFsxXSAtIHBhblN0YXJ0WzFdXTtcbiAgICAgICAgICAgIHBhblN0YXJ0ID0gcGFuQ3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVTY2FsZSA9IGdldFZpZXdTY2FsZSgpICogTWF0aC5tYXgodHJhbnNmb3JtWzJdLCBNYXRoLmxvZyh0cmFuc2Zvcm1bMl0pKSAqIChpbnZlcnNlUGFuID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybVswXSAtIHBhbkRlbHRhWzBdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgICAgIHk6IHRyYW5zZm9ybVsxXSAtIHBhbkRlbHRhWzFdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHBhblpvb20uc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIH0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgem9vbUFuZFBhbkhhbmRsZXIgPSB6b29tKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCBwYW5TdGFydEhhbmRsZXIpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAub24oJ3pvb20nLCBwYW5uYWJsZSA/IHBhbkhhbmRsZXIgOiBudWxsKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tLndoZWVsJywgem9vbWFibGUgPyB6b29tSGFuZGxlciA6IG51bGwpO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbCh6b29tQW5kUGFuSGFuZGxlciwge30pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJ3pvb20nLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgICAgICBwb2ludGVyLFxuICAgIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IHRyYW5zZm9ybVRvVmlld3BvcnQgPSAodHJhbnNmb3JtKSA9PiAoe1xuICAgIHg6IHRyYW5zZm9ybS54LFxuICAgIHk6IHRyYW5zZm9ybS55LFxuICAgIHpvb206IHRyYW5zZm9ybS5rLFxufSk7XG5jb25zdCB2aWV3cG9ydFRvVHJhbnNmb3JtID0gKHsgeCwgeSwgem9vbSB9KSA9PiB6b29tSWRlbnRpdHkudHJhbnNsYXRlKHgsIHkpLnNjYWxlKHpvb20pO1xuY29uc3QgaXNXcmFwcGVkV2l0aENsYXNzID0gKGV2ZW50LCBjbGFzc05hbWUpID0+IGV2ZW50LnRhcmdldC5jbG9zZXN0KGAuJHtjbGFzc05hbWV9YCk7XG5jb25zdCBpc1JpZ2h0Q2xpY2tQYW4gPSAocGFuT25EcmFnLCB1c2VkQnV0dG9uKSA9PiB1c2VkQnV0dG9uID09PSAyICYmIEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoMik7XG4vLyB0YWtlbiBmcm9tIGQzLWVhc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1lYXNlL2Jsb2IvbWFpbi9zcmMvY3ViaWMuanNcbmNvbnN0IGRlZmF1bHRFYXNlID0gKHQpID0+ICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbmNvbnN0IGdldEQzVHJhbnNpdGlvbiA9IChzZWxlY3Rpb24sIGR1cmF0aW9uID0gMCwgZWFzZSA9IGRlZmF1bHRFYXNlLCBvbkVuZCA9ICgpID0+IHsgfSkgPT4ge1xuICAgIGNvbnN0IGhhc0R1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBkdXJhdGlvbiA+IDA7XG4gICAgaWYgKCFoYXNEdXJhdGlvbikge1xuICAgICAgICBvbkVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRHVyYXRpb24gPyBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5lYXNlKGVhc2UpLm9uKCdlbmQnLCBvbkVuZCkgOiBzZWxlY3Rpb247XG59O1xuY29uc3Qgd2hlZWxEZWx0YSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWNPcygpID8gMTAgOiAxO1xuICAgIHJldHVybiAtZXZlbnQuZGVsdGFZICogKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDAuMDUgOiBldmVudC5kZWx0YU1vZGUgPyAxIDogMC4wMDIpICogZmFjdG9yO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlUGFuT25TY3JvbGxIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgbm9XaGVlbENsYXNzTmFtZSwgZDNTZWxlY3Rpb24sIGQzWm9vbSwgcGFuT25TY3JvbGxNb2RlLCBwYW5PblNjcm9sbFNwZWVkLCB6b29tT25QaW5jaCwgb25QYW5ab29tU3RhcnQsIG9uUGFuWm9vbSwgb25QYW5ab29tRW5kLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBzdG9wIG5hdGl2ZSBwYWdlIHpvb20gZm9yIHBpbmNoIHpvb21pbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykuayB8fCAxO1xuICAgICAgICAvLyBtYWNvcyBzZXRzIGN0cmxLZXk9dHJ1ZSBmb3IgcGluY2ggZ2VzdHVyZSBvbiBhIHRyYWNrcGFkXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIHpvb21PblBpbmNoKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IHdoZWVsRGVsdGEoZXZlbnQpO1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IGN1cnJlbnRab29tICogTWF0aC5wb3coMiwgcGluY2hEZWx0YSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkM1pvb20uc2NhbGVUbyhkM1NlbGVjdGlvbiwgem9vbSwgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBpbmNyZWFzZSBzY3JvbGwgc3BlZWQgaW4gZmlyZWZveFxuICAgICAgICAgKiBmaXJlZm94OiBkZWx0YU1vZGUgPT09IDE7IGNocm9tZTogZGVsdGFNb2RlID09PSAwXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWx0YU5vcm1hbGl6ZSA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDIwIDogMTtcbiAgICAgICAgbGV0IGRlbHRhWCA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsID8gMCA6IGV2ZW50LmRlbHRhWCAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICBsZXQgZGVsdGFZID0gcGFuT25TY3JvbGxNb2RlID09PSBQYW5PblNjcm9sbE1vZGUuSG9yaXpvbnRhbCA/IDAgOiBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgLy8gdGhpcyBlbmFibGVzIHZlcnRpY2FsIHNjcm9sbGluZyB3aXRoIHNoaWZ0ICsgc2Nyb2xsIG9uIHdpbmRvd3NcbiAgICAgICAgaWYgKCFpc01hY09zKCkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgcGFuT25TY3JvbGxNb2RlICE9PSBQYW5PblNjcm9sbE1vZGUuVmVydGljYWwpIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2ZW50LmRlbHRhWSAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkM1pvb20udHJhbnNsYXRlQnkoZDNTZWxlY3Rpb24sIC0oZGVsdGFYIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgLShkZWx0YVkgLyBjdXJyZW50Wm9vbSkgKiBwYW5PblNjcm9sbFNwZWVkLCBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB7IGludGVybmFsOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBuZXh0Vmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnBhblNjcm9sbFRpbWVvdXQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBmb3IgcGFuIG9uIHNjcm9sbCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGUgZXZlbnQgY2FsbHMgb24gb3VyIG93blxuICAgICAgICAgKiB3ZSBjYW4ndCB1c2UgdGhlIHN0YXJ0LCB6b29tIGFuZCBlbmQgZXZlbnRzIGZyb20gZDMtem9vbVxuICAgICAgICAgKiBiZWNhdXNlIHN0YXJ0IGFuZCBtb3ZlIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHNjcm9sbCBldmVudCBhbmQgbm90IG9uY2UgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0Py4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudCwgbmV4dFZpZXdwb3J0KTtcbiAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMucGFuU2Nyb2xsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZD8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlWm9vbU9uU2Nyb2xsSGFuZGxlcih7IG5vV2hlZWxDbGFzc05hbWUsIHByZXZlbnRTY3JvbGxpbmcsIGQzWm9vbUhhbmRsZXIgfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIGQpIHtcbiAgICAgICAgY29uc3QgaXNXaGVlbCA9IGV2ZW50LnR5cGUgPT09ICd3aGVlbCc7XG4gICAgICAgIC8vIHdlIHN0aWxsIHdhbnQgdG8gZW5hYmxlIHBpbmNoIHpvb21pbmcgZXZlbiBpZiBwcmV2ZW50U2Nyb2xsaW5nIGlzIHNldCB0byBmYWxzZVxuICAgICAgICBjb25zdCBwcmV2ZW50Wm9vbSA9ICFwcmV2ZW50U2Nyb2xsaW5nICYmIGlzV2hlZWwgJiYgIWV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGNvbnN0IGhhc05vV2hlZWxDbGFzcyA9IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSk7XG4gICAgICAgIC8vIGlmIHVzZXIgaXMgcGluY2ggem9vbWluZyBhYm92ZSBhIG5vd2hlZWwgZWxlbWVudCwgd2UgZG9uJ3Qgd2FudCB0aGUgYnJvd3NlciB0byB6b29tXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIGlzV2hlZWwgJiYgaGFzTm9XaGVlbENsYXNzKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2ZW50Wm9vbSB8fCBoYXNOb1doZWVsQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGQzWm9vbUhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCwgZCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21TdGFydEhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBvbkRyYWdnaW5nQ2hhbmdlLCBvblBhblpvb21TdGFydCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtZW1iZXIgaXQgaGVyZSwgYmVjYXVzZSBpdCdzIGFsd2F5cyAwIGluIHRoZSBcInpvb21cIiBldmVudFxuICAgICAgICB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID0gZXZlbnQuc291cmNlRXZlbnQ/LmJ1dHRvbiB8fCAwO1xuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IHRydWU7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMucHJldlZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8udHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbVN0YXJ0KSB7XG4gICAgICAgICAgICBvblBhblpvb21TdGFydD8uKGV2ZW50LnNvdXJjZUV2ZW50LCB2aWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbUhhbmRsZXIoeyB6b29tUGFuVmFsdWVzLCBwYW5PbkRyYWcsIG9uUGFuZUNvbnRleHRNZW51LCBvblRyYW5zZm9ybUNoYW5nZSwgb25QYW5ab29tLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICB6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uID0gISEob25QYW5lQ29udGV4dE1lbnUgJiYgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA/PyAwKSk7XG4gICAgICAgIGlmICghZXZlbnQuc291cmNlRXZlbnQ/LnN5bmMpIHtcbiAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlKFtldmVudC50cmFuc2Zvcm0ueCwgZXZlbnQudHJhbnNmb3JtLnksIGV2ZW50LnRyYW5zZm9ybS5rXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUGFuWm9vbSAmJiAhZXZlbnQuc291cmNlRXZlbnQ/LmludGVybmFsKSB7XG4gICAgICAgICAgICBvblBhblpvb20/LihldmVudC5zb3VyY2VFdmVudCwgdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIHBhbk9uRHJhZywgcGFuT25TY3JvbGwsIG9uRHJhZ2dpbmdDaGFuZ2UsIG9uUGFuWm9vbUVuZCwgb25QYW5lQ29udGV4dE1lbnUsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB6b29tUGFuVmFsdWVzLmlzWm9vbWluZ09yUGFubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAob25QYW5lQ29udGV4dE1lbnUgJiZcbiAgICAgICAgICAgIGlzUmlnaHRDbGlja1BhbihwYW5PbkRyYWcsIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPz8gMCkgJiZcbiAgICAgICAgICAgICF6b29tUGFuVmFsdWVzLnVzZWRSaWdodE1vdXNlQnV0dG9uICYmXG4gICAgICAgICAgICBldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUoZXZlbnQuc291cmNlRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gPSBmYWxzZTtcbiAgICAgICAgb25EcmFnZ2luZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgIGlmIChvblBhblpvb21FbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdHJhbnNmb3JtVG9WaWV3cG9ydChldmVudC50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnRpbWVySWQpO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kPy4oZXZlbnQuc291cmNlRXZlbnQsIHZpZXdwb3J0KTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gd2UgbmVlZCBhIHNldFRpbWVvdXQgZm9yIHBhbk9uU2Nyb2xsIHRvIHN1cHJlc3MgbXVsdGlwbGUgZW5kIGV2ZW50cyBmaXJlZCBkdXJpbmcgc2Nyb2xsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCA/IDE1MCA6IDApO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsdGVyKHsgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLCB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsLCB6b29tT25Eb3VibGVDbGljaywgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGxpYiwgY29ubmVjdGlvbkluUHJvZ3Jlc3MsIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHpvb21TY3JvbGwgPSB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgfHwgem9vbU9uU2Nyb2xsO1xuICAgICAgICBjb25zdCBwaW5jaFpvb20gPSB6b29tT25QaW5jaCAmJiBldmVudC5jdHJsS2V5O1xuICAgICAgICBjb25zdCBpc1doZWVsRXZlbnQgPSBldmVudC50eXBlID09PSAnd2hlZWwnO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAxICYmXG4gICAgICAgICAgICBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyAmJlxuICAgICAgICAgICAgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgYCR7bGlifS1mbG93X19ub2RlYCkgfHwgaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBgJHtsaWJ9LWZsb3dfX2VkZ2VgKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGFsbCBpbnRlcmFjdGlvbnMgYXJlIGRpc2FibGVkLCB3ZSBwcmV2ZW50IGFsbCB6b29tIGV2ZW50c1xuICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAhem9vbVNjcm9sbCAmJiAhcGFuT25TY3JvbGwgJiYgIXpvb21PbkRvdWJsZUNsaWNrICYmICF6b29tT25QaW5jaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGR1cmluZyBhIHNlbGVjdGlvbiB3ZSBwcmV2ZW50IGFsbCBvdGhlciBpbnRlcmFjdGlvbnNcbiAgICAgICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3YW50IHRvIGRpc2FibGUgcGluY2gtem9vbWluZyB3aGlsZSBtYWtpbmcgYSBjb25uZWN0aW9uXG4gICAgICAgIGlmIChjb25uZWN0aW9uSW5Qcm9ncmVzcyAmJiAhaXNXaGVlbEV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vd2hlZWwgY2xhc3MsIHdlIHByZXZlbnQgem9vbWluZ1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSAmJiBpc1doZWVsRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCB0aGUgbm9wYW4gY2xhc3MsIHdlIHByZXZlbnQgcGFubmluZ1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1BhbkNsYXNzTmFtZSkgJiZcbiAgICAgICAgICAgICghaXNXaGVlbEV2ZW50IHx8IChwYW5PblNjcm9sbCAmJiBpc1doZWVsRXZlbnQgJiYgIXpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6b29tT25QaW5jaCAmJiBldmVudC5jdHJsS2V5ICYmIGlzV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIGV2ZW50LnRvdWNoZXM/Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHlvdSBtYW5hZ2UgdG8gc3RhcnQgd2l0aCAyIHRvdWNoZXMsIHdlIHByZXZlbnQgbmF0aXZlIHpvb21cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHRoZXJlIGlzIG5vIHNjcm9sbCBoYW5kbGluZyBlbmFibGVkLCB3ZSBwcmV2ZW50IGFsbCB3aGVlbCBldmVudHNcbiAgICAgICAgaWYgKCF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhcGluY2hab29tICYmIGlzV2hlZWxFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYW5lIGlzIG5vdCBtb3ZhYmxlLCB3ZSBwcmV2ZW50IGRyYWdnaW5nIGl0IHdpdGggbW91c2VzdGFydCBvciB0b3VjaHN0YXJ0XG4gICAgICAgIGlmICghcGFuT25EcmFnICYmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHBhbmUgaXMgb25seSBtb3ZhYmxlIHVzaW5nIGFsbG93ZWQgY2xpY2tzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgIXBhbk9uRHJhZy5pbmNsdWRlcyhldmVudC5idXR0b24pICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSBhbGxvdyByaWdodCBjbGlja3MgaWYgcGFuIG9uIGRyYWcgaXMgc2V0IHRvIHJpZ2h0IGNsaWNrXG4gICAgICAgIGNvbnN0IGJ1dHRvbkFsbG93ZWQgPSAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcyhldmVudC5idXR0b24pKSB8fCAhZXZlbnQuYnV0dG9uIHx8IGV2ZW50LmJ1dHRvbiA8PSAxO1xuICAgICAgICAvLyBkZWZhdWx0IGZpbHRlciBmb3IgZDMtem9vbVxuICAgICAgICByZXR1cm4gKCFldmVudC5jdHJsS2V5IHx8IGlzV2hlZWxFdmVudCkgJiYgYnV0dG9uQWxsb3dlZDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBYWVBhblpvb20oeyBkb21Ob2RlLCBtaW5ab29tLCBtYXhab29tLCB0cmFuc2xhdGVFeHRlbnQsIHZpZXdwb3J0LCBvblBhblpvb20sIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb21FbmQsIG9uRHJhZ2dpbmdDaGFuZ2UsIH0pIHtcbiAgICBjb25zdCB6b29tUGFuVmFsdWVzID0ge1xuICAgICAgICBpc1pvb21pbmdPclBhbm5pbmc6IGZhbHNlLFxuICAgICAgICB1c2VkUmlnaHRNb3VzZUJ1dHRvbjogZmFsc2UsXG4gICAgICAgIHByZXZWaWV3cG9ydDogeyB4OiAwLCB5OiAwLCB6b29tOiAwIH0sXG4gICAgICAgIG1vdXNlQnV0dG9uOiAwLFxuICAgICAgICB0aW1lcklkOiB1bmRlZmluZWQsXG4gICAgICAgIHBhblNjcm9sbFRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNQYW5TY3JvbGxpbmc6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgYmJveCA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZDNab29tSW5zdGFuY2UgPSB6b29tKCkuc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKS50cmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCBkM1NlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKS5jYWxsKGQzWm9vbUluc3RhbmNlKTtcbiAgICBzZXRWaWV3cG9ydENvbnN0cmFpbmVkKHtcbiAgICAgICAgeDogdmlld3BvcnQueCxcbiAgICAgICAgeTogdmlld3BvcnQueSxcbiAgICAgICAgem9vbTogY2xhbXAodmlld3BvcnQuem9vbSwgbWluWm9vbSwgbWF4Wm9vbSksXG4gICAgfSwgW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFtiYm94LndpZHRoLCBiYm94LmhlaWdodF0sXG4gICAgXSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICBjb25zdCBkM1pvb21IYW5kbGVyID0gZDNTZWxlY3Rpb24ub24oJ3doZWVsLnpvb20nKTtcbiAgICBjb25zdCBkM0RibENsaWNrWm9vbUhhbmRsZXIgPSBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScpO1xuICAgIGQzWm9vbUluc3RhbmNlLndoZWVsRGVsdGEod2hlZWxEZWx0YSk7XG4gICAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKHRyYW5zZm9ybSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5pbnRlcnBvbGF0ZShvcHRpb25zPy5pbnRlcnBvbGF0ZSA9PT0gJ2xpbmVhcicgPyBpbnRlcnBvbGF0ZSA6IGludGVycG9sYXRlWm9vbSkudHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sIG9wdGlvbnM/LmVhc2UsICgpID0+IHJlc29sdmUodHJ1ZSkpLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25QYW5lQ29udGV4dE1lbnUsIHVzZXJTZWxlY3Rpb25BY3RpdmUsIHBhbk9uU2Nyb2xsLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgcHJldmVudFNjcm9sbGluZywgem9vbU9uUGluY2gsIHpvb21PblNjcm9sbCwgem9vbU9uRG91YmxlQ2xpY2ssIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgbGliLCBvblRyYW5zZm9ybUNoYW5nZSwgY29ubmVjdGlvbkluUHJvZ3Jlc3MsIHBhbmVDbGlja0Rpc3RhbmNlLCBzZWxlY3Rpb25PbkRyYWcsIH0pIHtcbiAgICAgICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUgJiYgIXpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nKSB7XG4gICAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNQYW5PblNjcm9sbCA9IHBhbk9uU2Nyb2xsICYmICF6b29tQWN0aXZhdGlvbktleVByZXNzZWQgJiYgIXVzZXJTZWxlY3Rpb25BY3RpdmU7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLmNsaWNrRGlzdGFuY2Uoc2VsZWN0aW9uT25EcmFnID8gSW5maW5pdHkgOiAhaXNOdW1lcmljKHBhbmVDbGlja0Rpc3RhbmNlKSB8fCBwYW5lQ2xpY2tEaXN0YW5jZSA8IDAgPyAwIDogcGFuZUNsaWNrRGlzdGFuY2UpO1xuICAgICAgICBjb25zdCB3aGVlbEhhbmRsZXIgPSBpc1Bhbk9uU2Nyb2xsXG4gICAgICAgICAgICA/IGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGQzU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGQzWm9vbTogZDNab29tSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGxNb2RlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGNyZWF0ZVpvb21PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgICAgICBkM1pvb21IYW5kbGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJywgd2hlZWxIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICBpZiAoIXVzZXJTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIHN0YXJ0XG4gICAgICAgICAgICBjb25zdCBzdGFydEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tU3RhcnRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICB6b29tUGFuVmFsdWVzLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tU3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdzdGFydCcsIHN0YXJ0SGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbVxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUhhbmRsZXIgPSBjcmVhdGVQYW5ab29tSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnU6ICEhb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tLFxuICAgICAgICAgICAgICAgIG9uVHJhbnNmb3JtQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignem9vbScsIHBhblpvb21IYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIHBhbiB6b29tIGVuZFxuICAgICAgICAgICAgY29uc3QgcGFuWm9vbUVuZEhhbmRsZXIgPSBjcmVhdGVQYW5ab29tRW5kSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kLFxuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdDaGFuZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCdlbmQnLCBwYW5ab29tRW5kSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyID0gY3JlYXRlRmlsdGVyKHtcbiAgICAgICAgICAgIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCxcbiAgICAgICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgICAgIHpvb21PblNjcm9sbCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBjb25uZWN0aW9uSW5Qcm9ncmVzcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBjYW5ub3QgYWRkIHpvb21PbkRvdWJsZUNsaWNrIHRvIHRoZSBmaWx0ZXIgYWJvdmUgYmVjYXVzZVxuICAgICAgICAgKiBkb3VibGUgdGFwcGluZyBvbiB0b3VjaCBzY3JlZW5zIGNpcmN1bXZlbnRzIHRoZSBmaWx0ZXIgYW5kXG4gICAgICAgICAqIGRibGNsaWNrLnpvb20gaXMgZmlyZWQgb24gdGhlIHNlbGVjdGlvbiBkaXJlY3RseVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHpvb21PbkRvdWJsZUNsaWNrKSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIGQzRGJsQ2xpY2tab29tSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkM1NlbGVjdGlvbi5vbignZGJsY2xpY2suem9vbScsIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlLm9uKCd6b29tJywgbnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldFZpZXdwb3J0Q29uc3RyYWluZWQodmlld3BvcnQsIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgY29uc3QgY29udHJhaW5lZFRyYW5zZm9ybSA9IGQzWm9vbUluc3RhbmNlPy5jb25zdHJhaW4oKShuZXh0VHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIGlmIChjb250cmFpbmVkVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0oY29udHJhaW5lZFRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKGNvbnRyYWluZWRUcmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2V0Vmlld3BvcnQodmlld3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICBhd2FpdCBzZXRUcmFuc2Zvcm0obmV4dFRyYW5zZm9ybSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShuZXh0VHJhbnNmb3JtKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN5bmNWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFuc2Zvcm0gPSB2aWV3cG9ydFRvVHJhbnNmb3JtKHZpZXdwb3J0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRyYW5zZm9ybS5rICE9PSB2aWV3cG9ydC56b29tIHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS54ICE9PSB2aWV3cG9ydC54IHx8XG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zZm9ybS55ICE9PSB2aWV3cG9ydC55KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNmb3JtKGQzU2VsZWN0aW9uLCBuZXh0VHJhbnNmb3JtLCBudWxsLCB7IHN5bmM6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vmlld3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGQzU2VsZWN0aW9uID8gem9vbVRyYW5zZm9ybShkM1NlbGVjdGlvbi5ub2RlKCkpIDogeyB4OiAwLCB5OiAwLCBrOiAxIH07XG4gICAgICAgIHJldHVybiB7IHg6IHRyYW5zZm9ybS54LCB5OiB0cmFuc2Zvcm0ueSwgem9vbTogdHJhbnNmb3JtLmsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUbyh6b29tLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgZDNab29tSW5zdGFuY2U/LmludGVycG9sYXRlKG9wdGlvbnM/LmludGVycG9sYXRlID09PSAnbGluZWFyJyA/IGludGVycG9sYXRlIDogaW50ZXJwb2xhdGVab29tKS5zY2FsZVRvKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sIG9wdGlvbnM/LmVhc2UsICgpID0+IHJlc29sdmUodHJ1ZSkpLCB6b29tKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZUJ5KGZhY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy5pbnRlcnBvbGF0ZShvcHRpb25zPy5pbnRlcnBvbGF0ZSA9PT0gJ2xpbmVhcicgPyBpbnRlcnBvbGF0ZSA6IGludGVycG9sYXRlWm9vbSkuc2NhbGVCeShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCBvcHRpb25zPy5lYXNlLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgZmFjdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRTY2FsZUV4dGVudChzY2FsZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8uc2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlPy50cmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q2xpY2tEaXN0YW5jZShkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCB2YWxpZERpc3RhbmNlID0gIWlzTnVtZXJpYyhkaXN0YW5jZSkgfHwgZGlzdGFuY2UgPCAwID8gMCA6IGRpc3RhbmNlO1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8uY2xpY2tEaXN0YW5jZSh2YWxpZERpc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgICAgICBzZXRWaWV3cG9ydCxcbiAgICAgICAgc2V0Vmlld3BvcnRDb25zdHJhaW5lZCxcbiAgICAgICAgZ2V0Vmlld3BvcnQsXG4gICAgICAgIHNjYWxlVG8sXG4gICAgICAgIHNjYWxlQnksXG4gICAgICAgIHNldFNjYWxlRXh0ZW50LFxuICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQsXG4gICAgICAgIHN5bmNWaWV3cG9ydCxcbiAgICAgICAgc2V0Q2xpY2tEaXN0YW5jZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB2YXJpYW50IG9mIHRoZSByZXNpemUgY29udHJvbFxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlc2l6ZUNvbnRyb2xWYXJpYW50O1xuKGZ1bmN0aW9uIChSZXNpemVDb250cm9sVmFyaWFudCkge1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiTGluZVwiXSA9IFwibGluZVwiO1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiSGFuZGxlXCJdID0gXCJoYW5kbGVcIjtcbn0pKFJlc2l6ZUNvbnRyb2xWYXJpYW50IHx8IChSZXNpemVDb250cm9sVmFyaWFudCA9IHt9KSk7XG5jb25zdCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMgPSBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXTtcbmNvbnN0IFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuXG4vKipcbiAqIEdldCBhbGwgY29ubmVjdGluZyBlZGdlcyBmb3IgYSBnaXZlbiBzZXQgb2Ygbm9kZXNcbiAqIEBwYXJhbSB3aWR0aCAtIG5ldyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZXaWR0aCAtIHByZXZpb3VzIHdpZHRoIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gbmV3IGhlaWdodCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZIZWlnaHQgLSBwcmV2aW91cyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBhZmZlY3RzWCAtIHdoZXRoZXIgdG8gaW52ZXJ0IHRoZSByZXNpemUgZGlyZWN0aW9uIGZvciB0aGUgeCBheGlzXG4gKiBAcGFyYW0gYWZmZWN0c1kgLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHkgYXhpc1xuICogQHJldHVybnMgYXJyYXkgb2YgdHdvIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJlc2l6ZSBmb3IgZWFjaCBheGlzLCAwID0gbm8gY2hhbmdlLCAxID0gaW5jcmVhc2UsIC0xID0gZGVjcmVhc2VcbiAqL1xuZnVuY3Rpb24gZ2V0UmVzaXplRGlyZWN0aW9uKHsgd2lkdGgsIHByZXZXaWR0aCwgaGVpZ2h0LCBwcmV2SGVpZ2h0LCBhZmZlY3RzWCwgYWZmZWN0c1ksIH0pIHtcbiAgICBjb25zdCBkZWx0YVdpZHRoID0gd2lkdGggLSBwcmV2V2lkdGg7XG4gICAgY29uc3QgZGVsdGFIZWlnaHQgPSBoZWlnaHQgLSBwcmV2SGVpZ2h0O1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IFtkZWx0YVdpZHRoID4gMCA/IDEgOiBkZWx0YVdpZHRoIDwgMCA/IC0xIDogMCwgZGVsdGFIZWlnaHQgPiAwID8gMSA6IGRlbHRhSGVpZ2h0IDwgMCA/IC0xIDogMF07XG4gICAgaWYgKGRlbHRhV2lkdGggJiYgYWZmZWN0c1gpIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gZGlyZWN0aW9uWzBdICogLTE7XG4gICAgfVxuICAgIGlmIChkZWx0YUhlaWdodCAmJiBhZmZlY3RzWSkge1xuICAgICAgICBkaXJlY3Rpb25bMV0gPSBkaXJlY3Rpb25bMV0gKiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBjb250cm9sIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZCB0byBkaW1lbnNpb25zIHRoYXQgYXJlIGJlaW5nIHJlc2l6ZWRcbiAqIEBwYXJhbSBjb250cm9sUG9zaXRpb24gLSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCB0aGF0IGlzIGJlaW5nIGRyYWdnZWRcbiAqIEByZXR1cm5zIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCwgYWZmZWN0c1gsIGFmZmVjdHNZLFxuICovXG5mdW5jdGlvbiBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbikge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygncmlnaHQnKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ2xlZnQnKTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdib3R0b20nKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIGNvbnN0IGFmZmVjdHNYID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgYWZmZWN0c1kgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzSG9yaXpvbnRhbCxcbiAgICAgICAgaXNWZXJ0aWNhbCxcbiAgICAgICAgYWZmZWN0c1gsXG4gICAgICAgIGFmZmVjdHNZLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRMb3dlckV4dGVudENsYW1wKGxvd2VyRXh0ZW50LCBsb3dlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGxvd2VyQm91bmQgLSBsb3dlckV4dGVudCk7XG59XG5mdW5jdGlvbiBnZXRVcHBlckV4dGVudENsYW1wKHVwcGVyRXh0ZW50LCB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHVwcGVyRXh0ZW50IC0gdXBwZXJCb3VuZCk7XG59XG5mdW5jdGlvbiBnZXRTaXplQ2xhbXAoc2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBtaW5TaXplIC0gc2l6ZSwgc2l6ZSAtIG1heFNpemUpO1xufVxuZnVuY3Rpb24geG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/ICFiIDogYjtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBuZXcgd2lkdGggJiBoZWlnaHQgYW5kIHggJiB5IG9mIG5vZGUgYWZ0ZXIgcmVzaXplIGJhc2VkIG9uIHBvaW50ZXIgcG9zaXRpb25cbiAqIEBkZXNjcmlwdGlvbiAtIEJ1Y2tsZSB1cCwgdGhpcyBpcyBhIGNodW5reSBvbmUuLi4gSWYgeW91IHdhbnQgdG8gZGV0ZXJtaW5lIHRoZSBuZXcgZGltZW5zaW9ucyBvZiBhIG5vZGUgYWZ0ZXIgYSByZXNpemUsXG4gKiB5b3UgaGF2ZSB0byBhY2NvdW50IGZvciBhbGwgcG9zc2libGUgcmVzdHJpY3Rpb25zOiBtaW4vbWF4IHdpZHRoL2hlaWdodCBvZiB0aGUgbm9kZSwgdGhlIG1heGltdW0gZXh0ZW50IHRoZSBub2RlIGlzIGFsbG93ZWRcbiAqIHRvIG1vdmUgaW4gKGluIHRoaXMgY2FzZTogcmVzaXplIGludG8pIGRldGVybWluZWQgYnkgdGhlIHBhcmVudCBub2RlLCB0aGUgbWluaW1hbCBleHRlbnQgZGV0ZXJtaW5lZCBieSBjaGlsZCBub2Rlc1xuICogd2l0aCBleHBhbmRQYXJlbnQgb3IgZXh0ZW50OiAncGFyZW50JyBzZXQgYW5kIG9oIHllYWgsIHRoZXNlIHRoaW5ncyBhbHNvIGhhdmUgdG8gd29yayB3aXRoIGtlZXBBc3BlY3RSYXRpbyFcbiAqIFRoZSB3YXkgdGhpcyBpcyBkb25lIGlzIGJ5IGRldGVybWluaW5nIGhvdyBtdWNoIGVhY2ggb2YgdGhlc2UgcmVzdHJpY3RpbmcgYWN0dWFsbHkgcmVzdHJpY3RzIHRoZSByZXNpemUgYW5kIHRoZW4gYXBwbHlpbmcgdGhlXG4gKiBzdHJvbmdlc3QgcmVzdHJpY3Rpb24uIEJlY2F1c2UgdGhlIHJlc2l6ZSBhZmZlY3RzIHgsIHkgYW5kIHdpZHRoLCBoZWlnaHQgYW5kIHdpZHRoLCBoZWlnaHQgb2YgYSBvcHBvc2luZyBzaWRlIHdpdGgga2VlcEFzcGVjdFJhdGlvLFxuICogdGhlIHJlc2l6ZSBhbW91bnQgaXMgYWx3YXlzIGtlcHQgaW4gZGlzdFggJiBkaXN0WSBhbW91bnQgKHRoZSBkaXN0YW5jZSBpbiBtb3VzZSBtb3ZlbWVudClcbiAqIEluc3RlYWQgb2YgY2xhbXBpbmcgZWFjaCB2YWx1ZSwgd2UgZmlyc3QgY2FsY3VsYXRlIHRoZSBiaWdnZXN0ICdjbGFtcCcgKGZvciB0aGUgbGFjayBvZiBhIGJldHRlciBuYW1lKSBhbmQgdGhlbiBhcHBseSBpdCB0byBhbGwgdmFsdWVzLlxuICogVG8gY29tcGxpY2F0ZSB0aGluZ3Mgbm9kZU9yaWdpbiBoYXMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50IGFzIHdlbGwuIFRoaXMgaXMgZG9uZSBieSBvZmZzZXR0aW5nIHRoZSBub2RlcyBhcyBpZiB0aGVpciBvcmlnaW4gaXMgWzAsIDBdLFxuICogdGhlbiBjYWxjdWxhdGluZyB0aGUgcmVzdHJpY3Rpb25zIGFzIHVzdWFsXG4gKiBAcGFyYW0gc3RhcnRWYWx1ZXMgLSBzdGFydGluZyB2YWx1ZXMgb2YgcmVzaXplXG4gKiBAcGFyYW0gY29udHJvbERpcmVjdGlvbiAtIGRpbWVuc2lvbnMgYWZmZWN0ZWQgYnkgdGhlIHJlc2l6ZVxuICogQHBhcmFtIHBvaW50ZXJQb3NpdGlvbiAtIHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gY29ycmVjdGVkIGZvciBzbmFwcGluZ1xuICogQHBhcmFtIGJvdW5kYXJpZXMgLSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRpbWVuc2lvbnMgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBrZWVwQXNwZWN0UmF0aW8gLSBwcmV2ZW50IGNoYW5nZXMgb2YgYXNwcmVjdCByYXRpb1xuICogQHJldHVybnMgeCwgeSwgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbm9kZSBhZnRlciByZXNpemVcbiAqL1xuZnVuY3Rpb24gZ2V0RGltZW5zaW9uc0FmdGVyUmVzaXplKHN0YXJ0VmFsdWVzLCBjb250cm9sRGlyZWN0aW9uLCBwb2ludGVyUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgbm9kZU9yaWdpbiwgZXh0ZW50LCBjaGlsZEV4dGVudCkge1xuICAgIGxldCB7IGFmZmVjdHNYLCBhZmZlY3RzWSB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCB7IGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCBpc0RpYWdvbmFsID0gaXNIb3Jpem9udGFsICYmIGlzVmVydGljYWw7XG4gICAgY29uc3QgeyB4U25hcHBlZCwgeVNuYXBwZWQgfSA9IHBvaW50ZXJQb3NpdGlvbjtcbiAgICBjb25zdCB7IG1pbldpZHRoLCBtYXhXaWR0aCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQgfSA9IGJvdW5kYXJpZXM7XG4gICAgY29uc3QgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgd2lkdGg6IHN0YXJ0V2lkdGgsIGhlaWdodDogc3RhcnRIZWlnaHQsIGFzcGVjdFJhdGlvIH0gPSBzdGFydFZhbHVlcztcbiAgICBsZXQgZGlzdFggPSBNYXRoLmZsb29yKGlzSG9yaXpvbnRhbCA/IHhTbmFwcGVkIC0gc3RhcnRWYWx1ZXMucG9pbnRlclggOiAwKTtcbiAgICBsZXQgZGlzdFkgPSBNYXRoLmZsb29yKGlzVmVydGljYWwgPyB5U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJZIDogMCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBzdGFydFdpZHRoICsgKGFmZmVjdHNYID8gLWRpc3RYIDogZGlzdFgpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHN0YXJ0SGVpZ2h0ICsgKGFmZmVjdHNZID8gLWRpc3RZIDogZGlzdFkpO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSAtbm9kZU9yaWdpblswXSAqIHN0YXJ0V2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IC1ub2RlT3JpZ2luWzFdICogc3RhcnRIZWlnaHQ7XG4gICAgLy8gQ2hlY2sgaWYgbWF4V2lkdGgsIG1pbldXaWR0aCwgbWF4SGVpZ2h0LCBtaW5IZWlnaHQgYXJlIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBsZXQgY2xhbXBYID0gZ2V0U2l6ZUNsYW1wKG5ld1dpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgpO1xuICAgIGxldCBjbGFtcFkgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0LCBtaW5IZWlnaHQsIG1heEhlaWdodCk7XG4gICAgLy8gQ2hlY2sgaWYgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBkaXN0WSArIG9yaWdpbk9mZnNldFksIGV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZID4gMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgbGV0IHhFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGxldCB5RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBpZiAoYWZmZWN0c1ggJiYgZGlzdFggPiAwKSB7XG4gICAgICAgICAgICB4RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIGRpc3RYLCBjaGlsZEV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCwgY2hpbGRFeHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFksIGNoaWxkRXh0ZW50WzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWZmZWN0c1kgJiYgZGlzdFkgPCAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld0hlaWdodCwgY2hpbGRFeHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgYXNwZWN0IHJhdGlvIHJlc2l6aW5nIG9mIHRoZSBvdGhlciBzaWRlIGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBtYXggZGltZW5zaW9ucyBtaWdodCBiZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBjb25zdCBhc3BlY3RIZWlnaHRDbGFtcCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBtaW5IZWlnaHQsIG1heEhlaWdodCkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0SGVpZ2h0Q2xhbXApO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgbmV3V2lkdGggLyBhc3BlY3RSYXRpbywgZXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGV4dGVudFswXVsxXSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGlsZCBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyAoYWZmZWN0c1ggPyBkaXN0WCA6IC1kaXN0WCkgLyBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMV0pICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvIHRoZSBzYW1lIHRoaW5nIGZvciB2ZXJ0aWNhbCByZXNpemluZ1xuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgY29uc3QgYXNwZWN0V2lkdGhDbGFtcCA9IGdldFNpemVDbGFtcChuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgbWluV2lkdGgsIG1heFdpZHRoKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RXaWR0aENsYW1wKTtcbiAgICAgICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvICsgb3JpZ2luT2Zmc2V0WCwgZXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1kgJiYgIWFmZmVjdHNYICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMV1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIChhZmZlY3RzWSA/IGRpc3RZIDogLWRpc3RZKSAqIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFswXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzdFkgPSBkaXN0WSArIChkaXN0WSA8IDAgPyBjbGFtcFkgOiAtY2xhbXBZKTtcbiAgICBkaXN0WCA9IGRpc3RYICsgKGRpc3RYIDwgMCA/IGNsYW1wWCA6IC1jbGFtcFgpO1xuICAgIGlmIChrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKGlzRGlhZ29uYWwpIHtcbiAgICAgICAgICAgIGlmIChuZXdXaWR0aCA+IG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSAoeG9yKGFmZmVjdHNYLCBhZmZlY3RzWSkgPyAtZGlzdFggOiBkaXN0WCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RYID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RZIDogZGlzdFkpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSBkaXN0WCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNZID0gYWZmZWN0c1g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9IGRpc3RZICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgYWZmZWN0c1ggPSBhZmZlY3RzWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4ID0gYWZmZWN0c1ggPyBzdGFydFggKyBkaXN0WCA6IHN0YXJ0WDtcbiAgICBjb25zdCB5ID0gYWZmZWN0c1kgPyBzdGFydFkgKyBkaXN0WSA6IHN0YXJ0WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKSxcbiAgICAgICAgaGVpZ2h0OiBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKSxcbiAgICAgICAgeDogbm9kZU9yaWdpblswXSAqIGRpc3RYICogKCFhZmZlY3RzWCA/IDEgOiAtMSkgKyB4LFxuICAgICAgICB5OiBub2RlT3JpZ2luWzFdICogZGlzdFkgKiAoIWFmZmVjdHNZID8gMSA6IC0xKSArIHksXG4gICAgfTtcbn1cblxuY29uc3QgaW5pdFByZXZWYWx1ZXMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHg6IDAsIHk6IDAgfTtcbmNvbnN0IGluaXRTdGFydFZhbHVlcyA9IHtcbiAgICAuLi5pbml0UHJldlZhbHVlcyxcbiAgICBwb2ludGVyWDogMCxcbiAgICBwb2ludGVyWTogMCxcbiAgICBhc3BlY3RSYXRpbzogMSxcbn07XG5mdW5jdGlvbiBub2RlVG9QYXJlbnRFeHRlbnQobm9kZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW25vZGUubWVhc3VyZWQud2lkdGgsIG5vZGUubWVhc3VyZWQuaGVpZ2h0XSxcbiAgICBdO1xufVxuZnVuY3Rpb24gbm9kZVRvQ2hpbGRFeHRlbnQoY2hpbGQsIHBhcmVudCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHggPSBwYXJlbnQucG9zaXRpb24ueCArIGNoaWxkLnBvc2l0aW9uLng7XG4gICAgY29uc3QgeSA9IHBhcmVudC5wb3NpdGlvbi55ICsgY2hpbGQucG9zaXRpb24ueTtcbiAgICBjb25zdCB3aWR0aCA9IGNoaWxkLm1lYXN1cmVkLndpZHRoID8/IDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2hpbGQubWVhc3VyZWQuaGVpZ2h0ID8/IDA7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WCA9IG5vZGVPcmlnaW5bMF0gKiB3aWR0aDtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRZID0gbm9kZU9yaWdpblsxXSAqIGhlaWdodDtcbiAgICByZXR1cm4gW1xuICAgICAgICBbeCAtIG9yaWdpbk9mZnNldFgsIHkgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICAgICAgW3ggKyB3aWR0aCAtIG9yaWdpbk9mZnNldFgsIHkgKyBoZWlnaHQgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gWFlSZXNpemVyKHsgZG9tTm9kZSwgbm9kZUlkLCBnZXRTdG9yZUl0ZW1zLCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBsZXQgcGFyYW1zID0ge1xuICAgICAgICBjb250cm9sRGlyZWN0aW9uOiBnZXRDb250cm9sRGlyZWN0aW9uKCdib3R0b20tcmlnaHQnKSxcbiAgICAgICAgYm91bmRhcmllczoge1xuICAgICAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IDAsXG4gICAgICAgICAgICBtYXhXaWR0aDogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIG1heEhlaWdodDogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVzaXplRGlyZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGtlZXBBc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgfTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBjb250cm9sUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgcmVzaXplRGlyZWN0aW9uLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIHNob3VsZFJlc2l6ZSwgfSkge1xuICAgICAgICBsZXQgcHJldlZhbHVlcyA9IHsgLi4uaW5pdFByZXZWYWx1ZXMgfTtcbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzID0geyAuLi5pbml0U3RhcnRWYWx1ZXMgfTtcbiAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgYm91bmRhcmllcyxcbiAgICAgICAgICAgIHJlc2l6ZURpcmVjdGlvbixcbiAgICAgICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIGNvbnRyb2xEaXJlY3Rpb246IGdldENvbnRyb2xEaXJlY3Rpb24oY29udHJvbFBvc2l0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb250YWluZXJCb3VuZHMgPSBudWxsO1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IHVuZGVmaW5lZDsgLy8gTmVlZGVkIHRvIGZpeCBleHBhbmRQYXJlbnRcbiAgICAgICAgbGV0IHBhcmVudEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNoaWxkRXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gdHJpZ2dlciBvblJlc2l6ZUVuZCBpZiBvblJlc2l6ZSB3YXMgYWN0dWFsbHkgY2FsbGVkXG4gICAgICAgIGxldCByZXNpemVEZXRlY3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBkcmFnSGFuZGxlciA9IGRyYWcoKVxuICAgICAgICAgICAgLm9uKCdzdGFydCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luLCBwYW5lRG9tTm9kZSB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXJCb3VuZHMgPSBwYW5lRG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgPz8gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgeFNuYXBwZWQsIHlTbmFwcGVkIH0gPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc25hcEdyaWQsXG4gICAgICAgICAgICAgICAgc25hcFRvR3JpZCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJCb3VuZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByZXZWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54ID8/IDAsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55ID8/IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucHJldlZhbHVlcyxcbiAgICAgICAgICAgICAgICBwb2ludGVyWDogeFNuYXBwZWQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclk6IHlTbmFwcGVkLFxuICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBwcmV2VmFsdWVzLndpZHRoIC8gcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudElkICYmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgbm9kZS5leHBhbmRQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudEV4dGVudCA9IHBhcmVudE5vZGUgJiYgbm9kZS5leHRlbnQgPT09ICdwYXJlbnQnID8gbm9kZVRvUGFyZW50RXh0ZW50KHBhcmVudE5vZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIENvbGxlY3QgYWxsIGNoaWxkIG5vZGVzIHRvIGNvcnJlY3QgdGhlaXIgcmVsYXRpdmUgcG9zaXRpb25zIHdoZW4gdG9wL2xlZnQgY2hhbmdlc1xuICAgICAgICAgICAgICogRGV0ZXJtaW5lIGxhcmdlc3QgbWluaW1hbCBleHRlbnQgdGhlIHBhcmVudCBub2RlIGlzIGFsbG93ZWQgdG8gcmVzaXplIHRvXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGNoaWxkRXh0ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2hpbGRJZCwgY2hpbGRdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50SWQgPT09IG5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyAuLi5jaGlsZC5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50OiBjaGlsZC5leHRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZXh0ZW50ID09PSAncGFyZW50JyB8fCBjaGlsZC5leHBhbmRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IG5vZGVUb0NoaWxkRXh0ZW50KGNoaWxkLCBub2RlLCBjaGlsZC5vcmlnaW4gPz8gbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW01hdGgubWluKGV4dGVudFswXVswXSwgY2hpbGRFeHRlbnRbMF1bMF0pLCBNYXRoLm1pbihleHRlbnRbMF1bMV0sIGNoaWxkRXh0ZW50WzBdWzFdKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1heChleHRlbnRbMV1bMF0sIGNoaWxkRXh0ZW50WzFdWzBdKSwgTWF0aC5tYXgoZXh0ZW50WzFdWzFdLCBjaGlsZEV4dGVudFsxXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEV4dGVudCA9IGV4dGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uUmVzaXplU3RhcnQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdkcmFnJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVPcmlnaW46IHN0b3JlTm9kZU9yaWdpbiB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlclBvc2l0aW9uID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgeDogcHJldlgsIHk6IHByZXZZLCB3aWR0aDogcHJldldpZHRoLCBoZWlnaHQ6IHByZXZIZWlnaHQgfSA9IHByZXZWYWx1ZXM7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVPcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBzdG9yZU5vZGVPcmlnaW47XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfSA9IGdldERpbWVuc2lvbnNBZnRlclJlc2l6ZShzdGFydFZhbHVlcywgcGFyYW1zLmNvbnRyb2xEaXJlY3Rpb24sIHBvaW50ZXJQb3NpdGlvbiwgcGFyYW1zLmJvdW5kYXJpZXMsIHBhcmFtcy5rZWVwQXNwZWN0UmF0aW8sIG5vZGVPcmlnaW4sIHBhcmVudEV4dGVudCwgY2hpbGRFeHRlbnQpO1xuICAgICAgICAgICAgY29uc3QgaXNXaWR0aENoYW5nZSA9IHdpZHRoICE9PSBwcmV2V2lkdGg7XG4gICAgICAgICAgICBjb25zdCBpc0hlaWdodENoYW5nZSA9IGhlaWdodCAhPT0gcHJldkhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGlzWFBvc0NoYW5nZSA9IHggIT09IHByZXZYICYmIGlzV2lkdGhDaGFuZ2U7XG4gICAgICAgICAgICBjb25zdCBpc1lQb3NDaGFuZ2UgPSB5ICE9PSBwcmV2WSAmJiBpc0hlaWdodENoYW5nZTtcbiAgICAgICAgICAgIGlmICghaXNYUG9zQ2hhbmdlICYmICFpc1lQb3NDaGFuZ2UgJiYgIWlzV2lkdGhDaGFuZ2UgJiYgIWlzSGVpZ2h0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzWFBvc0NoYW5nZSB8fCBpc1lQb3NDaGFuZ2UgfHwgbm9kZU9yaWdpblswXSA9PT0gMSB8fCBub2RlT3JpZ2luWzFdID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlLnggPSBpc1hQb3NDaGFuZ2UgPyB4IDogcHJldlZhbHVlcy54O1xuICAgICAgICAgICAgICAgIGNoYW5nZS55ID0gaXNZUG9zQ2hhbmdlID8geSA6IHByZXZWYWx1ZXMueTtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnggPSBjaGFuZ2UueDtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnkgPSBjaGFuZ2UueTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIHdoZW4gdG9wL2xlZnQgY2hhbmdlcywgY29ycmVjdCB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIG9mIGNoaWxkIG5vZGVzXG4gICAgICAgICAgICAgICAgICogc28gdGhhdCB0aGV5IHN0YXkgaW4gdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhDaGFuZ2UgPSB4IC0gcHJldlg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHlDaGFuZ2UgPSB5IC0gcHJldlk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGlsZE5vZGUucG9zaXRpb24ueCAtIHhDaGFuZ2UgKyBub2RlT3JpZ2luWzBdICogKHdpZHRoIC0gcHJldldpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBjaGlsZE5vZGUucG9zaXRpb24ueSAtIHlDaGFuZ2UgKyBub2RlT3JpZ2luWzFdICogKGhlaWdodCAtIHByZXZIZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkQ2hhbmdlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNXaWR0aENoYW5nZSB8fCBpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIGlzV2lkdGhDaGFuZ2UgJiYgKCFwYXJhbXMucmVzaXplRGlyZWN0aW9uIHx8IHBhcmFtcy5yZXNpemVEaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJldlZhbHVlcy53aWR0aDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaGVpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgaXNIZWlnaHRDaGFuZ2UgJiYgKCFwYXJhbXMucmVzaXplRGlyZWN0aW9uIHx8IHBhcmFtcy5yZXNpemVEaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwcmV2VmFsdWVzLmhlaWdodDtcbiAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLndpZHRoID0gY2hhbmdlLndpZHRoO1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMuaGVpZ2h0ID0gY2hhbmdlLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpeCBleHBhbmRQYXJlbnQgd2hlbiByZXNpemluZyBmcm9tIHRvcC9sZWZ0XG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBub2RlLmV4cGFuZFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHhMaW1pdCA9IG5vZGVPcmlnaW5bMF0gKiAoY2hhbmdlLndpZHRoID8/IDApO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UueCAmJiBjaGFuZ2UueCA8IHhMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnggPSB4TGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWVzLnggPSBzdGFydFZhbHVlcy54IC0gKGNoYW5nZS54IC0geExpbWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeUxpbWl0ID0gbm9kZU9yaWdpblsxXSAqIChjaGFuZ2UuaGVpZ2h0ID8/IDApO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UueSAmJiBjaGFuZ2UueSA8IHlMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2VmFsdWVzLnkgPSB5TGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWVzLnkgPSBzdGFydFZhbHVlcy55IC0gKGNoYW5nZS55IC0geUxpbWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBnZXRSZXNpemVEaXJlY3Rpb24oe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcmV2VmFsdWVzLndpZHRoLFxuICAgICAgICAgICAgICAgIHByZXZXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHByZXZWYWx1ZXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHByZXZIZWlnaHQsXG4gICAgICAgICAgICAgICAgYWZmZWN0c1g6IHBhcmFtcy5jb250cm9sRGlyZWN0aW9uLmFmZmVjdHNYLFxuICAgICAgICAgICAgICAgIGFmZmVjdHNZOiBwYXJhbXMuY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlcyA9IHsgLi4ucHJldlZhbHVlcywgZGlyZWN0aW9uIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsUmVzaXplID0gc2hvdWxkUmVzaXplPy4oZXZlbnQsIG5leHRWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzaXplRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgb25SZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2UsIGNoaWxkQ2hhbmdlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNpemVEZXRlY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uUmVzaXplRW5kPy4oZXZlbnQsIHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgICAgIG9uRW5kPy4oeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgcmVzaXplRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGVjdGlvbi5jYWxsKGRyYWdIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgc2VsZWN0aW9uLm9uKCcuZHJhZycsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgQ29ubmVjdGlvbkxpbmVUeXBlLCBDb25uZWN0aW9uTW9kZSwgTWFya2VyVHlwZSwgUGFuT25TY3JvbGxNb2RlLCBQb3NpdGlvbiwgUmVzaXplQ29udHJvbFZhcmlhbnQsIFNlbGVjdGlvbk1vZGUsIFhZRHJhZywgWFlIYW5kbGUsIFhZTWluaW1hcCwgWFlQYW5ab29tLCBYWVJlc2l6ZXIsIFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUywgWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUywgYWRkRWRnZSwgYWRvcHRVc2VyTm9kZXMsIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwsIGFyZVNldHNFcXVhbCwgYm94VG9SZWN0LCBjYWxjQXV0b1BhbiwgY2FsY3VsYXRlTm9kZVBvc2l0aW9uLCBjbGFtcCwgY2xhbXBQb3NpdGlvbiwgY2xhbXBQb3NpdGlvblRvUGFyZW50LCBjcmVhdGVNYXJrZXJJZHMsIGRlZmF1bHRBcmlhTGFiZWxDb25maWcsIGRldldhcm4sIGVsZW1lbnRTZWxlY3Rpb25LZXlzLCBlcnJvck1lc3NhZ2VzLCBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24sIGZpdFZpZXdwb3J0LCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRCZXppZXJQYXRoLCBnZXRCb3VuZHNPZkJveGVzLCBnZXRCb3VuZHNPZlJlY3RzLCBnZXRDb25uZWN0ZWRFZGdlcywgZ2V0Q29ubmVjdGlvblN0YXR1cywgZ2V0RGltZW5zaW9ucywgZ2V0RWRnZUNlbnRlciwgZ2V0RWRnZUlkLCBnZXRFZGdlUG9zaXRpb24sIGdldEVkZ2VUb29sYmFyVHJhbnNmb3JtLCBnZXRFbGVtZW50c1RvUmVtb3ZlLCBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgsIGdldEV2ZW50UG9zaXRpb24sIGdldEhhbmRsZUJvdW5kcywgZ2V0SGFuZGxlUG9zaXRpb24sIGdldEhvc3RGb3JFbGVtZW50LCBnZXRJbmNvbWVycywgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgZ2V0TWFya2VySWQsIGdldE5vZGVEaW1lbnNpb25zLCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSwgZ2V0Tm9kZXNCb3VuZHMsIGdldE5vZGVzSW5zaWRlLCBnZXRPdXRnb2VycywgZ2V0T3ZlcmxhcHBpbmdBcmVhLCBnZXRQb2ludGVyUG9zaXRpb24sIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBoYW5kbGVFeHBhbmRQYXJlbnQsIGluZmluaXRlRXh0ZW50LCBpbml0aWFsQ29ubmVjdGlvbiwgaXNDb29yZGluYXRlRXh0ZW50LCBpc0VkZ2VCYXNlLCBpc0VkZ2VWaXNpYmxlLCBpc0lucHV0RE9NTm9kZSwgaXNJbnRlcm5hbE5vZGVCYXNlLCBpc01hY09zLCBpc01hbnVhbFpJbmRleE1vZGUsIGlzTW91c2VFdmVudCwgaXNOb2RlQmFzZSwgaXNOdW1lcmljLCBpc1JlY3RPYmplY3QsIG1lcmdlQXJpYUxhYmVsQ29uZmlnLCBub2RlSGFzRGltZW5zaW9ucywgbm9kZVRvQm94LCBub2RlVG9SZWN0LCBvcHBvc2l0ZVBvc2l0aW9uLCBwYW5CeSwgcG9pbnRUb1JlbmRlcmVyUG9pbnQsIHJlY29ubmVjdEVkZ2UsIHJlY3RUb0JveCwgcmVuZGVyZXJQb2ludFRvUG9pbnQsIHNoYWxsb3dOb2RlRGF0YSwgc25hcFBvc2l0aW9uLCB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucywgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cCwgdXBkYXRlTm9kZUludGVybmFscywgd2l0aFJlc29sdmVycyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d393e6a432f7\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludmVuZS1vcmNoZXN0cmF0b3IvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcz9iNWExIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZDM5M2U2YTQzMmY3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/style.css\n");

/***/ })

};
;